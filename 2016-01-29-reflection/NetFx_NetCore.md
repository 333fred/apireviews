```diff
---.NET Framework
+++.NET Core
-namespace Microsoft.Win32 {
- public static class Registry {
-   public static readonly RegistryKey ClassesRoot;
-   public static readonly RegistryKey CurrentConfig;
-   public static readonly RegistryKey CurrentUser;
-   public static readonly RegistryKey DynData;
-   public static readonly RegistryKey LocalMachine;
-   public static readonly RegistryKey PerformanceData;
-   public static readonly RegistryKey Users;
-   public static object GetValue(string keyName, string valueName, object defaultValue);
-   public static void SetValue(string keyName, string valueName, object value);
-   public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
  }
- public enum RegistryHive {
-   ClassesRoot = -2147483648,
-   CurrentConfig = -2147483643,
-   CurrentUser = -2147483647,
-   DynData = -2147483642,
-   LocalMachine = -2147483646,
-   PerformanceData = -2147483644,
-   Users = -2147483645,
  }
- public sealed class RegistryKey : MarshalByRefObject, IDisposable {
-   public SafeRegistryHandle Handle { get; }
-   public string Name { get; }
-   public int SubKeyCount { get; }
-   public int ValueCount { get; }
-   public RegistryView View { get; }
-   public void Close();
-   public RegistryKey CreateSubKey(string subkey);
-   public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck);
-   public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions options);
-   public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity);
-   public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity);
-   public RegistryKey CreateSubKey(string subkey, bool writable);
-   public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
-   public void DeleteSubKey(string subkey);
-   public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
-   public void DeleteSubKeyTree(string subkey);
-   public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
-   public void DeleteValue(string name);
-   public void DeleteValue(string name, bool throwOnMissingValue);
-   public void Dispose();
-   public void Flush();
-   public static RegistryKey FromHandle(SafeRegistryHandle handle);
-   public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
-   public RegistrySecurity GetAccessControl();
-   public RegistrySecurity GetAccessControl(AccessControlSections includeSections);
-   public string[] GetSubKeyNames();
-   public object GetValue(string name);
-   public object GetValue(string name, object defaultValue);
-   public object GetValue(string name, object defaultValue, RegistryValueOptions options);
-   public RegistryValueKind GetValueKind(string name);
-   public string[] GetValueNames();
-   public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
-   public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName);
-   public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view);
-   public RegistryKey OpenSubKey(string name);
-   public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck);
-   public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights);
-   public RegistryKey OpenSubKey(string name, bool writable);
-   public RegistryKey OpenSubKey(string name, RegistryRights rights);
-   public void SetAccessControl(RegistrySecurity registrySecurity);
-   public void SetValue(string name, object value);
-   public void SetValue(string name, object value, RegistryValueKind valueKind);
-   public override string ToString();
  }
- public enum RegistryKeyPermissionCheck {
-   Default = 0,
-   ReadSubTree = 1,
-   ReadWriteSubTree = 2,
  }
- public enum RegistryOptions {
-   None = 0,
-   Volatile = 1,
  }
- public enum RegistryValueKind {
-   Binary = 3,
-   DWord = 4,
-   ExpandString = 2,
-   MultiString = 7,
-   None = -1,
-   QWord = 11,
-   String = 1,
-   Unknown = 0,
  }
- public enum RegistryValueOptions {
-   DoNotExpandEnvironmentNames = 1,
-   None = 0,
  }
- public enum RegistryView {
-   Default = 0,
-   Registry32 = 512,
-   Registry64 = 256,
  }
 }
-namespace Microsoft.Win32.SafeHandles {
- public abstract class CriticalHandleMinusOneIsInvalid : CriticalHandle {
-   protected CriticalHandleMinusOneIsInvalid();
-   public override bool IsInvalid { get; }
  }
- public abstract class CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
-   protected CriticalHandleZeroOrMinusOneIsInvalid();
-   public override bool IsInvalid { get; }
  }
- public sealed class SafeAccessTokenHandle : SafeHandle {
-   public SafeAccessTokenHandle(IntPtr handle);
-   public static SafeAccessTokenHandle InvalidHandle { get; }
-   public override bool IsInvalid { get; }
-   protected override bool ReleaseHandle();
  }
- public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
-   public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
-   protected override bool ReleaseHandle();
  }
- public abstract class SafeHandleMinusOneIsInvalid : SafeHandle {
-   protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
-   public override bool IsInvalid { get; }
  }
- public abstract class SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
-   protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
-   public override bool IsInvalid { get; }
  }
- public sealed class SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
-   public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
-   protected override bool ReleaseHandle();
  }
- public sealed class SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
-   public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
-   protected override bool ReleaseHandle();
  }
 }
 namespace System {
- public interface _AppDomain {
-   string BaseDirectory { get; }
-   string DynamicDirectory { get; }
-   Evidence Evidence { get; }
-   string FriendlyName { get; }
-   string RelativeSearchPath { get; }
-   bool ShadowCopyFiles { get; }
-   event AssemblyLoadEventHandler AssemblyLoad;
-   event ResolveEventHandler AssemblyResolve;
-   event EventHandler DomainUnload;
-   event EventHandler ProcessExit;
-   event ResolveEventHandler ResourceResolve;
-   event ResolveEventHandler TypeResolve;
-   event UnhandledExceptionEventHandler UnhandledException;
-   void AppendPrivatePath(string path);
-   void ClearPrivatePath();
-   void ClearShadowCopyPath();
-   ObjectHandle CreateInstance(string assemblyName, string typeName);
-   ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
-   ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
-   ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
-   void DoCallBack(CrossAppDomainDelegate theDelegate);
-   bool Equals(object other);
-   int ExecuteAssembly(string assemblyFile);
-   int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
-   int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args);
-   Assembly[] GetAssemblies();
-   object GetData(string name);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   object GetLifetimeService();
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   object InitializeLifetimeService();
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   Assembly Load(byte[] rawAssembly);
-   Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
-   Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
-   Assembly Load(AssemblyName assemblyRef);
-   Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
-   Assembly Load(string assemblyString);
-   Assembly Load(string assemblyString, Evidence assemblySecurity);
-   void SetAppDomainPolicy(PolicyLevel domainPolicy);
-   void SetCachePath(string s);
-   void SetData(string name, object data);
-   void SetPrincipalPolicy(PrincipalPolicy policy);
-   void SetShadowCopyPath(string s);
-   void SetThreadPrincipal(IPrincipal principal);
-   string ToString();
  }
- public class AccessViolationException : SystemException {
-   public AccessViolationException();
-   protected AccessViolationException(SerializationInfo info, StreamingContext context);
-   public AccessViolationException(string message);
-   public AccessViolationException(string message, Exception innerException);
  }
  public delegate void Action();
  public delegate void Action<in T>(T obj);
  public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);
  public delegate void Action<in T1, in T2, in T3>(T1 arg1, T2 arg2, T3 arg3);
  public delegate void Action<in T1, in T2, in T3, in T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
  public delegate void Action<in T1, in T2, in T3, in T4, in T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
  public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
  public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
  public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
+ public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
- public sealed class ActivationContext : IDisposable, ISerializable {
-   public byte[] ApplicationManifestBytes { get; }
-   public byte[] DeploymentManifestBytes { get; }
-   public ActivationContext.ContextForm Form { get; }
-   public ApplicationIdentity Identity { get; }
-   public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity);
-   public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, string[] manifestPaths);
-   public void Dispose();
-   ~ActivationContext();
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public enum ContextForm {
-     Loose = 0,
-     StoreBounded = 1,
    }
  }
  public sealedstatic class Activator : _Activator {
-   public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
-   public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   public static ObjectHandle CreateInstance(ActivationContext activationContext);
-   public static ObjectHandle CreateInstance(ActivationContext activationContext, string[] activationCustomData);
-   public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName);
-   public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   [MethodImpl(NoInlining)]public static ObjectHandle CreateInstance(string assemblyName, string typeName);
-   [MethodImpl(NoInlining)]public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   [MethodImpl(NoInlining)]public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityInfo);
-   [MethodImpl(NoInlining)]public static ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
    public static object CreateInstance(Type type);
-   [MethodImpl(NoInlining)]public static object CreateInstance(Type type, bool nonPublic);
    public static object CreateInstance(Type type, params object[] args);
-   public static object CreateInstance(Type type, object[] args, object[] activationAttributes);
-   public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture);
-   [MethodImpl(NoInlining)]public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   [MethodImpl(NoInlining)]public static T CreateInstance<T>();
-   public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName);
-   public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
-   public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityInfo);
-   public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
-   public static object GetObject(Type type, string url);
-   public static object GetObject(Type type, string url, object state);
-   void System.Runtime.InteropServices._Activator.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._Activator.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._Activator.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._Activator.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public class AggregateException : Exception {
-   public AggregateException();
-   public AggregateException(IEnumerable<Exception> innerExceptions);
-   public AggregateException(params Exception[] innerExceptions);
-   protected AggregateException(SerializationInfo info, StreamingContext context);
-   public AggregateException(string message);
-   public AggregateException(string message, IEnumerable<Exception> innerExceptions);
-   public AggregateException(string message, Exception innerException);
-   public AggregateException(string message, params Exception[] innerExceptions);
-   public ReadOnlyCollection<Exception> InnerExceptions { get; }
-   public AggregateException Flatten();
-   public override Exception GetBaseException();
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
-   public void Handle(Func<Exception, bool> predicate);
-   public override string ToString();
  }
- public static class AppContext {
-   public static string BaseDirectory { get; }
-   public static void SetSwitch(string switchName, bool isEnabled);
-   public static bool TryGetSwitch(string switchName, out bool isEnabled);
  }
- public sealed class AppDomain : MarshalByRefObject, _AppDomain, IEvidenceFactory {
-   public ActivationContext ActivationContext { get; }
-   public ApplicationIdentity ApplicationIdentity { get; }
-   public ApplicationTrust ApplicationTrust { get; }
-   public string BaseDirectory { get; }
-   public static AppDomain CurrentDomain { get; }
-   public AppDomainManager DomainManager { get; }
-   public string DynamicDirectory { get; }
-   public Evidence Evidence { get; }
-   public string FriendlyName { get; }
-   public int Id { get; }
-   public bool IsFullyTrusted { get; }
-   public bool IsHomogenous { get; }
-   public static bool MonitoringIsEnabled { get; set; }
-   public long MonitoringSurvivedMemorySize { get; }
-   public static long MonitoringSurvivedProcessMemorySize { get; }
-   public long MonitoringTotalAllocatedMemorySize { get; }
-   public TimeSpan MonitoringTotalProcessorTime { get; }
-   public PermissionSet PermissionSet { get; }
-   public string RelativeSearchPath { get; }
-   public AppDomainSetup SetupInformation { get; }
-   public bool ShadowCopyFiles { get; }
-   public event AssemblyLoadEventHandler AssemblyLoad;
-   public event ResolveEventHandler AssemblyResolve;
-   public event EventHandler DomainUnload;
-   public event EventHandler<FirstChanceExceptionEventArgs> FirstChanceException;
-   public event EventHandler ProcessExit;
-   public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
-   public event ResolveEventHandler ResourceResolve;
-   public event ResolveEventHandler TypeResolve;
-   public event UnhandledExceptionEventHandler UnhandledException;
-   public void AppendPrivatePath(string path);
-   public string ApplyPolicy(string assemblyName);
-   public void ClearPrivatePath();
-   public void ClearShadowCopyPath();
-   public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
-   public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   public static AppDomain CreateDomain(string friendlyName);
-   public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo);
-   public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info);
-   public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, params StrongName[] fullTrustAssemblies);
-   public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
-   public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
-   public ObjectHandle CreateInstance(string assemblyName, string typeName);
-   public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   public ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
-   public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
-   public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   public object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
-   public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
-   public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
-   public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName);
-   public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
-   public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes, SecurityContextSource securityContextSource);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, bool isSynchronized, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
-   [MethodImpl(NoInlining)]public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
-   public void DoCallBack(CrossAppDomainDelegate callBackDelegate);
-   public int ExecuteAssembly(string assemblyFile);
-   public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
-   public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args);
-   public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   public int ExecuteAssembly(string assemblyFile, string[] args);
-   public int ExecuteAssembly(string assemblyFile, string[] args, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, params string[] args);
-   public int ExecuteAssemblyByName(AssemblyName assemblyName, params string[] args);
-   public int ExecuteAssemblyByName(string assemblyName);
-   public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity);
-   public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, params string[] args);
-   public int ExecuteAssemblyByName(string assemblyName, params string[] args);
-   public Assembly[] GetAssemblies();
-   [DllImport("kernel32.dll")][MethodImpl(PreserveSig)]public static int GetCurrentThreadId();
-   public object GetData(string name);
-   public new Type GetType();
-   public override object InitializeLifetimeService();
-   public Nullable<bool> IsCompatibilitySwitchSet(string value);
-   public bool IsDefaultAppDomain();
-   [MethodImpl(InternalCall)]public bool IsFinalizingForUnload();
-   [MethodImpl(NoInlining)]public Assembly Load(byte[] rawAssembly);
-   [MethodImpl(NoInlining)]public Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
-   [MethodImpl(NoInlining)]public Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
-   [MethodImpl(NoInlining)]public Assembly Load(AssemblyName assemblyRef);
-   [MethodImpl(NoInlining)]public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
-   [MethodImpl(NoInlining)]public Assembly Load(string assemblyString);
-   [MethodImpl(NoInlining)]public Assembly Load(string assemblyString, Evidence assemblySecurity);
-   public Assembly[] ReflectionOnlyGetAssemblies();
-   public void SetAppDomainPolicy(PolicyLevel domainPolicy);
-   public void SetCachePath(string path);
-   public void SetData(string name, object data);
-   public void SetData(string name, object data, IPermission permission);
-   public void SetDynamicBase(string path);
-   public void SetPrincipalPolicy(PrincipalPolicy policy);
-   public void SetShadowCopyFiles();
-   public void SetShadowCopyPath(string path);
-   public void SetThreadPrincipal(IPrincipal principal);
-   void System._AppDomain.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System._AppDomain.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System._AppDomain.GetTypeInfoCount(out uint pcTInfo);
-   void System._AppDomain.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
-   public static void Unload(AppDomain domain);
  }
- public delegate void AppDomainInitializer(string[] args);
- public class AppDomainManager : MarshalByRefObject {
-   public AppDomainManager();
-   public virtual ApplicationActivator ApplicationActivator { get; }
-   public virtual Assembly EntryAssembly { get; }
-   public virtual HostExecutionContextManager HostExecutionContextManager { get; }
-   public virtual HostSecurityManager HostSecurityManager { get; }
-   public AppDomainManagerInitializationOptions InitializationFlags { get; set; }
-   public virtual bool CheckSecuritySettings(SecurityState state);
-   public virtual AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
-   protected static AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
-   public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
  }
- public enum AppDomainManagerInitializationOptions {
-   None = 0,
-   RegisterWithHost = 1,
  }
- public sealed class AppDomainSetup : IAppDomainSetup {
-   public AppDomainSetup();
-   public AppDomainSetup(ActivationContext activationContext);
-   public AppDomainSetup(ActivationArguments activationArguments);
-   public ActivationArguments ActivationArguments { get; set; }
-   public AppDomainInitializer AppDomainInitializer { get; set; }
-   public string[] AppDomainInitializerArguments { get; set; }
-   public string AppDomainManagerAssembly { get; set; }
-   public string AppDomainManagerType { get; set; }
-   public string ApplicationBase { get; set; }
-   public string ApplicationName { get; set; }
-   public ApplicationTrust ApplicationTrust { get; set; }
-   public string CachePath { get; set; }
-   public string ConfigurationFile { get; set; }
-   public bool DisallowApplicationBaseProbing { get; set; }
-   public bool DisallowBindingRedirects { get; set; }
-   public bool DisallowCodeDownload { get; set; }
-   public bool DisallowPublisherPolicy { get; set; }
-   public string DynamicBase { get; set; }
-   public string LicenseFile { get; set; }
-   public LoaderOptimization LoaderOptimization { get; set; }
-   public string[] PartialTrustVisibleAssemblies { get; set; }
-   public string PrivateBinPath { get; set; }
-   public string PrivateBinPathProbe { get; set; }
-   public bool SandboxInterop { get; set; }
-   public string ShadowCopyDirectories { get; set; }
-   public string ShadowCopyFiles { get; set; }
-   public string TargetFrameworkName { get; set; }
-   public byte[] GetConfigurationBytes();
-   public void SetCompatibilitySwitches(IEnumerable<string> switches);
-   public void SetConfigurationBytes(byte[] value);
-   public void SetNativeFunction(string functionName, int functionVersion, IntPtr functionPointer);
  }
- public class AppDomainUnloadedException : SystemException {
-   public AppDomainUnloadedException();
-   protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
-   public AppDomainUnloadedException(string message);
-   public AppDomainUnloadedException(string message, Exception innerException);
  }
- public class ApplicationException : Exception {
-   public ApplicationException();
-   protected ApplicationException(SerializationInfo info, StreamingContext context);
-   public ApplicationException(string message);
-   public ApplicationException(string message, Exception innerException);
  }
- public sealed class ApplicationId {
-   public ApplicationId(byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
-   public string Culture { get; }
-   public string Name { get; }
-   public string ProcessorArchitecture { get; }
-   public byte[] PublicKeyToken { get; }
-   public Version Version { get; }
-   public ApplicationId Copy();
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class ApplicationIdentity : ISerializable {
-   public ApplicationIdentity(string applicationIdentityFullName);
-   public string CodeBase { get; }
-   public string FullName { get; }
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ArgIterator {
-   public ArgIterator(RuntimeArgumentHandle arglist);
-   public unsafe ArgIterator(RuntimeArgumentHandle arglist, void* ptr);
-   public void End();
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public TypedReference GetNextArg();
-   public TypedReference GetNextArg(RuntimeTypeHandle rth);
-   public RuntimeTypeHandle GetNextArgType();
-   [MethodImpl(InternalCall)]public int GetRemainingCount();
  }
  public class ArgumentException : SystemExceptionException, ISerializable {
    public ArgumentException();
-   protected ArgumentException(SerializationInfo info, StreamingContext context);
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName);
    public ArgumentException(string message, string paramName, Exception innerException);
    public override string Message { get; }
    public virtual string ParamName { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class ArgumentNullException : ArgumentException {
    public ArgumentNullException();
-   protected ArgumentNullException(SerializationInfo info, StreamingContext context);
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
  }
  public class ArgumentOutOfRangeException : ArgumentException, ISerializable {
    public ArgumentOutOfRangeException();
-   protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public ArgumentOutOfRangeException(string paramName, string message);
    public virtual object ActualValue { get; }
    public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class ArithmeticException : SystemExceptionException {
    public ArithmeticException();
-   protected ArithmeticException(SerializationInfo info, StreamingContext context);
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
  }
  public abstract class Array : ICloneable, ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable {
-   public bool IsFixedSize { get; }
-   public bool IsReadOnly { get; }
-   public bool IsSynchronized { get; }
    public int Length { [MethodImpl(InternalCall)]get; }
-   public long LongLength { [MethodImpl(InternalCall)]get; }
    public int Rank { [MethodImpl(InternalCall)]get; }
-   public object SyncRoot { get; }
    int System.Collections.ICollection.Count { get; }
+   bool System.Collections.ICollection.IsSynchronized { get; }
+   object System.Collections.ICollection.SyncRoot { get; }
+   bool System.Collections.IList.IsFixedSize { get; }
+   bool System.Collections.IList.IsReadOnly { get; }
    object System.Collections.IList.this[int index] { get; set; }
-   public static ReadOnlyCollection<T> AsReadOnly<T>(T[] array);
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch<T>(T[] array, int index, int length, T value);
    public static int BinarySearch<T>(T[] array, int index, int length, T value, IComparer<T> comparer);
    public static int BinarySearch<T>(T[] array, T value);
    public static int BinarySearch<T>(T[] array, T value, IComparer<T> comparer);
-   [MethodImpl(InternalCall)]public static void Clear(Array array, int index, int length);
    public object Clone();
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
-   public static TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, Converter<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
-   public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
-   public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public void CopyTo(Array array, int index);
-   public void CopyTo(Array array, long index);
    public static Array CreateInstance(Type elementType, int length);
-   public static Array CreateInstance(Type elementType, int length1, int length2);
-   public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, params int[] lengths);
    public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
-   public static Array CreateInstance(Type elementType, params long[] lengths);
    public static T[] Empty<T>();
    public static bool Exists<T>(T[] array, Predicate<T> match);
    public static T Find<T>(T[] array, Predicate<T> match);
    public static T[] FindAll<T>(T[] array, Predicate<T> match);
    public static int FindIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
    public static int FindIndex<T>(T[] array, int startIndex, Predicate<T> match);
    public static int FindIndex<T>(T[] array, Predicate<T> match);
    public static T FindLast<T>(T[] array, Predicate<T> match);
    public static int FindLastIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
    public static int FindLastIndex<T>(T[] array, int startIndex, Predicate<T> match);
    public static int FindLastIndex<T>(T[] array, Predicate<T> match);
-   public static void ForEach<T>(T[] array, Action<T> action);
    public IEnumerator GetEnumerator();
-   [MethodImpl(InternalCall)]public int GetLength(int dimension);
-   public long GetLongLength(int dimension);
-   [MethodImpl(InternalCall)]public int GetLowerBound(int dimension);
-   [MethodImpl(InternalCall)]public int GetUpperBound(int dimension);
    public object GetValue(int index);
-   public object GetValue(int index1, int index2);
-   public object GetValue(int index1, int index2, int index3);
    public object GetValue(params int[] indices);
-   public object GetValue(long index);
-   public object GetValue(long index1, long index2);
-   public object GetValue(long index1, long index2, long index3);
-   public object GetValue(params long[] indices);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf<T>(T[] array, T value);
    public static int IndexOf<T>(T[] array, T value, int startIndex);
    public static int IndexOf<T>(T[] array, T value, int startIndex, int count);
-   [MethodImpl(InternalCall)]public void Initialize();
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf<T>(T[] array, T value);
    public static int LastIndexOf<T>(T[] array, T value, int startIndex);
    public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count);
    public static void Resize<T>(ref T[] array, int newSize);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public void SetValue(object value, int index);
-   public void SetValue(object value, int index1, int index2);
-   public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, params int[] indices);
-   public void SetValue(object value, long index);
-   public void SetValue(object value, long index1, long index2);
-   public void SetValue(object value, long index1, long index2, long index3);
-   public void SetValue(object value, params long[] indices);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort<T>(T[] array);
    public static void Sort<T>(T[] array, IComparer<T> comparer);
    public static void Sort<T>(T[] array, Comparison<T> comparison);
    public static void Sort<T>(T[] array, int index, int length);
    public static void Sort<T>(T[] array, int index, int length, IComparer<T> comparer);
    public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items);
    public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, IComparer<TKey> comparer);
    public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, IComparer<TKey> comparer);
    int System.Collections.IList.Add(object value);
    void System.Collections.IList.Clear();
    bool System.Collections.IList.Contains(object value);
    int System.Collections.IList.IndexOf(object value);
    void System.Collections.IList.Insert(int index, object value);
    void System.Collections.IList.Remove(object value);
    void System.Collections.IList.RemoveAt(int index);
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static bool TrueForAll<T>(T[] array, Predicate<T> match);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ArraySegment<T> : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
    public ArraySegment(T[] array);
    public ArraySegment(T[] array, int offset, int count);
    public T[] Array { get; }
    public int Count { get; }
    public int Offset { get; }
    bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    T System.Collections.Generic.IList<T>.this[int index] { get; set; }
    T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get; }
    public bool Equals(ArraySegment<T> obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
    public static bool operator ==(ArraySegment<T> a, ArraySegment<T> b);
    public static bool operator !=(ArraySegment<T> a, ArraySegment<T> b);
    void System.Collections.Generic.ICollection<T>.Add(T item);
    void System.Collections.Generic.ICollection<T>.Clear();
    bool System.Collections.Generic.ICollection<T>.Contains(T item);
    void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    bool System.Collections.Generic.ICollection<T>.Remove(T item);
    IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    int System.Collections.Generic.IList<T>.IndexOf(T item);
    void System.Collections.Generic.IList<T>.Insert(int index, T item);
    void System.Collections.Generic.IList<T>.RemoveAt(int index);
    IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
  public class ArrayTypeMismatchException : SystemExceptionException {
    public ArrayTypeMismatchException();
-   protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
  }
- public class AssemblyLoadEventArgs : EventArgs {
-   public AssemblyLoadEventArgs(Assembly loadedAssembly);
-   public Assembly LoadedAssembly { get; }
  }
- public delegate void AssemblyLoadEventHandler(object sender, AssemblyLoadEventArgs args);
  public delegate void AsyncCallback(IAsyncResult ar);
  public abstract class Attribute : _Attribute {
    protected Attribute();
-   public virtual object TypeId { get; }
    public override bool Equals(object obj);
-   public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
-   public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
-   public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
-   public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
-   public static Attribute GetCustomAttribute(Module element, Type attributeType);
-   public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
-   public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
-   public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
-   public static Attribute[] GetCustomAttributes(Assembly element);
-   public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
-   public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
-   public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
-   public static Attribute[] GetCustomAttributes(MemberInfo element);
-   public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
-   public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
-   public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
-   public static Attribute[] GetCustomAttributes(Module element);
-   public static Attribute[] GetCustomAttributes(Module element, bool inherit);
-   public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
-   public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
-   public static Attribute[] GetCustomAttributes(ParameterInfo element);
-   public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
-   public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
-   public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public override int GetHashCode();
-   public virtual bool IsDefaultAttribute();
-   public static bool IsDefined(Assembly element, Type attributeType);
-   public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
-   public static bool IsDefined(MemberInfo element, Type attributeType);
-   public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
-   public static bool IsDefined(Module element, Type attributeType);
-   public static bool IsDefined(Module element, Type attributeType, bool inherit);
-   public static bool IsDefined(ParameterInfo element, Type attributeType);
-   public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
-   public virtual bool Match(object obj);
-   void System.Runtime.InteropServices._Attribute.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._Attribute.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._Attribute.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
  public enum AttributeTargets {
    All = 32767,
    Assembly = 1,
    Class = 4,
    Constructor = 32,
    Delegate = 4096,
    Enum = 16,
    Event = 512,
    Field = 256,
    GenericParameter = 16384,
    Interface = 1024,
    Method = 64,
    Module = 2,
    Parameter = 2048,
    Property = 128,
    ReturnValue = 8192,
    Struct = 8,
  }
  public sealed class AttributeUsageAttribute : Attribute {
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool AllowMultiple { get; set; }
    public bool Inherited { get; set; }
    public AttributeTargets ValidOn { get; }
  }
  public class BadImageFormatException : SystemExceptionException {
    public BadImageFormatException();
-   protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    public string FileName { get; }
-   public string FusionLog { get; }
    public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
    public override string ToString();
  }
- public enum Base64FormattingOptions {
-   InsertLineBreaks = 1,
-   None = 0,
  }
- public static class BitConverter {
-   public static readonly bool IsLittleEndian;
-   public static long DoubleToInt64Bits(double value);
-   public static byte[] GetBytes(bool value);
-   public static byte[] GetBytes(char value);
-   public static byte[] GetBytes(double value);
-   public static byte[] GetBytes(short value);
-   public static byte[] GetBytes(int value);
-   public static byte[] GetBytes(long value);
-   public static byte[] GetBytes(float value);
-   public static byte[] GetBytes(ushort value);
-   public static byte[] GetBytes(uint value);
-   public static byte[] GetBytes(ulong value);
-   public static double Int64BitsToDouble(long value);
-   public static bool ToBoolean(byte[] value, int startIndex);
-   public static char ToChar(byte[] value, int startIndex);
-   public static double ToDouble(byte[] value, int startIndex);
-   public static short ToInt16(byte[] value, int startIndex);
-   public static int ToInt32(byte[] value, int startIndex);
-   public static long ToInt64(byte[] value, int startIndex);
-   public static float ToSingle(byte[] value, int startIndex);
-   public static string ToString(byte[] value);
-   public static string ToString(byte[] value, int startIndex);
-   public static string ToString(byte[] value, int startIndex, int length);
-   public static ushort ToUInt16(byte[] value, int startIndex);
-   public static uint ToUInt32(byte[] value, int startIndex);
-   public static ulong ToUInt64(byte[] value, int startIndex);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Boolean : IComparable, IComparable<bool>, IConvertible, IEquatable<bool> {
    public static readonly string FalseString;
    public static readonly string TrueString;
    public int CompareTo(bool value);
-   public int CompareTo(object obj);
    public bool Equals(bool obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static bool Parse(string value);
+   int System.IComparable.CompareTo(object obj);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
+   string System.IConvertible.ToString(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
-   public string ToString(IFormatProvider provider);
    public static bool TryParse(string value, out bool result);
  }
  public static class Buffer {
-   [MethodImpl(InternalCall)]public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
-   [MethodImpl(AggressiveInlining)]public unsafe static void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
-   [MethodImpl(AggressiveInlining)]public unsafe static void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    public static void SetByte(Array array, int index, byte value);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable {
    public const byte MaxValue = (byte)255;
    public const byte MinValue = (byte)0;
    public int CompareTo(byte value);
-   public int CompareTo(object value);
    public bool Equals(byte obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, out byte result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out byte result);
  }
- public class CannotUnloadAppDomainException : SystemException {
-   public CannotUnloadAppDomainException();
-   protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
-   public CannotUnloadAppDomainException(string message);
-   public CannotUnloadAppDomainException(string message, Exception innerException);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Char : IComparable, IComparable<char>, IConvertible, IEquatable<char> {
    public const char MaxValue = '\uFFFF';
    public const char MinValue = '\0';
    public int CompareTo(char value);
-   public int CompareTo(object value);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
    public bool Equals(char obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
-   public TypeCode GetTypeCode();
-   public static UnicodeCategory GetUnicodeCategory(char c);
-   public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(char c);
    public static bool IsDigit(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLetter(char c);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(char c);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(char c);
    public static bool IsLower(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(char c);
    public static bool IsPunctuation(string s, int index);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(char c);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(char c);
    public static bool IsWhiteSpace(string s, int index);
    public static char Parse(string s);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
+   string System.IConvertible.ToString(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static char ToLower(char c);
-   public static char ToLower(char c, CultureInfo culture);
    public static char ToLowerInvariant(char c);
    public override string ToString();
    public static string ToString(char c);
-   public string ToString(IFormatProvider provider);
    public static char ToUpper(char c);
-   public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpperInvariant(char c);
    public static bool TryParse(string s, out char result);
  }
- public sealed class CharEnumerator : ICloneable, IDisposable, IEnumerator, IEnumerator<char> {
-   public char Current { get; }
-   object System.Collections.IEnumerator.Current { get; }
-   public object Clone();
-   public void Dispose();
-   public bool MoveNext();
-   public void Reset();
  }
  public sealed class CLSCompliantAttribute : Attribute {
    public CLSCompliantAttribute(bool isCompliant);
    public bool IsCompliant { get; }
  }
  public delegate int Comparison<in T>(T x, T y);
- public static class Console {
-   public static ConsoleColor BackgroundColor { get; set; }
-   public static int BufferHeight { get; set; }
-   public static int BufferWidth { get; set; }
-   public static bool CapsLock { get; }
-   public static int CursorLeft { get; set; }
-   public static int CursorSize { get; set; }
-   public static int CursorTop { get; set; }
-   public static bool CursorVisible { get; set; }
-   public static TextWriter Error { get; }
-   public static ConsoleColor ForegroundColor { get; set; }
-   public static TextReader In { get; }
-   public static Encoding InputEncoding { get; set; }
-   public static bool IsErrorRedirected { get; }
-   public static bool IsInputRedirected { get; }
-   public static bool IsOutputRedirected { get; }
-   public static bool KeyAvailable { get; }
-   public static int LargestWindowHeight { get; }
-   public static int LargestWindowWidth { get; }
-   public static bool NumberLock { get; }
-   public static TextWriter Out { get; }
-   public static Encoding OutputEncoding { get; set; }
-   public static string Title { get; set; }
-   public static bool TreatControlCAsInput { get; set; }
-   public static int WindowHeight { get; set; }
-   public static int WindowLeft { get; set; }
-   public static int WindowTop { get; set; }
-   public static int WindowWidth { get; set; }
-   public static event ConsoleCancelEventHandler CancelKeyPress;
-   public static void Beep();
-   public static void Beep(int frequency, int duration);
-   public static void Clear();
-   public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
-   public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
-   public static Stream OpenStandardError();
-   public static Stream OpenStandardError(int bufferSize);
-   public static Stream OpenStandardInput();
-   public static Stream OpenStandardInput(int bufferSize);
-   public static Stream OpenStandardOutput();
-   public static Stream OpenStandardOutput(int bufferSize);
-   [MethodImpl(NoInlining)]public static int Read();
-   public static ConsoleKeyInfo ReadKey();
-   public static ConsoleKeyInfo ReadKey(bool intercept);
-   [MethodImpl(NoInlining)]public static string ReadLine();
-   public static void ResetColor();
-   public static void SetBufferSize(int width, int height);
-   public static void SetCursorPosition(int left, int top);
-   public static void SetError(TextWriter newError);
-   public static void SetIn(TextReader newIn);
-   public static void SetOut(TextWriter newOut);
-   public static void SetWindowPosition(int left, int top);
-   public static void SetWindowSize(int width, int height);
-   [MethodImpl(NoInlining)]public static void Write(bool value);
-   [MethodImpl(NoInlining)]public static void Write(char value);
-   [MethodImpl(NoInlining)]public static void Write(char[] buffer);
-   [MethodImpl(NoInlining)]public static void Write(char[] buffer, int index, int count);
-   [MethodImpl(NoInlining)]public static void Write(decimal value);
-   [MethodImpl(NoInlining)]public static void Write(double value);
-   [MethodImpl(NoInlining)]public static void Write(int value);
-   [MethodImpl(NoInlining)]public static void Write(long value);
-   [MethodImpl(NoInlining)]public static void Write(object value);
-   [MethodImpl(NoInlining)]public static void Write(float value);
-   [MethodImpl(NoInlining)]public static void Write(string value);
-   [MethodImpl(NoInlining)]public static void Write(string format, object arg0);
-   [MethodImpl(NoInlining)]public static void Write(string format, object arg0, object arg1);
-   [MethodImpl(NoInlining)]public static void Write(string format, object arg0, object arg1, object arg2);
-   [MethodImpl(NoInlining)]public static void Write(string format, object arg0, object arg1, object arg2, object arg3, __arglist);
-   [MethodImpl(NoInlining)]public static void Write(string format, params object[] arg);
-   [MethodImpl(NoInlining)]public static void Write(uint value);
-   [MethodImpl(NoInlining)]public static void Write(ulong value);
-   [MethodImpl(NoInlining)]public static void WriteLine();
-   [MethodImpl(NoInlining)]public static void WriteLine(bool value);
-   [MethodImpl(NoInlining)]public static void WriteLine(char value);
-   [MethodImpl(NoInlining)]public static void WriteLine(char[] buffer);
-   [MethodImpl(NoInlining)]public static void WriteLine(char[] buffer, int index, int count);
-   [MethodImpl(NoInlining)]public static void WriteLine(decimal value);
-   [MethodImpl(NoInlining)]public static void WriteLine(double value);
-   [MethodImpl(NoInlining)]public static void WriteLine(int value);
-   [MethodImpl(NoInlining)]public static void WriteLine(long value);
-   [MethodImpl(NoInlining)]public static void WriteLine(object value);
-   [MethodImpl(NoInlining)]public static void WriteLine(float value);
-   [MethodImpl(NoInlining)]public static void WriteLine(string value);
-   [MethodImpl(NoInlining)]public static void WriteLine(string format, object arg0);
-   [MethodImpl(NoInlining)]public static void WriteLine(string format, object arg0, object arg1);
-   [MethodImpl(NoInlining)]public static void WriteLine(string format, object arg0, object arg1, object arg2);
-   [MethodImpl(NoInlining)]public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3, __arglist);
-   [MethodImpl(NoInlining)]public static void WriteLine(string format, params object[] arg);
-   [MethodImpl(NoInlining)]public static void WriteLine(uint value);
-   [MethodImpl(NoInlining)]public static void WriteLine(ulong value);
  }
- public sealed class ConsoleCancelEventArgs : EventArgs {
-   public bool Cancel { get; set; }
-   public ConsoleSpecialKey SpecialKey { get; }
  }
- public delegate void ConsoleCancelEventHandler(object sender, ConsoleCancelEventArgs e);
- public enum ConsoleColor {
-   Black = 0,
-   Blue = 9,
-   Cyan = 11,
-   DarkBlue = 1,
-   DarkCyan = 3,
-   DarkGray = 8,
-   DarkGreen = 2,
-   DarkMagenta = 5,
-   DarkRed = 4,
-   DarkYellow = 6,
-   Gray = 7,
-   Green = 10,
-   Magenta = 13,
-   Red = 12,
-   White = 15,
-   Yellow = 14,
  }
- public enum ConsoleKey {
-   A = 65,
-   Add = 107,
-   Applications = 93,
-   Attention = 246,
-   B = 66,
-   Backspace = 8,
-   BrowserBack = 166,
-   BrowserFavorites = 171,
-   BrowserForward = 167,
-   BrowserHome = 172,
-   BrowserRefresh = 168,
-   BrowserSearch = 170,
-   BrowserStop = 169,
-   C = 67,
-   Clear = 12,
-   CrSel = 247,
-   D = 68,
-   D0 = 48,
-   D1 = 49,
-   D2 = 50,
-   D3 = 51,
-   D4 = 52,
-   D5 = 53,
-   D6 = 54,
-   D7 = 55,
-   D8 = 56,
-   D9 = 57,
-   Decimal = 110,
-   Delete = 46,
-   Divide = 111,
-   DownArrow = 40,
-   E = 69,
-   End = 35,
-   Enter = 13,
-   EraseEndOfFile = 249,
-   Escape = 27,
-   Execute = 43,
-   ExSel = 248,
-   F = 70,
-   F1 = 112,
-   F10 = 121,
-   F11 = 122,
-   F12 = 123,
-   F13 = 124,
-   F14 = 125,
-   F15 = 126,
-   F16 = 127,
-   F17 = 128,
-   F18 = 129,
-   F19 = 130,
-   F2 = 113,
-   F20 = 131,
-   F21 = 132,
-   F22 = 133,
-   F23 = 134,
-   F24 = 135,
-   F3 = 114,
-   F4 = 115,
-   F5 = 116,
-   F6 = 117,
-   F7 = 118,
-   F8 = 119,
-   F9 = 120,
-   G = 71,
-   H = 72,
-   Help = 47,
-   Home = 36,
-   I = 73,
-   Insert = 45,
-   J = 74,
-   K = 75,
-   L = 76,
-   LaunchApp1 = 182,
-   LaunchApp2 = 183,
-   LaunchMail = 180,
-   LaunchMediaSelect = 181,
-   LeftArrow = 37,
-   LeftWindows = 91,
-   M = 77,
-   MediaNext = 176,
-   MediaPlay = 179,
-   MediaPrevious = 177,
-   MediaStop = 178,
-   Multiply = 106,
-   N = 78,
-   NoName = 252,
-   NumPad0 = 96,
-   NumPad1 = 97,
-   NumPad2 = 98,
-   NumPad3 = 99,
-   NumPad4 = 100,
-   NumPad5 = 101,
-   NumPad6 = 102,
-   NumPad7 = 103,
-   NumPad8 = 104,
-   NumPad9 = 105,
-   O = 79,
-   Oem1 = 186,
-   Oem102 = 226,
-   Oem2 = 191,
-   Oem3 = 192,
-   Oem4 = 219,
-   Oem5 = 220,
-   Oem6 = 221,
-   Oem7 = 222,
-   Oem8 = 223,
-   OemClear = 254,
-   OemComma = 188,
-   OemMinus = 189,
-   OemPeriod = 190,
-   OemPlus = 187,
-   P = 80,
-   Pa1 = 253,
-   Packet = 231,
-   PageDown = 34,
-   PageUp = 33,
-   Pause = 19,
-   Play = 250,
-   Print = 42,
-   PrintScreen = 44,
-   Process = 229,
-   Q = 81,
-   R = 82,
-   RightArrow = 39,
-   RightWindows = 92,
-   S = 83,
-   Select = 41,
-   Separator = 108,
-   Sleep = 95,
-   Spacebar = 32,
-   Subtract = 109,
-   T = 84,
-   Tab = 9,
-   U = 85,
-   UpArrow = 38,
-   V = 86,
-   VolumeDown = 174,
-   VolumeMute = 173,
-   VolumeUp = 175,
-   W = 87,
-   X = 88,
-   Y = 89,
-   Z = 90,
-   Zoom = 251,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ConsoleKeyInfo {
-   public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
-   public ConsoleKey Key { get; }
-   public char KeyChar { get; }
-   public ConsoleModifiers Modifiers { get; }
-   public bool Equals(ConsoleKeyInfo obj);
-   public override bool Equals(object value);
-   public override int GetHashCode();
-   public static bool operator ==(ConsoleKeyInfo a, ConsoleKeyInfo b);
-   public static bool operator !=(ConsoleKeyInfo a, ConsoleKeyInfo b);
  }
- public enum ConsoleModifiers {
-   Alt = 1,
-   Control = 4,
-   Shift = 2,
  }
- public enum ConsoleSpecialKey {
-   ControlBreak = 1,
-   ControlC = 0,
  }
- public abstract class ContextBoundObject : MarshalByRefObject {
-   protected ContextBoundObject();
  }
- public class ContextMarshalException : SystemException {
-   public ContextMarshalException();
-   protected ContextMarshalException(SerializationInfo info, StreamingContext context);
-   public ContextMarshalException(string message);
-   public ContextMarshalException(string message, Exception inner);
  }
- public class ContextStaticAttribute : Attribute {
-   public ContextStaticAttribute();
  }
- public static class Convert {
-   public static readonly object DBNull;
-   public static object ChangeType(object value, Type conversionType);
-   public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
-   public static object ChangeType(object value, TypeCode typeCode);
-   public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
-   public static byte[] FromBase64CharArray(char[] inArray, int offset, int length);
-   public static byte[] FromBase64String(string s);
-   public static TypeCode GetTypeCode(object value);
-   public static bool IsDBNull(object value);
-   public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);
-   public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, Base64FormattingOptions options);
-   public static string ToBase64String(byte[] inArray);
-   public static string ToBase64String(byte[] inArray, Base64FormattingOptions options);
-   public static string ToBase64String(byte[] inArray, int offset, int length);
-   public static string ToBase64String(byte[] inArray, int offset, int length, Base64FormattingOptions options);
-   public static bool ToBoolean(bool value);
-   public static bool ToBoolean(byte value);
-   public static bool ToBoolean(char value);
-   public static bool ToBoolean(DateTime value);
-   public static bool ToBoolean(decimal value);
-   public static bool ToBoolean(double value);
-   public static bool ToBoolean(short value);
-   public static bool ToBoolean(int value);
-   public static bool ToBoolean(long value);
-   public static bool ToBoolean(object value);
-   public static bool ToBoolean(object value, IFormatProvider provider);
-   public static bool ToBoolean(sbyte value);
-   public static bool ToBoolean(float value);
-   public static bool ToBoolean(string value);
-   public static bool ToBoolean(string value, IFormatProvider provider);
-   public static bool ToBoolean(ushort value);
-   public static bool ToBoolean(uint value);
-   public static bool ToBoolean(ulong value);
-   public static byte ToByte(bool value);
-   public static byte ToByte(byte value);
-   public static byte ToByte(char value);
-   public static byte ToByte(DateTime value);
-   public static byte ToByte(decimal value);
-   public static byte ToByte(double value);
-   public static byte ToByte(short value);
-   public static byte ToByte(int value);
-   public static byte ToByte(long value);
-   public static byte ToByte(object value);
-   public static byte ToByte(object value, IFormatProvider provider);
-   public static byte ToByte(sbyte value);
-   public static byte ToByte(float value);
-   public static byte ToByte(string value);
-   public static byte ToByte(string value, IFormatProvider provider);
-   public static byte ToByte(string value, int fromBase);
-   public static byte ToByte(ushort value);
-   public static byte ToByte(uint value);
-   public static byte ToByte(ulong value);
-   public static char ToChar(bool value);
-   public static char ToChar(byte value);
-   public static char ToChar(char value);
-   public static char ToChar(DateTime value);
-   public static char ToChar(decimal value);
-   public static char ToChar(double value);
-   public static char ToChar(short value);
-   public static char ToChar(int value);
-   public static char ToChar(long value);
-   public static char ToChar(object value);
-   public static char ToChar(object value, IFormatProvider provider);
-   public static char ToChar(sbyte value);
-   public static char ToChar(float value);
-   public static char ToChar(string value);
-   public static char ToChar(string value, IFormatProvider provider);
-   public static char ToChar(ushort value);
-   public static char ToChar(uint value);
-   public static char ToChar(ulong value);
-   public static DateTime ToDateTime(bool value);
-   public static DateTime ToDateTime(byte value);
-   public static DateTime ToDateTime(char value);
-   public static DateTime ToDateTime(DateTime value);
-   public static DateTime ToDateTime(decimal value);
-   public static DateTime ToDateTime(double value);
-   public static DateTime ToDateTime(short value);
-   public static DateTime ToDateTime(int value);
-   public static DateTime ToDateTime(long value);
-   public static DateTime ToDateTime(object value);
-   public static DateTime ToDateTime(object value, IFormatProvider provider);
-   public static DateTime ToDateTime(sbyte value);
-   public static DateTime ToDateTime(float value);
-   public static DateTime ToDateTime(string value);
-   public static DateTime ToDateTime(string value, IFormatProvider provider);
-   public static DateTime ToDateTime(ushort value);
-   public static DateTime ToDateTime(uint value);
-   public static DateTime ToDateTime(ulong value);
-   public static decimal ToDecimal(bool value);
-   public static decimal ToDecimal(byte value);
-   public static decimal ToDecimal(char value);
-   public static decimal ToDecimal(DateTime value);
-   public static decimal ToDecimal(decimal value);
-   public static decimal ToDecimal(double value);
-   public static decimal ToDecimal(short value);
-   public static decimal ToDecimal(int value);
-   public static decimal ToDecimal(long value);
-   public static decimal ToDecimal(object value);
-   public static decimal ToDecimal(object value, IFormatProvider provider);
-   public static decimal ToDecimal(sbyte value);
-   public static decimal ToDecimal(float value);
-   public static decimal ToDecimal(string value);
-   public static decimal ToDecimal(string value, IFormatProvider provider);
-   public static decimal ToDecimal(ushort value);
-   public static decimal ToDecimal(uint value);
-   public static decimal ToDecimal(ulong value);
-   public static double ToDouble(bool value);
-   public static double ToDouble(byte value);
-   public static double ToDouble(char value);
-   public static double ToDouble(DateTime value);
-   public static double ToDouble(decimal value);
-   public static double ToDouble(double value);
-   public static double ToDouble(short value);
-   public static double ToDouble(int value);
-   public static double ToDouble(long value);
-   public static double ToDouble(object value);
-   public static double ToDouble(object value, IFormatProvider provider);
-   public static double ToDouble(sbyte value);
-   public static double ToDouble(float value);
-   public static double ToDouble(string value);
-   public static double ToDouble(string value, IFormatProvider provider);
-   public static double ToDouble(ushort value);
-   public static double ToDouble(uint value);
-   public static double ToDouble(ulong value);
-   public static short ToInt16(bool value);
-   public static short ToInt16(byte value);
-   public static short ToInt16(char value);
-   public static short ToInt16(DateTime value);
-   public static short ToInt16(decimal value);
-   public static short ToInt16(double value);
-   public static short ToInt16(short value);
-   public static short ToInt16(int value);
-   public static short ToInt16(long value);
-   public static short ToInt16(object value);
-   public static short ToInt16(object value, IFormatProvider provider);
-   public static short ToInt16(sbyte value);
-   public static short ToInt16(float value);
-   public static short ToInt16(string value);
-   public static short ToInt16(string value, IFormatProvider provider);
-   public static short ToInt16(string value, int fromBase);
-   public static short ToInt16(ushort value);
-   public static short ToInt16(uint value);
-   public static short ToInt16(ulong value);
-   public static int ToInt32(bool value);
-   public static int ToInt32(byte value);
-   public static int ToInt32(char value);
-   public static int ToInt32(DateTime value);
-   public static int ToInt32(decimal value);
-   public static int ToInt32(double value);
-   public static int ToInt32(short value);
-   public static int ToInt32(int value);
-   public static int ToInt32(long value);
-   public static int ToInt32(object value);
-   public static int ToInt32(object value, IFormatProvider provider);
-   public static int ToInt32(sbyte value);
-   public static int ToInt32(float value);
-   public static int ToInt32(string value);
-   public static int ToInt32(string value, IFormatProvider provider);
-   public static int ToInt32(string value, int fromBase);
-   public static int ToInt32(ushort value);
-   public static int ToInt32(uint value);
-   public static int ToInt32(ulong value);
-   public static long ToInt64(bool value);
-   public static long ToInt64(byte value);
-   public static long ToInt64(char value);
-   public static long ToInt64(DateTime value);
-   public static long ToInt64(decimal value);
-   public static long ToInt64(double value);
-   public static long ToInt64(short value);
-   public static long ToInt64(int value);
-   public static long ToInt64(long value);
-   public static long ToInt64(object value);
-   public static long ToInt64(object value, IFormatProvider provider);
-   public static long ToInt64(sbyte value);
-   public static long ToInt64(float value);
-   public static long ToInt64(string value);
-   public static long ToInt64(string value, IFormatProvider provider);
-   public static long ToInt64(string value, int fromBase);
-   public static long ToInt64(ushort value);
-   public static long ToInt64(uint value);
-   public static long ToInt64(ulong value);
-   public static sbyte ToSByte(bool value);
-   public static sbyte ToSByte(byte value);
-   public static sbyte ToSByte(char value);
-   public static sbyte ToSByte(DateTime value);
-   public static sbyte ToSByte(decimal value);
-   public static sbyte ToSByte(double value);
-   public static sbyte ToSByte(short value);
-   public static sbyte ToSByte(int value);
-   public static sbyte ToSByte(long value);
-   public static sbyte ToSByte(object value);
-   public static sbyte ToSByte(object value, IFormatProvider provider);
-   public static sbyte ToSByte(sbyte value);
-   public static sbyte ToSByte(float value);
-   public static sbyte ToSByte(string value);
-   public static sbyte ToSByte(string value, IFormatProvider provider);
-   public static sbyte ToSByte(string value, int fromBase);
-   public static sbyte ToSByte(ushort value);
-   public static sbyte ToSByte(uint value);
-   public static sbyte ToSByte(ulong value);
-   public static float ToSingle(bool value);
-   public static float ToSingle(byte value);
-   public static float ToSingle(char value);
-   public static float ToSingle(DateTime value);
-   public static float ToSingle(decimal value);
-   public static float ToSingle(double value);
-   public static float ToSingle(short value);
-   public static float ToSingle(int value);
-   public static float ToSingle(long value);
-   public static float ToSingle(object value);
-   public static float ToSingle(object value, IFormatProvider provider);
-   public static float ToSingle(sbyte value);
-   public static float ToSingle(float value);
-   public static float ToSingle(string value);
-   public static float ToSingle(string value, IFormatProvider provider);
-   public static float ToSingle(ushort value);
-   public static float ToSingle(uint value);
-   public static float ToSingle(ulong value);
-   public static string ToString(bool value);
-   public static string ToString(bool value, IFormatProvider provider);
-   public static string ToString(byte value);
-   public static string ToString(byte value, IFormatProvider provider);
-   public static string ToString(byte value, int toBase);
-   public static string ToString(char value);
-   public static string ToString(char value, IFormatProvider provider);
-   public static string ToString(DateTime value);
-   public static string ToString(DateTime value, IFormatProvider provider);
-   public static string ToString(decimal value);
-   public static string ToString(decimal value, IFormatProvider provider);
-   public static string ToString(double value);
-   public static string ToString(double value, IFormatProvider provider);
-   public static string ToString(short value);
-   public static string ToString(short value, IFormatProvider provider);
-   public static string ToString(short value, int toBase);
-   public static string ToString(int value);
-   public static string ToString(int value, IFormatProvider provider);
-   public static string ToString(int value, int toBase);
-   public static string ToString(long value);
-   public static string ToString(long value, IFormatProvider provider);
-   public static string ToString(long value, int toBase);
-   public static string ToString(object value);
-   public static string ToString(object value, IFormatProvider provider);
-   public static string ToString(sbyte value);
-   public static string ToString(sbyte value, IFormatProvider provider);
-   public static string ToString(float value);
-   public static string ToString(float value, IFormatProvider provider);
-   public static string ToString(string value);
-   public static string ToString(string value, IFormatProvider provider);
-   public static string ToString(ushort value);
-   public static string ToString(ushort value, IFormatProvider provider);
-   public static string ToString(uint value);
-   public static string ToString(uint value, IFormatProvider provider);
-   public static string ToString(ulong value);
-   public static string ToString(ulong value, IFormatProvider provider);
-   public static ushort ToUInt16(bool value);
-   public static ushort ToUInt16(byte value);
-   public static ushort ToUInt16(char value);
-   public static ushort ToUInt16(DateTime value);
-   public static ushort ToUInt16(decimal value);
-   public static ushort ToUInt16(double value);
-   public static ushort ToUInt16(short value);
-   public static ushort ToUInt16(int value);
-   public static ushort ToUInt16(long value);
-   public static ushort ToUInt16(object value);
-   public static ushort ToUInt16(object value, IFormatProvider provider);
-   public static ushort ToUInt16(sbyte value);
-   public static ushort ToUInt16(float value);
-   public static ushort ToUInt16(string value);
-   public static ushort ToUInt16(string value, IFormatProvider provider);
-   public static ushort ToUInt16(string value, int fromBase);
-   public static ushort ToUInt16(ushort value);
-   public static ushort ToUInt16(uint value);
-   public static ushort ToUInt16(ulong value);
-   public static uint ToUInt32(bool value);
-   public static uint ToUInt32(byte value);
-   public static uint ToUInt32(char value);
-   public static uint ToUInt32(DateTime value);
-   public static uint ToUInt32(decimal value);
-   public static uint ToUInt32(double value);
-   public static uint ToUInt32(short value);
-   public static uint ToUInt32(int value);
-   public static uint ToUInt32(long value);
-   public static uint ToUInt32(object value);
-   public static uint ToUInt32(object value, IFormatProvider provider);
-   public static uint ToUInt32(sbyte value);
-   public static uint ToUInt32(float value);
-   public static uint ToUInt32(string value);
-   public static uint ToUInt32(string value, IFormatProvider provider);
-   public static uint ToUInt32(string value, int fromBase);
-   public static uint ToUInt32(ushort value);
-   public static uint ToUInt32(uint value);
-   public static uint ToUInt32(ulong value);
-   public static ulong ToUInt64(bool value);
-   public static ulong ToUInt64(byte value);
-   public static ulong ToUInt64(char value);
-   public static ulong ToUInt64(DateTime value);
-   public static ulong ToUInt64(decimal value);
-   public static ulong ToUInt64(double value);
-   public static ulong ToUInt64(short value);
-   public static ulong ToUInt64(int value);
-   public static ulong ToUInt64(long value);
-   public static ulong ToUInt64(object value);
-   public static ulong ToUInt64(object value, IFormatProvider provider);
-   public static ulong ToUInt64(sbyte value);
-   public static ulong ToUInt64(float value);
-   public static ulong ToUInt64(string value);
-   public static ulong ToUInt64(string value, IFormatProvider provider);
-   public static ulong ToUInt64(string value, int fromBase);
-   public static ulong ToUInt64(ushort value);
-   public static ulong ToUInt64(uint value);
-   public static ulong ToUInt64(ulong value);
  }
- public delegate TOutput Converter<in TInput, out TOutput>(TInput input);
- public delegate void CrossAppDomainDelegate();
- public sealed class DataMisalignedException : SystemException {
-   public DataMisalignedException();
-   public DataMisalignedException(string message);
-   public DataMisalignedException(string message, Exception innerException);
  }
+ [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
  public struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, ISerializable {
    public static readonly DateTime MaxValue;
    public static readonly DateTime MinValue;
    public DateTime(int year, int month, int day);
-   public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
-   public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
-   public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
-   public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public static DateTime UtcNow { get; }
    public int Year { get; }
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public int CompareTo(DateTime value);
-   public int CompareTo(object value);
    public static int DaysInMonth(int year, int month);
    public bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public override bool Equals(object value);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
-   public static DateTime FromOADate(double d);
    public string[] GetDateTimeFormats();
    public string[] GetDateTimeFormats(char format);
    public string[] GetDateTimeFormats(char format, IFormatProvider provider);
    public string[] GetDateTimeFormats(IFormatProvider provider);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public bool IsDaylightSavingTime();
    public static bool IsLeapYear(int year);
    public static DateTime operator +(DateTime d, TimeSpan t);
    public static bool operator ==(DateTime d1, DateTime d2);
    public static bool operator >(DateTime t1, DateTime t2);
    public static bool operator >=(DateTime t1, DateTime t2);
    public static bool operator !=(DateTime d1, DateTime d2);
    public static bool operator <(DateTime t1, DateTime t2);
    public static bool operator <=(DateTime t1, DateTime t2);
    public static TimeSpan operator -(DateTime d1, DateTime d2);
    public static DateTime operator -(DateTime d, TimeSpan t);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToBinary();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
-   public string ToLongDateString();
-   public string ToLongTimeString();
-   public double ToOADate();
-   public string ToShortDateString();
-   public string ToShortTimeString();
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, out DateTime result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, out DateTime result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, out DateTime result);
    public static bool TryParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style, out DateTime result);
  }
  public enum DateTimeKind {
    Local = 2,
    Unspecified = 0,
    Utc = 1,
  }
+ [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
  public struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, ISerializable {
    public static readonly DateTimeOffset MaxValue;
    public static readonly DateTimeOffset MinValue;
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
-   public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTime Date { get; }
    public DateTime DateTime { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTime LocalDateTime { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTimeOffset Now { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime UtcDateTime { get; }
    public static DateTimeOffset UtcNow { get; }
    public long UtcTicks { get; }
    public int Year { get; }
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    public int CompareTo(DateTimeOffset other);
    public bool Equals(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public override bool Equals(object obj);
    public bool EqualsExact(DateTimeOffset other);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public override int GetHashCode();
    public static DateTimeOffset operator +(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static bool operator ==(DateTimeOffset left, DateTimeOffset right);
    public static bool operator >(DateTimeOffset left, DateTimeOffset right);
    public static bool operator >=(DateTimeOffset left, DateTimeOffset right);
    public static implicit operator DateTimeOffset (DateTime dateTime);
    public static bool operator !=(DateTimeOffset left, DateTimeOffset right);
    public static bool operator <(DateTimeOffset left, DateTimeOffset right);
    public static bool operator <=(DateTimeOffset left, DateTimeOffset right);
    public static TimeSpan operator -(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset operator -(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    int System.IComparable.CompareTo(object obj);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    public override string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public long ToUnixTimeMilliseconds();
    public long ToUnixTimeSeconds();
    public static bool TryParse(string input, out DateTimeOffset result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
    public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
  }
  public enum DayOfWeek {
    Friday = 5,
    Monday = 1,
    Saturday = 6,
    Sunday = 0,
    Thursday = 4,
    Tuesday = 2,
    Wednesday = 3,
  }
- public sealed class DBNull : IConvertible, ISerializable {
-   public static readonly DBNull Value;
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public TypeCode GetTypeCode();
-   bool System.IConvertible.ToBoolean(IFormatProvider provider);
-   byte System.IConvertible.ToByte(IFormatProvider provider);
-   char System.IConvertible.ToChar(IFormatProvider provider);
-   DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
-   decimal System.IConvertible.ToDecimal(IFormatProvider provider);
-   double System.IConvertible.ToDouble(IFormatProvider provider);
-   short System.IConvertible.ToInt16(IFormatProvider provider);
-   int System.IConvertible.ToInt32(IFormatProvider provider);
-   long System.IConvertible.ToInt64(IFormatProvider provider);
-   sbyte System.IConvertible.ToSByte(IFormatProvider provider);
-   float System.IConvertible.ToSingle(IFormatProvider provider);
-   object System.IConvertible.ToType(Type type, IFormatProvider provider);
-   ushort System.IConvertible.ToUInt16(IFormatProvider provider);
-   uint System.IConvertible.ToUInt32(IFormatProvider provider);
-   ulong System.IConvertible.ToUInt64(IFormatProvider provider);
-   public override string ToString();
-   public string ToString(IFormatProvider provider);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Decimal : IComparable, IComparable<decimal>, IConvertible, IDeserializationCallback, IEquatable<decimal>, IFormattable {
    public static readonly decimal MaxValue;
    public static readonly decimal MinusOne;
    public static readonly decimal MinValue;
    public static readonly decimal One;
    public static readonly decimal Zero;
-   [MethodImpl(InternalCall)]public Decimal(double value);
    public Decimal(int value);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    public Decimal(int[] bits);
    public Decimal(long value);
-   [MethodImpl(InternalCall)]public Decimal(float value);
    public Decimal(uint value);
    public Decimal(ulong value);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    public int CompareTo(decimal value);
-   public int CompareTo(object value);
    public static decimal Divide(decimal d1, decimal d2);
    public bool Equals(decimal value);
    public static bool Equals(decimal d1, decimal d2);
    public override bool Equals(object value);
    public static decimal Floor(decimal d);
-   public static decimal FromOACurrency(long cy);
    public static int[] GetBits(decimal d);
-   [MethodImpl(InternalCall)]public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal operator +(decimal d1, decimal d2);
    public static decimal operator --(decimal d);
    public static decimal operator /(decimal d1, decimal d2);
    public static bool operator ==(decimal d1, decimal d2);
    public static explicit operator byte (decimal value);
    public static explicit operator sbyte (decimal value);
    public static explicit operator char (decimal value);
    public static explicit operator short (decimal value);
    public static explicit operator ushort (decimal value);
    public static explicit operator int (decimal value);
    public static explicit operator uint (decimal value);
    public static explicit operator long (decimal value);
    public static explicit operator ulong (decimal value);
    public static explicit operator float (decimal value);
    public static explicit operator double (decimal value);
    public static explicit operator decimal (double value);
    public static explicit operator decimal (float value);
    public static bool operator >(decimal d1, decimal d2);
    public static bool operator >=(decimal d1, decimal d2);
    public static implicit operator decimal (byte value);
    public static implicit operator decimal (char value);
    public static implicit operator decimal (short value);
    public static implicit operator decimal (int value);
    public static implicit operator decimal (long value);
    public static implicit operator decimal (sbyte value);
    public static implicit operator decimal (ushort value);
    public static implicit operator decimal (uint value);
    public static implicit operator decimal (ulong value);
    public static decimal operator ++(decimal d);
    public static bool operator !=(decimal d1, decimal d2);
    public static bool operator <(decimal d1, decimal d2);
    public static bool operator <=(decimal d1, decimal d2);
    public static decimal operator %(decimal d1, decimal d2);
    public static decimal operator *(decimal d1, decimal d2);
    public static decimal operator -(decimal d1, decimal d2);
    public static decimal operator -(decimal d);
    public static decimal operator +(decimal d);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Remainder(decimal d1, decimal d2);
-   public static decimal Round(decimal d);
-   public static decimal Round(decimal d, int decimals);
-   public static decimal Round(decimal d, int decimals, MidpointRounding mode);
-   public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Subtract(decimal d1, decimal d2);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public static byte ToByte(decimal value);
-   [MethodImpl(InternalCall)]public static double ToDouble(decimal d);
    public static short ToInt16(decimal value);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
-   public static long ToOACurrency(decimal value);
    public static sbyte ToSByte(decimal value);
-   [MethodImpl(InternalCall)]public static float ToSingle(decimal d);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static ushort ToUInt16(decimal value);
    public static uint ToUInt32(decimal d);
    public static ulong ToUInt64(decimal d);
    public static decimal Truncate(decimal d);
    public static bool TryParse(string s, out decimal result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out decimal result);
  }
  public abstract class Delegate : ICloneable, ISerializable {
-   protected Delegate(object target, string method);
-   protected Delegate(Type target, string method);
-   public MethodInfo Method { get; }
    public object Target { get; }
-   public virtual object Clone();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(params Delegate[] delegates);
-   protected virtual Delegate CombineImpl(Delegate d);
-   public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
-   [MethodImpl(NoInlining)]public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
-   public static Delegate CreateDelegate(Type type, object target, string method);
-   public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
-   public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
-   public static Delegate CreateDelegate(Type type, MethodInfo method);
-   [MethodImpl(NoInlining)]public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
-   public static Delegate CreateDelegate(Type type, Type target, string method);
-   public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
-   public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public object DynamicInvoke(params object[] args);
-   protected virtual object DynamicInvokeImpl(object[] args);
    public override bool Equals(object obj);
    public override int GetHashCode();
    public virtual Delegate[] GetInvocationList();
-   protected virtual MethodInfo GetMethodImpl();
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool operator ==(Delegate d1, Delegate d2);
    public static bool operator !=(Delegate d1, Delegate d2);
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
-   protected virtual Delegate RemoveImpl(Delegate d);
  }
  public class DivideByZeroException : ArithmeticException {
    public DivideByZeroException();
-   protected DivideByZeroException(SerializationInfo info, StreamingContext context);
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
  }
- public class DllNotFoundException : TypeLoadException {
-   public DllNotFoundException();
-   protected DllNotFoundException(SerializationInfo info, StreamingContext context);
-   public DllNotFoundException(string message);
-   public DllNotFoundException(string message, Exception inner);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable {
    public const double Epsilon = 4.94065645841247E-324;
    public const double MaxValue = 1.7976931348623157E+308;
    public const double MinValue = -1.7976931348623157E+308;
    public const double NaN = 0.0 / 0.0;
    public const double NegativeInfinity = -1.0 / 0.0;
    public const double PositiveInfinity = 1.0 / 0.0;
    public int CompareTo(double value);
-   public int CompareTo(object value);
    public bool Equals(double obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static bool IsInfinity(double d);
    public static bool IsNaN(double d);
    public static bool IsNegativeInfinity(double d);
    public static bool IsPositiveInfinity(double d);
    public static bool operator ==(double left, double right);
    public static bool operator >(double left, double right);
    public static bool operator >=(double left, double right);
    public static bool operator !=(double left, double right);
    public static bool operator <(double left, double right);
    public static bool operator <=(double left, double right);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, out double result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out double result);
  }
- public class DuplicateWaitObjectException : ArgumentException {
-   public DuplicateWaitObjectException();
-   protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
-   public DuplicateWaitObjectException(string parameterName);
-   public DuplicateWaitObjectException(string message, Exception innerException);
-   public DuplicateWaitObjectException(string parameterName, string message);
  }
- public class EntryPointNotFoundException : TypeLoadException {
-   public EntryPointNotFoundException();
-   protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
-   public EntryPointNotFoundException(string message);
-   public EntryPointNotFoundException(string message, Exception inner);
  }
  public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable {
    protected Enum();
    public int CompareTo(object target);
-   [MethodImpl(InternalCall)]public override bool Equals(object obj);
    public static string Format(Type enumType, object value, string format);
    public override int GetHashCode();
    public static string GetName(Type enumType, object value);
    public static string[] GetNames(Type enumType);
-   public TypeCode GetTypeCode();
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
+   string System.IConvertible.ToString(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+   string System.IFormattable.ToString(string format, IFormatProvider provider);
-   public static object ToObject(Type enumType, byte value);
-   public static object ToObject(Type enumType, short value);
-   public static object ToObject(Type enumType, int value);
-   public static object ToObject(Type enumType, long value);
    public static object ToObject(Type enumType, object value);
-   public static object ToObject(Type enumType, sbyte value);
-   public static object ToObject(Type enumType, ushort value);
-   public static object ToObject(Type enumType, uint value);
-   public static object ToObject(Type enumType, ulong value);
    public override string ToString();
-   public string ToString(IFormatProvider provider);
    public string ToString(string format);
-   public string ToString(string format, IFormatProvider provider);
    public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct;
    public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct;
  }
- public static class Environment {
-   public static string CommandLine { get; }
-   public static string CurrentDirectory { get; set; }
-   public static int CurrentManagedThreadId { get; }
-   public static int ExitCode { [MethodImpl(InternalCall)]get; [MethodImpl(InternalCall)]set; }
-   public static bool HasShutdownStarted { [MethodImpl(InternalCall)]get; }
-   public static bool Is64BitOperatingSystem { get; }
-   public static bool Is64BitProcess { get; }
-   public static string MachineName { get; }
-   public static string NewLine { get; }
-   public static OperatingSystem OSVersion { get; }
-   public static int ProcessorCount { get; }
-   public static string StackTrace { get; }
-   public static string SystemDirectory { get; }
-   public static int SystemPageSize { get; }
-   public static int TickCount { [MethodImpl(InternalCall)]get; }
-   public static string UserDomainName { get; }
-   public static bool UserInteractive { get; }
-   public static string UserName { get; }
-   public static Version Version { get; }
-   public static long WorkingSet { get; }
-   public static void Exit(int exitCode);
-   public static string ExpandEnvironmentVariables(string name);
-   [MethodImpl(InternalCall)]public static void FailFast(string message);
-   [MethodImpl(InternalCall)]public static void FailFast(string message, Exception exception);
-   public static string[] GetCommandLineArgs();
-   public static string GetEnvironmentVariable(string variable);
-   public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
-   public static IDictionary GetEnvironmentVariables();
-   public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
-   public static string GetFolderPath(Environment.SpecialFolder folder);
-   public static string GetFolderPath(Environment.SpecialFolder folder, Environment.SpecialFolderOption option);
-   public static string[] GetLogicalDrives();
-   public static void SetEnvironmentVariable(string variable, string value);
-   public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
-   public enum SpecialFolder {
-     AdminTools = 48,
-     ApplicationData = 26,
-     CDBurning = 59,
-     CommonAdminTools = 47,
-     CommonApplicationData = 35,
-     CommonDesktopDirectory = 25,
-     CommonDocuments = 46,
-     CommonMusic = 53,
-     CommonOemLinks = 58,
-     CommonPictures = 54,
-     CommonProgramFiles = 43,
-     CommonProgramFilesX86 = 44,
-     CommonPrograms = 23,
-     CommonStartMenu = 22,
-     CommonStartup = 24,
-     CommonTemplates = 45,
-     CommonVideos = 55,
-     Cookies = 33,
-     Desktop = 0,
-     DesktopDirectory = 16,
-     Favorites = 6,
-     Fonts = 20,
-     History = 34,
-     InternetCache = 32,
-     LocalApplicationData = 28,
-     LocalizedResources = 57,
-     MyComputer = 17,
-     MyDocuments = 5,
-     MyMusic = 13,
-     MyPictures = 39,
-     MyVideos = 14,
-     NetworkShortcuts = 19,
-     Personal = 5,
-     PrinterShortcuts = 27,
-     ProgramFiles = 38,
-     ProgramFilesX86 = 42,
-     Programs = 2,
-     Recent = 8,
-     Resources = 56,
-     SendTo = 9,
-     StartMenu = 11,
-     Startup = 7,
-     System = 37,
-     SystemX86 = 41,
-     Templates = 21,
-     UserProfile = 40,
-     Windows = 36,
    }
-   public enum SpecialFolderOption {
-     Create = 32768,
-     DoNotVerify = 16384,
-     None = 0,
    }
  }
- public enum EnvironmentVariableTarget {
-   Machine = 2,
-   Process = 0,
-   User = 1,
  }
  public class EventArgs {
    public static readonly EventArgs Empty;
    public EventArgs();
  }
  public delegate void EventHandler(object sender, EventArgs e);
  public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);
  public class Exception : _Exception, ISerializable {
    public Exception();
-   protected Exception(SerializationInfo info, StreamingContext context);
    public Exception(string message);
    public Exception(string message, Exception innerException);
    public virtual IDictionary Data { get; }
    public virtual string HelpLink { get; set; }
    public int HResult { get; protected set; }
    public Exception InnerException { get; }
    public virtual string Message { get; }
    public virtual string Source { get; set; }
    public virtual string StackTrace { get; }
-   public MethodBase TargetSite { get; }
-   protected event EventHandler<SafeSerializationEventArgs> SerializeObjectState;
    public virtual Exception GetBaseException();
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public new Type GetType();
    public override string ToString();
  }
- public sealed class ExecutionEngineException : SystemException {
-   public ExecutionEngineException();
-   public ExecutionEngineException(string message);
-   public ExecutionEngineException(string message, Exception innerException);
  }
  public class FieldAccessException : MemberAccessException {
    public FieldAccessException();
-   protected FieldAccessException(SerializationInfo info, StreamingContext context);
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
  }
  public class FlagsAttribute : Attribute {
    public FlagsAttribute();
  }
  public class FormatException : SystemExceptionException {
    public FormatException();
-   protected FormatException(SerializationInfo info, StreamingContext context);
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
  }
  public abstract class FormattableString : IFormattable {
    protected FormattableString();
    public abstract int ArgumentCount { get; }
    public abstract string Format { get; }
    public abstract object GetArgument(int index);
    public abstract object[] GetArguments();
    public static string Invariant(FormattableString formattable);
    string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public override string ToString();
    public abstract string ToString(IFormatProvider formatProvider);
  }
  public delegate TResult Func<out TResult>();
  public delegate TResult Func<in T, out TResult>(T arg);
  public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
  public delegate TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3);
  public delegate TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
  public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
  public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
  public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
  public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
+ public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
  public static class GC {
    public static int MaxGeneration { get; }
    public static void AddMemoryPressure(long bytesAllocated);
-   public static void CancelFullGCNotification();
    public static void Collect();
    public static void Collect(int generation);
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
-   public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
-   public static void EndNoGCRegion();
-   [MethodImpl(InternalCall)]public static int GetGeneration(object obj);
-   public static int GetGeneration(WeakReference wo);
    public static long GetTotalMemory(bool forceFullCollection);
-   [MethodImpl(NoInlining)]public static void KeepAlive(object obj);
-   public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static void ReRegisterForFinalize(object obj);
    public static void SuppressFinalize(object obj);
-   public static bool TryStartNoGCRegion(long totalSize);
-   public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
-   public static bool TryStartNoGCRegion(long totalSize, long lohSize);
-   public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
-   public static GCNotificationStatus WaitForFullGCApproach();
-   public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
-   public static GCNotificationStatus WaitForFullGCComplete();
-   public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    public static void WaitForPendingFinalizers();
  }
  public enum GCCollectionMode {
    Default = 0,
    Forced = 1,
    Optimized = 2,
  }
- public enum GCNotificationStatus {
-   Canceled = 2,
-   Failed = 1,
-   NotApplicable = 4,
-   Succeeded = 0,
-   Timeout = 3,
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable {
    public static readonly Guid Empty;
    public Guid(byte[] b);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, byte[] d);
    public Guid(string g);
    public Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public int CompareTo(Guid value);
-   public int CompareTo(object value);
    public bool Equals(Guid g);
    public override bool Equals(object o);
    public override int GetHashCode();
    public static Guid NewGuid();
    public static bool operator ==(Guid a, Guid b);
    public static bool operator !=(Guid a, Guid b);
    public static Guid Parse(string input);
    public static Guid ParseExact(string input, string format);
+   int System.IComparable.CompareTo(object value);
+   string System.IFormattable.ToString(string format, IFormatProvider provider);
    public byte[] ToByteArray();
    public override string ToString();
    public string ToString(string format);
-   public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string input, out Guid result);
    public static bool TryParseExact(string input, string format, out Guid result);
  }
- public interface IAppDomainSetup {
-   string ApplicationBase { get; set; }
-   string ApplicationName { get; set; }
-   string CachePath { get; set; }
-   string ConfigurationFile { get; set; }
-   string DynamicBase { get; set; }
-   string LicenseFile { get; set; }
-   string PrivateBinPath { get; set; }
-   string PrivateBinPathProbe { get; set; }
-   string ShadowCopyDirectories { get; set; }
-   string ShadowCopyFiles { get; set; }
  }
  public interface IAsyncResult {
    object AsyncState { get; }
    WaitHandle AsyncWaitHandle { get; }
    bool CompletedSynchronously { get; }
    bool IsCompleted { get; }
  }
- public interface ICloneable {
-   object Clone();
  }
  public interface IComparable {
    int CompareTo(object obj);
  }
  public interface IComparable<in T> {
    int CompareTo(T other);
  }
  public interface IConvertible {
    TypeCode GetTypeCode();
    bool ToBoolean(IFormatProvider provider);
    byte ToByte(IFormatProvider provider);
    char ToChar(IFormatProvider provider);
    DateTime ToDateTime(IFormatProvider provider);
    decimal ToDecimal(IFormatProvider provider);
    double ToDouble(IFormatProvider provider);
    short ToInt16(IFormatProvider provider);
    int ToInt32(IFormatProvider provider);
    long ToInt64(IFormatProvider provider);
    sbyte ToSByte(IFormatProvider provider);
    float ToSingle(IFormatProvider provider);
    string ToString(IFormatProvider provider);
    object ToType(Type conversionType, IFormatProvider provider);
    ushort ToUInt16(IFormatProvider provider);
    uint ToUInt32(IFormatProvider provider);
    ulong ToUInt64(IFormatProvider provider);
  }
  public interface ICustomFormatter {
    string Format(string format, object arg, IFormatProvider formatProvider);
  }
  public interface IDisposable {
    void Dispose();
  }
  public interface IEquatable<T> {
    bool Equals(T other);
  }
  public interface IFormatProvider {
    object GetFormat(Type formatType);
  }
  public interface IFormattable {
    string ToString(string format, IFormatProvider formatProvider);
  }
  public sealed class IndexOutOfRangeException : SystemExceptionException {
    public IndexOutOfRangeException();
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
  }
  public sealed class InsufficientExecutionStackException : SystemExceptionException {
    public InsufficientExecutionStackException();
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
  }
- public sealed class InsufficientMemoryException : OutOfMemoryException {
-   public InsufficientMemoryException();
-   public InsufficientMemoryException(string message);
-   public InsufficientMemoryException(string message, Exception innerException);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable {
    public const short MaxValue = (short)32767;
    public const short MinValue = (short)-32768;
    public int CompareTo(short value);
-   public int CompareTo(object value);
    public bool Equals(short obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out short result);
    public static bool TryParse(string s, out short result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable {
    public const int MaxValue = 2147483647;
    public const int MinValue = -2147483648;
    public int CompareTo(int value);
-   public int CompareTo(object value);
    public bool Equals(int obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out int result);
    public static bool TryParse(string s, out int result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable {
    public const long MaxValue = (long)9223372036854775807;
    public const long MinValue = (long)-9223372036854775808;
    public int CompareTo(long value);
-   public int CompareTo(object value);
    public bool Equals(long obj);
    public override bool Equals(object obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out long result);
    public static bool TryParse(string s, out long result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct IntPtr : ISerializable {
    public static readonly IntPtr Zero;
    public IntPtr(int value);
    public IntPtr(long value);
    public unsafe IntPtr(void* value);
    public static int Size { get; }
    public static IntPtr Add(IntPtr pointer, int offset);
    public override bool Equals(object obj);
    public override int GetHashCode();
    public static IntPtr operator +(IntPtr pointer, int offset);
    public static bool operator ==(IntPtr value1, IntPtr value2);
    public static explicit operator IntPtr (int value);
    public static explicit operator IntPtr (long value);
    public unsafe static explicit operator void* (IntPtr value);
    public static explicit operator int (IntPtr value);
    public static explicit operator long (IntPtr value);
    public unsafe static explicit operator IntPtr (void* value);
    public static bool operator !=(IntPtr value1, IntPtr value2);
    public static IntPtr operator -(IntPtr pointer, int offset);
    public static IntPtr Subtract(IntPtr pointer, int offset);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int ToInt32();
    public long ToInt64();
    public unsafe void* ToPointer();
    public override string ToString();
    public string ToString(string format);
  }
  public class InvalidCastException : SystemExceptionException {
    public InvalidCastException();
-   protected InvalidCastException(SerializationInfo info, StreamingContext context);
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
  }
  public class InvalidOperationException : SystemExceptionException {
    public InvalidOperationException();
-   protected InvalidOperationException(SerializationInfo info, StreamingContext context);
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
  }
  public sealed class InvalidProgramException : SystemExceptionException {
    public InvalidProgramException();
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
  }
  public class InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException();
-   protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
  }
  public interface IObservable<out T> {
    IDisposable Subscribe(IObserver<T> observer);
  }
  public interface IObserver<in T> {
    void OnCompleted();
    void OnError(Exception error);
    void OnNext(T value);
  }
  public interface IProgress<in T> {
    void Report(T value);
  }
- public interface IServiceProvider {
-   object GetService(Type serviceType);
  }
  public class Lazy<T> {
    public Lazy();
    public Lazy(bool isThreadSafe);
    public Lazy(Func<T> valueFactory);
    public Lazy(Func<T> valueFactory, bool isThreadSafe);
    public Lazy(Func<T> valueFactory, LazyThreadSafetyMode mode);
    public Lazy(LazyThreadSafetyMode mode);
    public bool IsValueCreated { get; }
    public T Value { get; }
    public override string ToString();
  }
+ public class Lazy<T, TMetadata> : Lazy<T> {
+   public Lazy(Func<T> valueFactory, TMetadata metadata);
+   public Lazy(Func<T> valueFactory, TMetadata metadata, bool isThreadSafe);
+   public Lazy(Func<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
+   public Lazy(TMetadata metadata);
+   public Lazy(TMetadata metadata, bool isThreadSafe);
+   public Lazy(TMetadata metadata, LazyThreadSafetyMode mode);
+   public TMetadata Metadata { get; }
  }
- public enum LoaderOptimization {
-   DisallowBindings = 4,
-   DomainMask = 3,
-   MultiDomain = 2,
-   MultiDomainHost = 3,
-   NotSpecified = 0,
-   SingleDomain = 1,
  }
- public sealed class LoaderOptimizationAttribute : Attribute {
-   public LoaderOptimizationAttribute(byte value);
-   public LoaderOptimizationAttribute(LoaderOptimization value);
-   public LoaderOptimization Value { get; }
  }
- public sealed class LocalDataStoreSlot {
-   ~LocalDataStoreSlot();
  }
- public abstract class MarshalByRefObject {
-   protected MarshalByRefObject();
-   public virtual ObjRef CreateObjRef(Type requestedType);
-   public object GetLifetimeService();
-   public virtual object InitializeLifetimeService();
-   protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
  }
- public static class Math {
-   public const double E = 2.7182818284590451;
-   public const double PI = 3.1415926535897931;
-   public static decimal Abs(decimal value);
-   [MethodImpl(InternalCall)]public static double Abs(double value);
-   public static short Abs(short value);
-   public static int Abs(int value);
-   public static long Abs(long value);
-   public static sbyte Abs(sbyte value);
-   [MethodImpl(InternalCall)]public static float Abs(float value);
-   [MethodImpl(InternalCall)]public static double Acos(double d);
-   [MethodImpl(InternalCall)]public static double Asin(double d);
-   [MethodImpl(InternalCall)]public static double Atan(double d);
-   [MethodImpl(InternalCall)]public static double Atan2(double y, double x);
-   public static long BigMul(int a, int b);
-   public static decimal Ceiling(decimal d);
-   [MethodImpl(InternalCall)]public static double Ceiling(double a);
-   [MethodImpl(InternalCall)]public static double Cos(double d);
-   [MethodImpl(InternalCall)]public static double Cosh(double value);
-   public static int DivRem(int a, int b, out int result);
-   public static long DivRem(long a, long b, out long result);
-   [MethodImpl(InternalCall)]public static double Exp(double d);
-   public static decimal Floor(decimal d);
-   [MethodImpl(InternalCall)]public static double Floor(double d);
-   public static double IEEERemainder(double x, double y);
-   [MethodImpl(InternalCall)]public static double Log(double d);
-   public static double Log(double a, double newBase);
-   [MethodImpl(InternalCall)]public static double Log10(double d);
-   public static byte Max(byte val1, byte val2);
-   public static decimal Max(decimal val1, decimal val2);
-   public static double Max(double val1, double val2);
-   public static short Max(short val1, short val2);
-   public static int Max(int val1, int val2);
-   public static long Max(long val1, long val2);
-   public static sbyte Max(sbyte val1, sbyte val2);
-   public static float Max(float val1, float val2);
-   public static ushort Max(ushort val1, ushort val2);
-   public static uint Max(uint val1, uint val2);
-   public static ulong Max(ulong val1, ulong val2);
-   public static byte Min(byte val1, byte val2);
-   public static decimal Min(decimal val1, decimal val2);
-   public static double Min(double val1, double val2);
-   public static short Min(short val1, short val2);
-   public static int Min(int val1, int val2);
-   public static long Min(long val1, long val2);
-   public static sbyte Min(sbyte val1, sbyte val2);
-   public static float Min(float val1, float val2);
-   public static ushort Min(ushort val1, ushort val2);
-   public static uint Min(uint val1, uint val2);
-   public static ulong Min(ulong val1, ulong val2);
-   [MethodImpl(InternalCall)]public static double Pow(double x, double y);
-   public static decimal Round(decimal d);
-   public static decimal Round(decimal d, int decimals);
-   public static decimal Round(decimal d, int decimals, MidpointRounding mode);
-   public static decimal Round(decimal d, MidpointRounding mode);
-   [MethodImpl(InternalCall)]public static double Round(double a);
-   public static double Round(double value, int digits);
-   public static double Round(double value, int digits, MidpointRounding mode);
-   public static double Round(double value, MidpointRounding mode);
-   public static int Sign(decimal value);
-   public static int Sign(double value);
-   public static int Sign(short value);
-   public static int Sign(int value);
-   public static int Sign(long value);
-   public static int Sign(sbyte value);
-   public static int Sign(float value);
-   [MethodImpl(InternalCall)]public static double Sin(double a);
-   [MethodImpl(InternalCall)]public static double Sinh(double value);
-   [MethodImpl(InternalCall)]public static double Sqrt(double d);
-   [MethodImpl(InternalCall)]public static double Tan(double a);
-   [MethodImpl(InternalCall)]public static double Tanh(double value);
-   public static decimal Truncate(decimal d);
-   public static double Truncate(double d);
  }
  public class MemberAccessException : SystemExceptionException {
    public MemberAccessException();
-   protected MemberAccessException(SerializationInfo info, StreamingContext context);
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
  }
  public class MethodAccessException : MemberAccessException {
    public MethodAccessException();
-   protected MethodAccessException(SerializationInfo info, StreamingContext context);
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
  }
- public enum MidpointRounding {
-   AwayFromZero = 1,
-   ToEven = 0,
  }
  public class MissingFieldException : MissingMemberException, ISerializable {
    public MissingFieldException();
-   protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
-   public MissingFieldException(string className, string fieldName);
    public override string Message { get; }
  }
  public class MissingMemberException : MemberAccessException, ISerializable {
-   protected byte[] Signature;
-   protected string ClassName;
-   protected string MemberName;
    public MissingMemberException();
-   protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
-   public MissingMemberException(string className, string memberName);
    public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class MissingMethodException : MissingMemberException, ISerializable {
    public MissingMethodException();
-   protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
-   public MissingMethodException(string className, string methodName);
    public override string Message { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ModuleHandle {
-   public static readonly ModuleHandle EmptyHandle;
-   public int MDStreamVersion { get; }
-   public bool Equals(ModuleHandle handle);
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
-   public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
-   public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
-   public static bool operator ==(ModuleHandle left, ModuleHandle right);
-   public static bool operator !=(ModuleHandle left, ModuleHandle right);
-   public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
-   public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
-   public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
-   public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
-   public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
-   public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
  }
  public sealed class MTAThreadAttribute : Attribute {
    public MTAThreadAttribute();
  }
  public abstract class MulticastDelegate : Delegate {
-   protected MulticastDelegate(object target, string method);
-   protected MulticastDelegate(Type target, string method);
-   protected sealed override Delegate CombineImpl(Delegate follow);
    public sealed override bool Equals(object obj);
    public sealed override int GetHashCode();
    public sealed override Delegate[] GetInvocationList();
-   protected override MethodInfo GetMethodImpl();
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2);
    public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2);
-   protected sealed override Delegate RemoveImpl(Delegate value);
  }
- public sealed class MulticastNotSupportedException : SystemException {
-   public MulticastNotSupportedException();
-   public MulticastNotSupportedException(string message);
-   public MulticastNotSupportedException(string message, Exception inner);
  }
- public sealed class NonSerializedAttribute : Attribute {
-   public NonSerializedAttribute();
  }
- public class NotFiniteNumberException : ArithmeticException {
-   public NotFiniteNumberException();
-   public NotFiniteNumberException(double offendingNumber);
-   protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
-   public NotFiniteNumberException(string message);
-   public NotFiniteNumberException(string message, double offendingNumber);
-   public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
-   public NotFiniteNumberException(string message, Exception innerException);
-   public double OffendingNumber { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class NotImplementedException : SystemExceptionException {
    public NotImplementedException();
-   protected NotImplementedException(SerializationInfo info, StreamingContext context);
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
  }
  public class NotSupportedException : SystemExceptionException {
    public NotSupportedException();
-   protected NotSupportedException(SerializationInfo info, StreamingContext context);
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
  }
  public static class Nullable {
    public static int Compare<T>(Nullable<T> n1, Nullable<T> n2) where T : struct;
    public static bool Equals<T>(Nullable<T> n1, Nullable<T> n2) where T : struct;
    public static Type GetUnderlyingType(Type nullableType);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Nullable<T> where T : struct {
    public Nullable(T value);
    public bool HasValue { get; }
    public T Value { get; }
    public override bool Equals(object other);
    public override int GetHashCode();
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    public static explicit operator T (Nullable<T> value);
    public static implicit operator Nullable<T> (T value);
    public override string ToString();
  }
  public class NullReferenceException : SystemExceptionException {
    public NullReferenceException();
-   protected NullReferenceException(SerializationInfo info, StreamingContext context);
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
  }
  public class Object {
    public Object();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    ~Object();
    public virtual int GetHashCode();
-   [MethodImpl(InternalCall)]public Type GetType();
-   [MethodImpl(InternalCall)]protected object MemberwiseClone();
    public static bool ReferenceEquals(object objA, object objB);
    public virtual string ToString();
  }
  public class ObjectDisposedException : InvalidOperationException {
-   protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string message, Exception innerException);
    public ObjectDisposedException(string objectName, string message);
    public override string Message { get; }
    public string ObjectName { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public sealed class ObsoleteAttribute : Attribute {
    public ObsoleteAttribute();
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public bool IsError { get; }
    public string Message { get; }
  }
- public sealed class OperatingSystem : ICloneable, ISerializable {
-   public OperatingSystem(PlatformID platform, Version version);
-   public PlatformID Platform { get; }
-   public string ServicePack { get; }
-   public Version Version { get; }
-   public string VersionString { get; }
-   public object Clone();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
  }
- public class OperationCanceledException : SystemException {
-   public OperationCanceledException();
-   protected OperationCanceledException(SerializationInfo info, StreamingContext context);
-   public OperationCanceledException(string message);
-   public OperationCanceledException(string message, Exception innerException);
-   public OperationCanceledException(string message, Exception innerException, CancellationToken token);
-   public OperationCanceledException(string message, CancellationToken token);
-   public OperationCanceledException(CancellationToken token);
-   public CancellationToken CancellationToken { get; }
  }
  public class OutOfMemoryException : SystemExceptionException {
    public OutOfMemoryException();
-   protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
  }
  public class OverflowException : ArithmeticException {
    public OverflowException();
-   protected OverflowException(SerializationInfo info, StreamingContext context);
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
  }
  public sealed class ParamArrayAttribute : Attribute {
    public ParamArrayAttribute();
  }
- public enum PlatformID {
-   MacOSX = 6,
-   Unix = 4,
-   Win32NT = 2,
-   Win32S = 0,
-   Win32Windows = 1,
-   WinCE = 3,
-   Xbox = 5,
  }
  public class PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException();
-   protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
  }
  public delegate bool Predicate<in T>(T obj);
- public class Progress<T> : IProgress<T> {
-   public Progress();
-   public Progress(Action<T> handler);
-   public event EventHandler<T> ProgressChanged;
-   protected virtual void OnReport(T value);
-   void System.IProgress<T>.Report(T value);
  }
- public class Random {
-   public Random();
-   public Random(int Seed);
-   public virtual int Next();
-   public virtual int Next(int maxValue);
-   public virtual int Next(int minValue, int maxValue);
-   public virtual void NextBytes(byte[] buffer);
-   public virtual double NextDouble();
-   protected virtual double Sample();
  }
  public class RankException : SystemExceptionException {
    public RankException();
-   protected RankException(SerializationInfo info, StreamingContext context);
    public RankException(string message);
    public RankException(string message, Exception innerException);
  }
- public class ResolveEventArgs : EventArgs {
-   public ResolveEventArgs(string name);
-   public ResolveEventArgs(string name, Assembly requestingAssembly);
-   public string Name { get; }
-   public Assembly RequestingAssembly { get; }
  }
- public delegate Assembly ResolveEventHandler(object sender, ResolveEventArgs args);
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct RuntimeArgumentHandle {
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct RuntimeFieldHandle : ISerializable {
-   public IntPtr Value { get; }
    public override bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public override int GetHashCode();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool operator ==(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool operator !=(RuntimeFieldHandle left, RuntimeFieldHandle right);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct RuntimeMethodHandle : ISerializable {
-   public IntPtr Value { get; }
    public override bool Equals(object obj);
    public bool Equals(RuntimeMethodHandle handle);
-   public IntPtr GetFunctionPointer();
    public override int GetHashCode();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool operator ==(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool operator !=(RuntimeMethodHandle left, RuntimeMethodHandle right);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct RuntimeTypeHandle : ISerializable {
-   public IntPtr Value { get; }
    public override bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public override int GetHashCode();
-   public ModuleHandle GetModuleHandle();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool operator ==(object left, RuntimeTypeHandle right);
    public static bool operator ==(RuntimeTypeHandle left, object right);
    public static bool operator !=(object left, RuntimeTypeHandle right);
    public static bool operator !=(RuntimeTypeHandle left, object right);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable {
    public const sbyte MaxValue = (sbyte)127;
    public const sbyte MinValue = (sbyte)-128;
-   public int CompareTo(object obj);
    public int CompareTo(sbyte value);
    public override bool Equals(object obj);
    public bool Equals(sbyte obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static sbyte Parse(string s);
    public static sbyte Parse(string s, NumberStyles style);
    public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static sbyte Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object obj);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out sbyte result);
    public static bool TryParse(string s, out sbyte result);
  }
- public sealed class SerializableAttribute : Attribute {
-   public SerializableAttribute();
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable {
    public const float Epsilon = 1.401298E-45f;
    public const float MaxValue = 3.40282347E+38f;
    public const float MinValue = -3.40282347E+38f;
    public const float NaN = 0.0f / 0.0f;
    public const float NegativeInfinity = -1.0f / 0.0f;
    public const float PositiveInfinity = 1.0f / 0.0f;
-   public int CompareTo(object value);
    public int CompareTo(float value);
    public override bool Equals(object obj);
    public bool Equals(float obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static bool IsInfinity(float f);
    public static bool IsNaN(float f);
    public static bool IsNegativeInfinity(float f);
    public static bool IsPositiveInfinity(float f);
    public static bool operator ==(float left, float right);
    public static bool operator >(float left, float right);
    public static bool operator >=(float left, float right);
    public static bool operator !=(float left, float right);
    public static bool operator <(float left, float right);
    public static bool operator <=(float left, float right);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out float result);
    public static bool TryParse(string s, out float result);
  }
- public sealed class StackOverflowException : SystemException {
-   public StackOverflowException();
-   public StackOverflowException(string message);
-   public StackOverflowException(string message, Exception innerException);
  }
  public sealed class STAThreadAttribute : Attribute {
    public STAThreadAttribute();
  }
  public sealed class String : ICloneable, IComparable, IComparable<string>, IConvertible, IEnumerable, IEnumerable<char>, IEquatable<string> {
    public static readonly string Empty;
-   [MethodImpl(InternalCall)]public unsafe String(char* value);
-   [MethodImpl(InternalCall)]public unsafe String(char* value, int startIndex, int length);
-   [MethodImpl(InternalCall)]public String(char c, int count);
-   [MethodImpl(InternalCall)]public String(char[] value);
-   [MethodImpl(InternalCall)]public String(char[] value, int startIndex, int length);
-   [MethodImpl(InternalCall)]public unsafe String(sbyte* value);
-   [MethodImpl(InternalCall)]public unsafe String(sbyte* value, int startIndex, int length);
-   [MethodImpl(InternalCall)]public unsafe String(sbyte* value, int startIndex, int length, Encoding enc);
    public int Length { [MethodImpl(InternalCall)]get; }
    [System.Runtime.CompilerServices.IndexerName("Chars")]
    public char this[int index] { [MethodImpl(InternalCall)]get; }
-   public object Clone();
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
-   public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
-   public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
-   public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
-   public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
-   public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public static int CompareOrdinal(string strA, string strB);
-   public int CompareTo(object value);
    public int CompareTo(string strB);
    public static string Concat(IEnumerable<string> values);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
-   public static string Concat(object arg0, object arg1, object arg2, object arg3, __arglist);
    public static string Concat(params object[] args);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(params string[] values);
    public static string Concat<T>(IEnumerable<T> values);
    public bool Contains(string value);
-   public static string Copy(string str);
    public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
    public bool EndsWith(string value);
-   public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(string value, StringComparison comparisonType);
    public override bool Equals(object obj);
    public bool Equals(string value);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public bool Equals(string value, StringComparison comparisonType);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, params object[] args);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, params object[] args);
-   public CharEnumerator GetEnumerator();
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
-   [MethodImpl(InternalCall)]public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(char[] anyOf);
    public int IndexOfAny(char[] anyOf, int startIndex);
-   [MethodImpl(InternalCall)]public int IndexOfAny(char[] anyOf, int startIndex, int count);
    public string Insert(int startIndex, string value);
-   public static string Intern(string str);
-   public static string IsInterned(string str);
-   public bool IsNormalized();
-   public bool IsNormalized(NormalizationForm normalizationForm);
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    public static string Join(string separator, IEnumerable<string> values);
    public static string Join(string separator, params object[] values);
    public static string Join(string separator, params string[] value);
    public static string Join(string separator, string[] value, int startIndex, int count);
    public static string Join<T>(string separator, IEnumerable<T> values);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
-   [MethodImpl(InternalCall)]public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOfAny(char[] anyOf);
    public int LastIndexOfAny(char[] anyOf, int startIndex);
-   [MethodImpl(InternalCall)]public int LastIndexOfAny(char[] anyOf, int startIndex, int count);
-   public string Normalize();
-   public string Normalize(NormalizationForm normalizationForm);
    public static bool operator ==(string a, string b);
    public static bool operator !=(string a, string b);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public string[] Split(params char[] separator);
    public string[] Split(char[] separator, int count);
    public string[] Split(char[] separator, int count, StringSplitOptions options);
    public string[] Split(char[] separator, StringSplitOptions options);
    public string[] Split(string[] separator, int count, StringSplitOptions options);
    public string[] Split(string[] separator, StringSplitOptions options);
    public bool StartsWith(string value);
-   public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(string value, StringComparison comparisonType);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    IEnumerator<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    IEnumerator System.Collections.IEnumerable.GetEnumerator();
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
+   string System.IConvertible.ToString(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public char[] ToCharArray();
    public char[] ToCharArray(int startIndex, int length);
    public string ToLower();
-   public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public override string ToString();
-   public string ToString(IFormatProvider provider);
    public string ToUpper();
-   public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(params char[] trimChars);
    public string TrimEnd(params char[] trimChars);
    public string TrimStart(params char[] trimChars);
  }
- public abstract class StringComparer : IComparer, IComparer<string>, IEqualityComparer, IEqualityComparer<string> {
-   protected StringComparer();
-   public static StringComparer CurrentCulture { get; }
-   public static StringComparer CurrentCultureIgnoreCase { get; }
-   public static StringComparer InvariantCulture { get; }
-   public static StringComparer InvariantCultureIgnoreCase { get; }
-   public static StringComparer Ordinal { get; }
-   public static StringComparer OrdinalIgnoreCase { get; }
-   public int Compare(object x, object y);
-   public abstract int Compare(string x, string y);
-   public static StringComparer Create(CultureInfo culture, bool ignoreCase);
-   public new bool Equals(object x, object y);
-   public abstract bool Equals(string x, string y);
-   public int GetHashCode(object obj);
-   public abstract int GetHashCode(string obj);
  }
  public enum StringComparison {
    CurrentCulture = 0,
    CurrentCultureIgnoreCase = 1,
-   InvariantCulture = 2,
-   InvariantCultureIgnoreCase = 3,
    Ordinal = 4,
    OrdinalIgnoreCase = 5,
  }
  public enum StringSplitOptions {
    None = 0,
    RemoveEmptyEntries = 1,
  }
- public class SystemException : Exception {
-   public SystemException();
-   protected SystemException(SerializationInfo info, StreamingContext context);
-   public SystemException(string message);
-   public SystemException(string message, Exception innerException);
  }
  public class ThreadStaticAttribute : Attribute {
    public ThreadStaticAttribute();
  }
  public class TimeoutException : SystemExceptionException {
    public TimeoutException();
-   protected TimeoutException(SerializationInfo info, StreamingContext context);
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable {
    public const long TicksPerDay = (long)864000000000;
    public const long TicksPerHour = (long)36000000000;
    public const long TicksPerMillisecond = (long)10000;
    public const long TicksPerMinute = (long)600000000;
    public const long TicksPerSecond = (long)10000000;
    public static readonly TimeSpan MaxValue;
    public static readonly TimeSpan MinValue;
    public static readonly TimeSpan Zero;
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(long ticks);
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public long Ticks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
-   public int CompareTo(object value);
    public int CompareTo(TimeSpan value);
    public TimeSpan Duration();
    public override bool Equals(object value);
    public bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public static TimeSpan FromDays(double value);
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public static TimeSpan FromSeconds(double value);
    public static TimeSpan FromTicks(long value);
    public override int GetHashCode();
    public TimeSpan Negate();
    public static TimeSpan operator +(TimeSpan t1, TimeSpan t2);
    public static bool operator ==(TimeSpan t1, TimeSpan t2);
    public static bool operator >(TimeSpan t1, TimeSpan t2);
    public static bool operator >=(TimeSpan t1, TimeSpan t2);
    public static bool operator !=(TimeSpan t1, TimeSpan t2);
    public static bool operator <(TimeSpan t1, TimeSpan t2);
    public static bool operator <=(TimeSpan t1, TimeSpan t2);
    public static TimeSpan operator -(TimeSpan t1, TimeSpan t2);
    public static TimeSpan operator -(TimeSpan t);
    public static TimeSpan operator +(TimeSpan t);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public TimeSpan Subtract(TimeSpan ts);
+   int System.IComparable.CompareTo(object value);
    public override string ToString();
    public string ToString(string format);
    public string ToString(string format, IFormatProvider formatProvider);
    public static bool TryParse(string input, IFormatProvider formatProvider, out TimeSpan result);
    public static bool TryParse(string s, out TimeSpan result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, out TimeSpan result);
    public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
    public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, out TimeSpan result);
  }
- public abstract class TimeZone {
-   protected TimeZone();
-   public static TimeZone CurrentTimeZone { get; }
-   public abstract string DaylightName { get; }
-   public abstract string StandardName { get; }
-   public abstract DaylightTime GetDaylightChanges(int year);
-   public abstract TimeSpan GetUtcOffset(DateTime time);
-   public virtual bool IsDaylightSavingTime(DateTime time);
-   public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
-   public virtual DateTime ToLocalTime(DateTime time);
-   public virtual DateTime ToUniversalTime(DateTime time);
  }
  public sealed class TimeZoneInfo : IDeserializationCallback, IEquatable<TimeZoneInfo>, ISerializable {
    public TimeSpan BaseUtcOffset { get; }
    public string DaylightName { get; }
    public string DisplayName { get; }
    public string Id { get; }
    public static TimeZoneInfo Local { get; }
    public string StandardName { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Utc { get; }
-   public static void ClearCachedData();
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
-   public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
-   public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
-   public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
-   public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
-   public static DateTime ConvertTimeToUtc(DateTime dateTime);
-   public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
-   public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
-   public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules);
-   public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
-   public override bool Equals(object obj);
    public bool Equals(TimeZoneInfo other);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
-   public static TimeZoneInfo FromSerializedString(string source);
-   public TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public override int GetHashCode();
    public static ReadOnlyCollection<TimeZoneInfo> GetSystemTimeZones();
    public TimeSpan GetUtcOffset(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
-   public bool HasSameRules(TimeZoneInfo other);
    public bool IsAmbiguousTime(DateTime dateTime);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsInvalidTime(DateTime dateTime);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public string ToSerializedString();
    public override string ToString();
-   public sealed class AdjustmentRule : IDeserializationCallback, IEquatable<TimeZoneInfo.AdjustmentRule>, ISerializable {
-     public DateTime DateEnd { get; }
-     public DateTime DateStart { get; }
-     public TimeSpan DaylightDelta { get; }
-     public TimeZoneInfo.TransitionTime DaylightTransitionEnd { get; }
-     public TimeZoneInfo.TransitionTime DaylightTransitionStart { get; }
-     public static TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TimeZoneInfo.TransitionTime daylightTransitionStart, TimeZoneInfo.TransitionTime daylightTransitionEnd);
-     public bool Equals(TimeZoneInfo.AdjustmentRule other);
-     public override int GetHashCode();
-     void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-     void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    }
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct TransitionTime : IDeserializationCallback, IEquatable<TimeZoneInfo.TransitionTime>, ISerializable {
-     public int Day { get; }
-     public DayOfWeek DayOfWeek { get; }
-     public bool IsFixedDateRule { get; }
-     public int Month { get; }
-     public DateTime TimeOfDay { get; }
-     public int Week { get; }
-     public static TimeZoneInfo.TransitionTime CreateFixedDateRule(DateTime timeOfDay, int month, int day);
-     public static TimeZoneInfo.TransitionTime CreateFloatingDateRule(DateTime timeOfDay, int month, int week, DayOfWeek dayOfWeek);
-     public override bool Equals(object obj);
-     public bool Equals(TimeZoneInfo.TransitionTime other);
-     public override int GetHashCode();
-     public static bool operator ==(TimeZoneInfo.TransitionTime t1, TimeZoneInfo.TransitionTime t2);
-     public static bool operator !=(TimeZoneInfo.TransitionTime t1, TimeZoneInfo.TransitionTime t2);
-     void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-     void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    }
  }
- public class TimeZoneNotFoundException : Exception {
-   public TimeZoneNotFoundException();
-   protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
-   public TimeZoneNotFoundException(string message);
-   public TimeZoneNotFoundException(string message, Exception innerException);
  }
  public static class Tuple {
    public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    public static Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
    public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
    public static Tuple<T1> Create<T1>(T1 item1);
  }
  public class Tuple<T1> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1);
    public T1 Item1 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3, T4> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3, T4, T5> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3, T4, T5, T6> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3, T4, T5, T6, T7> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : IComparable, IStructuralComparable, IStructuralEquatable {
    public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    int System.IComparable.CompareTo(object obj);
    public override string ToString();
  }
  public abstract class Type : MemberInfo, _Type, IReflect {
    public static readonly char Delimiter;
    ^ Pallavi Taneja: Added on the Type.
    public static readonly object Missing;
    ^ Pallavi Taneja: Already present.
-   public static readonly MemberFilter FilterAttribute;
    ^ Pallavi Taneja: Filter* can't be added to TypeInfo in this contract revision.
-   public static readonly MemberFilter FilterName;
-   public static readonly MemberFilter FilterNameIgnoreCase;
    public static readonly Type[] EmptyTypes;
    ^ Pallavi Taneja: Already present.
-   protected Type();
-   public abstract Assembly Assembly { get; }
    public abstract string AssemblyQualifiedName { get; }
-   public TypeAttributes Attributes { get; }
-   public abstract Type BaseType { get; }
-   public virtual bool ContainsGenericParameters { get; }
-   public virtual MethodBase DeclaringMethod { get; }
    public overrideabstract Type DeclaringType { get; }
-   public static Binder DefaultBinder { get; }
    ^ Pallavi Taneja: [Pending discussion] Whether Binder should be empty or exposed via a separate contract.
    public abstract string FullName { get; }
-   public virtual GenericParameterAttributes GenericParameterAttributes { get; }
    public virtualabstract int GenericParameterPosition { get; }
    public virtualabstract Type[] GenericTypeArguments { get; }
-   public abstract Guid GUID { get; }
    public bool HasElementType { get; }
-   public bool IsAbstract { get; }
-   public bool IsAnsiClass { get; }
    public virtual bool IsArray { get; }
-   public bool IsAutoClass { get; }
-   public bool IsAutoLayout { get; }
    public virtual bool IsByRef { get; }
-   public bool IsClass { get; }
-   public bool IsCOMObject { get; }
    public virtualabstract bool IsConstructedGenericType { get; }
    ^ Pallavi Taneja: Already exposed in Type.
-   public bool IsContextful { get; }
    ^ Pallavi Taneja: Used only in remoting.
-   public virtual bool IsEnum { get; }
-   public bool IsExplicitLayout { get; }
    public virtualabstract bool IsGenericParameter { get; }
-   public virtual bool IsGenericType { get; }
-   public virtual bool IsGenericTypeDefinition { get; }
-   public bool IsImport { get; }
-   public bool IsInterface { get; }
-   public bool IsLayoutSequential { get; }
-   public bool IsMarshalByRef { get; }
    public bool IsNested { get; }
-   public bool IsNestedAssembly { get; }
-   public bool IsNestedFamANDAssem { get; }
-   public bool IsNestedFamily { get; }
-   public bool IsNestedFamORAssem { get; }
-   public bool IsNestedPrivate { get; }
-   public bool IsNestedPublic { get; }
-   public bool IsNotPublic { get; }
    public virtual bool IsPointer { get; }
-   public bool IsPrimitive { get; }
-   public bool IsPublic { get; }
-   public bool IsSealed { get; }
-   public virtual bool IsSecurityCritical { get; }
    ^ Pallavi Taneja: Obsolete concept.
-   public virtual bool IsSecuritySafeCritical { get; }
-   public virtual bool IsSecurityTransparent { get; }
-   public virtual bool IsSerializable { get; }
-   public bool IsSpecialName { get; }
-   public bool IsUnicodeClass { get; }
-   public bool IsValueType { get; }
-   public bool IsVisible { get; }
-   public override MemberTypes MemberType { get; }
-   public abstract new Module Module { get; }
+   public abstract string Name { get; }
    public abstract string Namespace { get; }
-   public override Type ReflectedType { get; }
-   public virtual StructLayoutAttribute StructLayoutAttribute { get; }
    public virtual RuntimeTypeHandle TypeHandle { get; }
    ^ Pallavi Taneja: Already exposed in Type
-   public ConstructorInfo TypeInitializer { get; }
-   public abstract Type UnderlyingSystemType { get; }
    public override bool Equals(object o);
    public virtual bool Equals(Type o);
-   public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
-   public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtualabstract int GetArrayRank();
-   protected abstract TypeAttributes GetAttributeFlagsImpl();
-   public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    ^ Pallavi Taneja: Binder decision pending.
-   public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
-   public ConstructorInfo GetConstructor(Type[] types);
-   protected abstract ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public ConstructorInfo[] GetConstructors();
-   public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   public virtual MemberInfo[] GetDefaultMembers();
    public abstract Type GetElementType();
-   public virtual string GetEnumName(object value);
-   public virtual string[] GetEnumNames();
-   public virtual Type GetEnumUnderlyingType();
-   public virtual Array GetEnumValues();
-   public EventInfo GetEvent(string name);
-   public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   public virtual EventInfo[] GetEvents();
-   public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);
-   public FieldInfo GetField(string name);
-   public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public FieldInfo[] GetFields();
-   public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);
-   public virtual Type[] GetGenericArguments();
-   public virtual Type[] GetGenericParameterConstraints();
    public virtualabstract Type GetGenericTypeDefinition();
    public override int GetHashCode();
-   public Type GetInterface(string name);
-   public abstract Type GetInterface(string name, bool ignoreCase);
-   public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
-   public abstract Type[] GetInterfaces();
-   public MemberInfo[] GetMember(string name);
-   public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
-   public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   public MemberInfo[] GetMembers();
-   public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   public MethodInfo GetMethod(string name);
-   public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
-   public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    ^ Pallavi Taneja: Binder decision pending.
-   public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
-   public MethodInfo GetMethod(string name, Type[] types);
-   public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
-   protected abstract MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public MethodInfo[] GetMethods();
-   public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   public Type GetNestedType(string name);
-   public abstract Type GetNestedType(string name, BindingFlags bindingAttr);
-   public Type[] GetNestedTypes();
-   public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);
-   public PropertyInfo[] GetProperties();
-   public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   public PropertyInfo GetProperty(string name);
-   public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
-   public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    ^ Pallavi Taneja: Binder decision pending.
-   public PropertyInfo GetProperty(string name, Type returnType);
-   public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
-   public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   public PropertyInfo GetProperty(string name, Type[] types);
-   protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   public new Type GetType();
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName);
    ^ Pallavi Taneja: GetType* can't be added to TypeInfo in the current contract version.
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName, bool throwOnError);
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver);
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver, bool throwOnError);
-   [MethodImpl(NoInlining)]public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
-   public static Type[] GetTypeArray(object[] args);
    ^ Pallavi Taneja: Can't be added to TypeInfo in the current contract version.
    public static TypeCode GetTypeCode(Type type);
-   protected virtual TypeCode GetTypeCodeImpl();
-   public static Type GetTypeFromCLSID(Guid clsid);
    ^ Pallavi Taneja: Interop concept
-   public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
-   public static Type GetTypeFromCLSID(Guid clsid, string server);
-   public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
-   [MethodImpl(InternalCall)]public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    ^ Pallavi Taneja: Already implemented.
-   public static Type GetTypeFromProgID(string progID);
    ^ Pallavi Taneja: Interop concept
-   public static Type GetTypeFromProgID(string progID, bool throwOnError);
-   public static Type GetTypeFromProgID(string progID, string server);
-   public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
-   public static RuntimeTypeHandle GetTypeHandle(object o);
    ^ Pallavi Taneja: Decision pending.
-   protected abstract bool HasElementTypeImpl();
-   public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);
    ^ Pallavi Taneja: Binder decision pending.
-   public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture);
-   public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   protected abstract bool IsArrayImpl();
-   public virtual bool IsAssignableFrom(Type c);
-   protected abstract bool IsByRefImpl();
-   protected abstract bool IsCOMObjectImpl();
-   protected virtual bool IsContextfulImpl();
-   public virtual bool IsEnumDefined(object value);
-   public virtual bool IsEquivalentTo(Type other);
-   public virtual bool IsInstanceOfType(object o);
-   protected virtual bool IsMarshalByRefImpl();
-   protected abstract bool IsPointerImpl();
-   protected abstract bool IsPrimitiveImpl();
-   public virtual bool IsSubclassOf(Type c);
-   protected virtual bool IsValueTypeImpl();
    public virtualabstract Type MakeArrayType();
    public virtualabstract Type MakeArrayType(int rank);
    public virtualabstract Type MakeByRefType();
    public virtualabstract Type MakeGenericType(params Type[] typeArguments);
    public virtualabstract Type MakePointerType();
-   [MethodImpl(InternalCall)]public static bool operator ==(Type left, Type right);
-   [MethodImpl(InternalCall)]public static bool operator !=(Type left, Type right);
-   [MethodImpl(NoInlining)]public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
-   void System.Runtime.InteropServices._Type.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._Type.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._Type.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._Type.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public override string ToString();
  }
  public class TypeAccessException : TypeLoadException {
    public TypeAccessException();
-   protected TypeAccessException(SerializationInfo info, StreamingContext context);
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
  }
  public enum TypeCode {
    Boolean = 3,
    Byte = 6,
    Char = 4,
    DateTime = 16,
-   DBNull = 2,
    Decimal = 15,
    Double = 14,
    Empty = 0,
    Int16 = 7,
    Int32 = 9,
    Int64 = 11,
    Object = 1,
    SByte = 5,
    Single = 13,
    String = 18,
    UInt16 = 8,
    UInt32 = 10,
    UInt64 = 12,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TypedReference {
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public static Type GetTargetType(TypedReference value);
-   public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
-   public static void SetTypedReference(TypedReference target, object value);
-   public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
-   public static object ToObject(TypedReference value);
  }
  public sealed class TypeInitializationException : SystemExceptionException {
    public TypeInitializationException(string fullTypeName, Exception innerException);
    public string TypeName { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class TypeLoadException : SystemExceptionException, ISerializable {
    public TypeLoadException();
-   protected TypeLoadException(SerializationInfo info, StreamingContext context);
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    public override string Message { get; }
    public string TypeName { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public class TypeUnloadedException : SystemException {
-   public TypeUnloadedException();
-   protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
-   public TypeUnloadedException(string message);
-   public TypeUnloadedException(string message, Exception innerException);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable {
    public const ushort MaxValue = (ushort)65535;
    public const ushort MinValue = (ushort)0;
-   public int CompareTo(object value);
    public int CompareTo(ushort value);
    public override bool Equals(object obj);
    public bool Equals(ushort obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static ushort Parse(string s);
    public static ushort Parse(string s, NumberStyles style);
    public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    public static ushort Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ushort result);
    public static bool TryParse(string s, out ushort result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable {
    public const uint MaxValue = (uint)4294967295;
    public const uint MinValue = (uint)0;
-   public int CompareTo(object value);
    public int CompareTo(uint value);
    public override bool Equals(object obj);
    public bool Equals(uint obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static uint Parse(string s);
    public static uint Parse(string s, NumberStyles style);
    public static uint Parse(string s, NumberStyles style, IFormatProvider provider);
    public static uint Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out uint result);
    public static bool TryParse(string s, out uint result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable {
    public const ulong MaxValue = (ulong)18446744073709551615;
    public const ulong MinValue = (ulong)0;
-   public int CompareTo(object value);
    public int CompareTo(ulong value);
    public override bool Equals(object obj);
    public bool Equals(ulong obj);
    public override int GetHashCode();
-   public TypeCode GetTypeCode();
    public static ulong Parse(string s);
    public static ulong Parse(string s, NumberStyles style);
    public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    public static ulong Parse(string s, IFormatProvider provider);
+   int System.IComparable.CompareTo(object value);
+   TypeCode System.IConvertible.GetTypeCode();
    bool System.IConvertible.ToBoolean(IFormatProvider provider);
    byte System.IConvertible.ToByte(IFormatProvider provider);
    char System.IConvertible.ToChar(IFormatProvider provider);
    DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    double System.IConvertible.ToDouble(IFormatProvider provider);
    short System.IConvertible.ToInt16(IFormatProvider provider);
    int System.IConvertible.ToInt32(IFormatProvider provider);
    long System.IConvertible.ToInt64(IFormatProvider provider);
    sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    float System.IConvertible.ToSingle(IFormatProvider provider);
    object System.IConvertible.ToType(Type type, IFormatProvider provider);
    ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    uint System.IConvertible.ToUInt32(IFormatProvider provider);
    ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public override string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ulong result);
    public static bool TryParse(string s, out ulong result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct UIntPtr : ISerializable {
    public static readonly UIntPtr Zero;
    public UIntPtr(uint value);
    public UIntPtr(ulong value);
    public unsafe UIntPtr(void* value);
    public static int Size { get; }
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public override bool Equals(object obj);
    public override int GetHashCode();
    public static UIntPtr operator +(UIntPtr pointer, int offset);
    public static bool operator ==(UIntPtr value1, UIntPtr value2);
    public static explicit operator UIntPtr (uint value);
    public static explicit operator UIntPtr (ulong value);
    public static explicit operator uint (UIntPtr value);
    public static explicit operator ulong (UIntPtr value);
    public unsafe static explicit operator void* (UIntPtr value);
    public unsafe static explicit operator UIntPtr (void* value);
    public static bool operator !=(UIntPtr value1, UIntPtr value2);
    public static UIntPtr operator -(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public unsafe void* ToPointer();
    public override string ToString();
    public uint ToUInt32();
    public ulong ToUInt64();
  }
  public class UnauthorizedAccessException : SystemExceptionException {
    public UnauthorizedAccessException();
-   protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
  }
- public class UnhandledExceptionEventArgs : EventArgs {
-   public UnhandledExceptionEventArgs(object exception, bool isTerminating);
-   public object ExceptionObject { get; }
-   public bool IsTerminating { get; }
  }
- public delegate void UnhandledExceptionEventHandler(object sender, UnhandledExceptionEventArgs e);
+ public class Uri {
+   public Uri(string uriString);
+   public Uri(string uriString, UriKind uriKind);
+   public Uri(Uri baseUri, string relativeUri);
+   public Uri(Uri baseUri, Uri relativeUri);
+   public string AbsolutePath { get; }
+   public string AbsoluteUri { get; }
+   public string Authority { get; }
+   public string DnsSafeHost { get; }
+   public string Fragment { get; }
+   public string Host { get; }
+   public UriHostNameType HostNameType { get; }
+   public string IdnHost { get; }
+   public bool IsAbsoluteUri { get; }
+   public bool IsDefaultPort { get; }
+   public bool IsFile { get; }
+   public bool IsLoopback { get; }
+   public bool IsUnc { get; }
+   public string LocalPath { get; }
+   public string OriginalString { get; }
+   public string PathAndQuery { get; }
+   public int Port { get; }
+   public string Query { get; }
+   public string Scheme { get; }
+   public string[] Segments { get; }
+   public bool UserEscaped { get; }
+   public string UserInfo { get; }
+   public static UriHostNameType CheckHostName(string name);
+   public static bool CheckSchemeName(string schemeName);
+   public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
+   public override bool Equals(object comparand);
+   public static string EscapeDataString(string stringToEscape);
+   public static string EscapeUriString(string stringToEscape);
+   public string GetComponents(UriComponents components, UriFormat format);
+   public override int GetHashCode();
+   public bool IsBaseOf(Uri uri);
+   public bool IsWellFormedOriginalString();
+   public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
+   public Uri MakeRelativeUri(Uri uri);
+   public static bool operator ==(Uri uri1, Uri uri2);
+   public static bool operator !=(Uri uri1, Uri uri2);
+   public override string ToString();
+   public static bool TryCreate(string uriString, UriKind uriKind, out Uri result);
+   public static bool TryCreate(Uri baseUri, string relativeUri, out Uri result);
+   public static bool TryCreate(Uri baseUri, Uri relativeUri, out Uri result);
+   public static string UnescapeDataString(string stringToUnescape);
  }
+ public enum UriComponents {
+   AbsoluteUri = 127,
+   Fragment = 64,
+   Host = 4,
+   HostAndPort = 132,
+   HttpRequestUrl = 61,
+   KeepDelimiter = 1073741824,
+   NormalizedHost = 256,
+   Path = 16,
+   PathAndQuery = 48,
+   Port = 8,
+   Query = 32,
+   Scheme = 1,
+   SchemeAndServer = 13,
+   SerializationInfoString = -2147483648,
+   StrongAuthority = 134,
+   StrongPort = 128,
+   UserInfo = 2,
  }
+ public enum UriFormat {
+   SafeUnescaped = 3,
+   Unescaped = 2,
+   UriEscaped = 1,
  }
+ public class UriFormatException : FormatException {
+   public UriFormatException();
+   public UriFormatException(string textString);
+   public UriFormatException(string textString, Exception e);
  }
+ public enum UriHostNameType {
+   Basic = 1,
+   Dns = 2,
+   IPv4 = 3,
+   IPv6 = 4,
+   Unknown = 0,
  }
+ public enum UriKind {
+   Absolute = 1,
+   Relative = 2,
+   RelativeOrAbsolute = 0,
  }
  public abstract class ValueType {
    protected ValueType();
    public override bool Equals(object obj);
-   [MethodImpl(InternalCall)]public override int GetHashCode();
    public override string ToString();
  }
  public sealed class Version : ICloneable, IComparable, IComparable<Version>, IEquatable<Version> {
-   public Version();
    public Version(int major, int minor);
    public Version(int major, int minor, int build);
    public Version(int major, int minor, int build, int revision);
    public Version(string version);
    public int Build { get; }
    public int Major { get; }
    public short MajorRevision { get; }
    public int Minor { get; }
    public short MinorRevision { get; }
    public int Revision { get; }
-   public object Clone();
-   public int CompareTo(object version);
    public int CompareTo(Version value);
    public override bool Equals(object obj);
    public bool Equals(Version obj);
    public override int GetHashCode();
    public static bool operator ==(Version v1, Version v2);
    public static bool operator >(Version v1, Version v2);
    public static bool operator >=(Version v1, Version v2);
    public static bool operator !=(Version v1, Version v2);
    public static bool operator <(Version v1, Version v2);
    public static bool operator <=(Version v1, Version v2);
    public static Version Parse(string input);
+   int System.IComparable.CompareTo(object version);
    public override string ToString();
    public string ToString(int fieldCount);
    public static bool TryParse(string input, out Version result);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
  public struct Void {
  }
  public class WeakReference : ISerializable {
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
-   protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool IsAlive { [MethodImpl(InternalCall)]get; }
    public virtual object Target { [MethodImpl(InternalCall)]get; [MethodImpl(InternalCall)]set; }
    public virtual bool TrackResurrection { get; }
    ~WeakReference();
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public sealed class WeakReference<T> : ISerializable where T : class {
    public WeakReference(T target);
    public WeakReference(T target, bool trackResurrection);
    ~WeakReference();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
-   [MethodImpl(AggressiveInlining)]public bool TryGetTarget(out T target);
  }
 }
 namespace System.Collections {
- public class ArrayList : ICloneable, ICollection, IEnumerable, IList {
-   public ArrayList();
-   public ArrayList(ICollection c);
-   public ArrayList(int capacity);
-   public virtual int Capacity { get; set; }
-   public virtual int Count { get; }
-   public virtual bool IsFixedSize { get; }
-   public virtual bool IsReadOnly { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual object SyncRoot { get; }
-   public virtual object this[int index] { get; set; }
-   public static ArrayList Adapter(IList list);
-   public virtual int Add(object value);
-   public virtual void AddRange(ICollection c);
-   public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
-   public virtual int BinarySearch(object value);
-   public virtual int BinarySearch(object value, IComparer comparer);
-   public virtual void Clear();
-   public virtual object Clone();
-   public virtual bool Contains(object item);
-   public virtual void CopyTo(Array array);
-   public virtual void CopyTo(Array array, int arrayIndex);
-   public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
-   public static ArrayList FixedSize(ArrayList list);
-   public static IList FixedSize(IList list);
-   public virtual IEnumerator GetEnumerator();
-   public virtual IEnumerator GetEnumerator(int index, int count);
-   public virtual ArrayList GetRange(int index, int count);
-   public virtual int IndexOf(object value);
-   public virtual int IndexOf(object value, int startIndex);
-   public virtual int IndexOf(object value, int startIndex, int count);
-   public virtual void Insert(int index, object value);
-   public virtual void InsertRange(int index, ICollection c);
-   public virtual int LastIndexOf(object value);
-   public virtual int LastIndexOf(object value, int startIndex);
-   public virtual int LastIndexOf(object value, int startIndex, int count);
-   public static ArrayList ReadOnly(ArrayList list);
-   public static IList ReadOnly(IList list);
-   public virtual void Remove(object obj);
-   public virtual void RemoveAt(int index);
-   public virtual void RemoveRange(int index, int count);
-   public static ArrayList Repeat(object value, int count);
-   public virtual void Reverse();
-   public virtual void Reverse(int index, int count);
-   public virtual void SetRange(int index, ICollection c);
-   public virtual void Sort();
-   public virtual void Sort(IComparer comparer);
-   public virtual void Sort(int index, int count, IComparer comparer);
-   public static ArrayList Synchronized(ArrayList list);
-   public static IList Synchronized(IList list);
-   public virtual object[] ToArray();
-   public virtual Array ToArray(Type type);
-   public virtual void TrimToSize();
  }
- public sealed class BitArray : ICloneable, ICollection, IEnumerable {
-   public BitArray(bool[] values);
-   public BitArray(byte[] bytes);
-   public BitArray(BitArray bits);
-   public BitArray(int length);
-   public BitArray(int length, bool defaultValue);
-   public BitArray(int[] values);
-   public int Count { get; }
-   public bool IsReadOnly { get; }
-   public bool IsSynchronized { get; }
-   public int Length { get; set; }
-   public object SyncRoot { get; }
-   public bool this[int index] { get; set; }
-   public BitArray And(BitArray value);
-   public object Clone();
-   public void CopyTo(Array array, int index);
-   public bool Get(int index);
-   public IEnumerator GetEnumerator();
-   public BitArray Not();
-   public BitArray Or(BitArray value);
-   public void Set(int index, bool value);
-   public void SetAll(bool value);
-   public BitArray Xor(BitArray value);
  }
- public class CaseInsensitiveComparer : IComparer {
-   public CaseInsensitiveComparer();
-   public CaseInsensitiveComparer(CultureInfo culture);
-   public static CaseInsensitiveComparer Default { get; }
-   public static CaseInsensitiveComparer DefaultInvariant { get; }
-   public int Compare(object a, object b);
  }
- public class CaseInsensitiveHashCodeProvider : IHashCodeProvider {
-   public CaseInsensitiveHashCodeProvider();
-   public CaseInsensitiveHashCodeProvider(CultureInfo culture);
-   public static CaseInsensitiveHashCodeProvider Default { get; }
-   public static CaseInsensitiveHashCodeProvider DefaultInvariant { get; }
-   public int GetHashCode(object obj);
  }
- public abstract class CollectionBase : ICollection, IEnumerable, IList {
-   protected CollectionBase();
-   protected CollectionBase(int capacity);
-   public int Capacity { get; set; }
-   public int Count { get; }
-   protected ArrayList InnerList { get; }
-   protected IList List { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IList.IsFixedSize { get; }
-   bool System.Collections.IList.IsReadOnly { get; }
-   object System.Collections.IList.this[int index] { get; set; }
-   public void Clear();
-   public IEnumerator GetEnumerator();
-   protected virtual void OnClear();
-   protected virtual void OnClearComplete();
-   protected virtual void OnInsert(int index, object value);
-   protected virtual void OnInsertComplete(int index, object value);
-   protected virtual void OnRemove(int index, object value);
-   protected virtual void OnRemoveComplete(int index, object value);
-   protected virtual void OnSet(int index, object oldValue, object newValue);
-   protected virtual void OnSetComplete(int index, object oldValue, object newValue);
-   protected virtual void OnValidate(object value);
-   public void RemoveAt(int index);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   int System.Collections.IList.Add(object value);
-   bool System.Collections.IList.Contains(object value);
-   int System.Collections.IList.IndexOf(object value);
-   void System.Collections.IList.Insert(int index, object value);
-   void System.Collections.IList.Remove(object value);
  }
- public sealed class Comparer : IComparer, ISerializable {
-   public static readonly Comparer Default;
-   public static readonly Comparer DefaultInvariant;
-   public Comparer(CultureInfo culture);
-   public int Compare(object a, object b);
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public abstract class DictionaryBase : ICollection, IDictionary, IEnumerable {
-   protected DictionaryBase();
-   public int Count { get; }
-   protected IDictionary Dictionary { get; }
-   protected Hashtable InnerHashtable { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IDictionary.IsFixedSize { get; }
-   bool System.Collections.IDictionary.IsReadOnly { get; }
-   object System.Collections.IDictionary.this[object key] { get; set; }
-   ICollection System.Collections.IDictionary.Keys { get; }
-   ICollection System.Collections.IDictionary.Values { get; }
-   public void Clear();
-   public void CopyTo(Array array, int index);
-   public IDictionaryEnumerator GetEnumerator();
-   protected virtual void OnClear();
-   protected virtual void OnClearComplete();
-   protected virtual object OnGet(object key, object currentValue);
-   protected virtual void OnInsert(object key, object value);
-   protected virtual void OnInsertComplete(object key, object value);
-   protected virtual void OnRemove(object key, object value);
-   protected virtual void OnRemoveComplete(object key, object value);
-   protected virtual void OnSet(object key, object oldValue, object newValue);
-   protected virtual void OnSetComplete(object key, object oldValue, object newValue);
-   protected virtual void OnValidate(object key, object value);
-   void System.Collections.IDictionary.Add(object key, object value);
-   bool System.Collections.IDictionary.Contains(object key);
-   void System.Collections.IDictionary.Remove(object key);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct DictionaryEntry {
    public DictionaryEntry(object key, object value);
    public object Key { get; set; }
    public object Value { get; set; }
  }
- public class Hashtable : ICloneable, ICollection, IDeserializationCallback, IDictionary, IEnumerable, ISerializable {
-   public Hashtable();
-   public Hashtable(IDictionary d);
-   public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
-   public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
-   public Hashtable(IDictionary d, float loadFactor);
-   public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
-   public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
-   public Hashtable(IEqualityComparer equalityComparer);
-   public Hashtable(IHashCodeProvider hcp, IComparer comparer);
-   public Hashtable(int capacity);
-   public Hashtable(int capacity, IEqualityComparer equalityComparer);
-   public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
-   public Hashtable(int capacity, float loadFactor);
-   public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
-   public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
-   protected Hashtable(SerializationInfo info, StreamingContext context);
-   protected IComparer comparer { get; set; }
-   public virtual int Count { get; }
-   protected IEqualityComparer EqualityComparer { get; }
-   protected IHashCodeProvider hcp { get; set; }
-   public virtual bool IsFixedSize { get; }
-   public virtual bool IsReadOnly { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual ICollection Keys { get; }
-   public virtual object SyncRoot { get; }
-   public virtual object this[object key] { get; set; }
-   public virtual ICollection Values { get; }
-   public virtual void Add(object key, object value);
-   public virtual void Clear();
-   public virtual object Clone();
-   public virtual bool Contains(object key);
-   public virtual bool ContainsKey(object key);
-   public virtual bool ContainsValue(object value);
-   public virtual void CopyTo(Array array, int arrayIndex);
-   public virtual IDictionaryEnumerator GetEnumerator();
-   protected virtual int GetHash(object key);
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   protected virtual bool KeyEquals(object item, object key);
-   public virtual void OnDeserialization(object sender);
-   public virtual void Remove(object key);
-   public static Hashtable Synchronized(Hashtable table);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
  public interface ICollection : IEnumerable {
    int Count { get; }
    bool IsSynchronized { get; }
    object SyncRoot { get; }
    void CopyTo(Array array, int index);
  }
  public interface IComparer {
    int Compare(object x, object y);
  }
  public interface IDictionary : ICollection, IEnumerable {
    bool IsFixedSize { get; }
    bool IsReadOnly { get; }
    ICollection Keys { get; }
    object this[object key] { get; set; }
    ICollection Values { get; }
    void Add(object key, object value);
    void Clear();
    bool Contains(object key);
    new IDictionaryEnumerator GetEnumerator();
    void Remove(object key);
  }
  public interface IDictionaryEnumerator : IEnumerator {
    DictionaryEntry Entry { get; }
    object Key { get; }
    object Value { get; }
  }
  public interface IEnumerable {
    IEnumerator GetEnumerator();
  }
  public interface IEnumerator {
    object Current { get; }
    bool MoveNext();
    void Reset();
  }
  public interface IEqualityComparer {
    bool Equals(object x, object y);
    int GetHashCode(object obj);
  }
- public interface IHashCodeProvider {
-   int GetHashCode(object obj);
  }
  public interface IList : ICollection, IEnumerable {
    bool IsFixedSize { get; }
    bool IsReadOnly { get; }
    object this[int index] { get; set; }
    int Add(object value);
    void Clear();
    bool Contains(object value);
    int IndexOf(object value);
    void Insert(int index, object value);
    void Remove(object value);
    void RemoveAt(int index);
  }
  public interface IStructuralComparable {
    int CompareTo(object other, IComparer comparer);
  }
  public interface IStructuralEquatable {
    bool Equals(object other, IEqualityComparer comparer);
    int GetHashCode(IEqualityComparer comparer);
  }
- public class Queue : ICloneable, ICollection, IEnumerable {
-   public Queue();
-   public Queue(ICollection col);
-   public Queue(int capacity);
-   public Queue(int capacity, float growFactor);
-   public virtual int Count { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual object SyncRoot { get; }
-   public virtual void Clear();
-   public virtual object Clone();
-   public virtual bool Contains(object obj);
-   public virtual void CopyTo(Array array, int index);
-   public virtual object Dequeue();
-   public virtual void Enqueue(object obj);
-   public virtual IEnumerator GetEnumerator();
-   public virtual object Peek();
-   public static Queue Synchronized(Queue queue);
-   public virtual object[] ToArray();
-   public virtual void TrimToSize();
  }
- public abstract class ReadOnlyCollectionBase : ICollection, IEnumerable {
-   protected ReadOnlyCollectionBase();
-   public virtual int Count { get; }
-   protected ArrayList InnerList { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   public virtual IEnumerator GetEnumerator();
-   void System.Collections.ICollection.CopyTo(Array array, int index);
  }
- public class SortedList : ICloneable, ICollection, IDictionary, IEnumerable {
-   public SortedList();
-   public SortedList(IComparer comparer);
-   public SortedList(IComparer comparer, int capacity);
-   public SortedList(IDictionary d);
-   public SortedList(IDictionary d, IComparer comparer);
-   public SortedList(int initialCapacity);
-   public virtual int Capacity { get; set; }
-   public virtual int Count { get; }
-   public virtual bool IsFixedSize { get; }
-   public virtual bool IsReadOnly { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual ICollection Keys { get; }
-   public virtual object SyncRoot { get; }
-   public virtual object this[object key] { get; set; }
-   public virtual ICollection Values { get; }
-   public virtual void Add(object key, object value);
-   public virtual void Clear();
-   public virtual object Clone();
-   public virtual bool Contains(object key);
-   public virtual bool ContainsKey(object key);
-   public virtual bool ContainsValue(object value);
-   public virtual void CopyTo(Array array, int arrayIndex);
-   public virtual object GetByIndex(int index);
-   public virtual IDictionaryEnumerator GetEnumerator();
-   public virtual object GetKey(int index);
-   public virtual IList GetKeyList();
-   public virtual IList GetValueList();
-   public virtual int IndexOfKey(object key);
-   public virtual int IndexOfValue(object value);
-   public virtual void Remove(object key);
-   public virtual void RemoveAt(int index);
-   public virtual void SetByIndex(int index, object value);
-   public static SortedList Synchronized(SortedList list);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public virtual void TrimToSize();
  }
- public class Stack : ICloneable, ICollection, IEnumerable {
-   public Stack();
-   public Stack(ICollection col);
-   public Stack(int initialCapacity);
-   public virtual int Count { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual object SyncRoot { get; }
-   public virtual void Clear();
-   public virtual object Clone();
-   public virtual bool Contains(object obj);
-   public virtual void CopyTo(Array array, int index);
-   public virtual IEnumerator GetEnumerator();
-   public virtual object Peek();
-   public virtual object Pop();
-   public virtual void Push(object obj);
-   public static Stack Synchronized(Stack stack);
-   public virtual object[] ToArray();
  }
- public static class StructuralComparisons {
-   public static IComparer StructuralComparer { get; }
-   public static IEqualityComparer StructuralEqualityComparer { get; }
  }
 }
-namespace System.Collections.Concurrent {
- public class ConcurrentDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
-   public ConcurrentDictionary();
-   public ConcurrentDictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection);
-   public ConcurrentDictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer);
-   public ConcurrentDictionary(IEqualityComparer<TKey> comparer);
-   public ConcurrentDictionary(int concurrencyLevel, IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer);
-   public ConcurrentDictionary(int concurrencyLevel, int capacity);
-   public ConcurrentDictionary(int concurrencyLevel, int capacity, IEqualityComparer<TKey> comparer);
-   public int Count { get; }
-   public bool IsEmpty { get; }
-   public ICollection<TKey> Keys { get; }
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
-   IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
-   IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IDictionary.IsFixedSize { get; }
-   bool System.Collections.IDictionary.IsReadOnly { get; }
-   object System.Collections.IDictionary.this[object key] { get; set; }
-   ICollection System.Collections.IDictionary.Keys { get; }
-   ICollection System.Collections.IDictionary.Values { get; }
-   public TValue this[TKey key] { get; set; }
-   public ICollection<TValue> Values { get; }
-   public TValue AddOrUpdate(TKey key, Func<TKey, TValue> addValueFactory, Func<TKey, TValue, TValue> updateValueFactory);
-   public TValue AddOrUpdate(TKey key, TValue addValue, Func<TKey, TValue, TValue> updateValueFactory);
-   public void Clear();
-   public bool ContainsKey(TKey key);
-   public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
-   public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory);
-   public TValue GetOrAdd(TKey key, TValue value);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int index);
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
-   void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
-   bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   void System.Collections.IDictionary.Add(object key, object value);
-   bool System.Collections.IDictionary.Contains(object key);
-   IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
-   void System.Collections.IDictionary.Remove(object key);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public KeyValuePair<TKey, TValue>[] ToArray();
-   public bool TryAdd(TKey key, TValue value);
-   public bool TryGetValue(TKey key, out TValue value);
-   public bool TryRemove(TKey key, out TValue value);
-   public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
  }
- public class ConcurrentQueue<T> : ICollection, IEnumerable, IEnumerable<T>, IProducerConsumerCollection<T>, IReadOnlyCollection<T> {
-   public ConcurrentQueue();
-   public ConcurrentQueue(IEnumerable<T> collection);
-   public int Count { get; }
-   public bool IsEmpty { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   public void CopyTo(T[] array, int index);
-   public void Enqueue(T item);
-   public IEnumerator<T> GetEnumerator();
-   bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
-   bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(out T item);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public T[] ToArray();
-   public bool TryDequeue(out T result);
-   public bool TryPeek(out T result);
  }
- public class ConcurrentStack<T> : ICollection, IEnumerable, IEnumerable<T>, IProducerConsumerCollection<T>, IReadOnlyCollection<T> {
-   public ConcurrentStack();
-   public ConcurrentStack(IEnumerable<T> collection);
-   public int Count { get; }
-   public bool IsEmpty { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   public void Clear();
-   public void CopyTo(T[] array, int index);
-   public IEnumerator<T> GetEnumerator();
-   public void Push(T item);
-   public void PushRange(T[] items);
-   public void PushRange(T[] items, int startIndex, int count);
-   bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
-   bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(out T item);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public T[] ToArray();
-   public bool TryPeek(out T result);
-   public bool TryPop(out T result);
-   public int TryPopRange(T[] items);
-   public int TryPopRange(T[] items, int startIndex, int count);
  }
- public enum EnumerablePartitionerOptions {
-   NoBuffering = 1,
-   None = 0,
  }
- public interface IProducerConsumerCollection<T> : ICollection, IEnumerable, IEnumerable<T> {
-   void CopyTo(T[] array, int index);
-   T[] ToArray();
-   bool TryAdd(T item);
-   bool TryTake(out T item);
  }
- public abstract class OrderablePartitioner<TSource> : Partitioner<TSource> {
-   protected OrderablePartitioner(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
-   public bool KeysNormalized { get; }
-   public bool KeysOrderedAcrossPartitions { get; }
-   public bool KeysOrderedInEachPartition { get; }
-   public override IEnumerable<TSource> GetDynamicPartitions();
-   public virtual IEnumerable<KeyValuePair<long, TSource>> GetOrderableDynamicPartitions();
-   public abstract IList<IEnumerator<KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
-   public override IList<IEnumerator<TSource>> GetPartitions(int partitionCount);
  }
- public static class Partitioner {
-   public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive);
-   public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
-   public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive);
-   public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
-   public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source);
-   public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source, EnumerablePartitionerOptions partitionerOptions);
-   public static OrderablePartitioner<TSource> Create<TSource>(IList<TSource> list, bool loadBalance);
-   public static OrderablePartitioner<TSource> Create<TSource>(TSource[] array, bool loadBalance);
  }
- public abstract class Partitioner<TSource> {
-   protected Partitioner();
-   public virtual bool SupportsDynamicPartitions { get; }
-   public virtual IEnumerable<TSource> GetDynamicPartitions();
-   public abstract IList<IEnumerator<TSource>> GetPartitions(int partitionCount);
  }
 }
 namespace System.Collections.Generic {
- public abstract class Comparer<T> : IComparer, IComparer<T> {
-   protected Comparer();
-   public static Comparer<T> Default { get; }
-   public abstract int Compare(T x, T y);
-   public static Comparer<T> Create(Comparison<T> comparison);
-   int System.Collections.IComparer.Compare(object x, object y);
  }
- public class Dictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDeserializationCallback, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ISerializable {
-   public Dictionary();
-   public Dictionary(IDictionary<TKey, TValue> dictionary);
-   public Dictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer);
-   public Dictionary(IEqualityComparer<TKey> comparer);
-   public Dictionary(int capacity);
-   public Dictionary(int capacity, IEqualityComparer<TKey> comparer);
-   protected Dictionary(SerializationInfo info, StreamingContext context);
-   public IEqualityComparer<TKey> Comparer { get; }
-   public int Count { get; }
-   public Dictionary<TKey, TValue>.KeyCollection Keys { get; }
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
-   ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
-   ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
-   IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
-   IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IDictionary.IsFixedSize { get; }
-   bool System.Collections.IDictionary.IsReadOnly { get; }
-   object System.Collections.IDictionary.this[object key] { get; set; }
-   ICollection System.Collections.IDictionary.Keys { get; }
-   ICollection System.Collections.IDictionary.Values { get; }
-   public TValue this[TKey key] { get; set; }
-   public Dictionary<TKey, TValue>.ValueCollection Values { get; }
-   public void Add(TKey key, TValue value);
-   public void Clear();
-   public bool ContainsKey(TKey key);
-   public bool ContainsValue(TValue value);
-   public Dictionary<TKey, TValue>.Enumerator GetEnumerator();
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual void OnDeserialization(object sender);
-   public bool Remove(TKey key);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int index);
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
-   IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   void System.Collections.IDictionary.Add(object key, object value);
-   bool System.Collections.IDictionary.Contains(object key);
-   IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
-   void System.Collections.IDictionary.Remove(object key);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public bool TryGetValue(TKey key, out TValue value);
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct Enumerator : IDictionaryEnumerator, IDisposable, IEnumerator, IEnumerator<KeyValuePair<TKey, TValue>> {
-     public KeyValuePair<TKey, TValue> Current { get; }
-     DictionaryEntry System.Collections.IDictionaryEnumerator.Entry { get; }
-     object System.Collections.IDictionaryEnumerator.Key { get; }
-     object System.Collections.IDictionaryEnumerator.Value { get; }
-     object System.Collections.IEnumerator.Current { get; }
-     public void Dispose();
-     public bool MoveNext();
-     void System.Collections.IEnumerator.Reset();
    }
-   public sealed class KeyCollection : ICollection, ICollection<TKey>, IEnumerable, IEnumerable<TKey>, IReadOnlyCollection<TKey> {
-     public KeyCollection(Dictionary<TKey, TValue> dictionary);
-     public int Count { get; }
-     bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
-     bool System.Collections.ICollection.IsSynchronized { get; }
-     object System.Collections.ICollection.SyncRoot { get; }
-     public void CopyTo(TKey[] array, int index);
-     public Dictionary<TKey, TValue>.KeyCollection.Enumerator GetEnumerator();
-     void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
-     void System.Collections.Generic.ICollection<TKey>.Clear();
-     bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
-     bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
-     IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
-     void System.Collections.ICollection.CopyTo(Array array, int index);
-     IEnumerator System.Collections.IEnumerable.GetEnumerator();
-     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
      public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TKey> {
-       public TKey Current { get; }
-       object System.Collections.IEnumerator.Current { get; }
-       public void Dispose();
-       public bool MoveNext();
-       void System.Collections.IEnumerator.Reset();
      }
    }
-   public sealed class ValueCollection : ICollection, ICollection<TValue>, IEnumerable, IEnumerable<TValue>, IReadOnlyCollection<TValue> {
-     public ValueCollection(Dictionary<TKey, TValue> dictionary);
-     public int Count { get; }
-     bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
-     bool System.Collections.ICollection.IsSynchronized { get; }
-     object System.Collections.ICollection.SyncRoot { get; }
-     public void CopyTo(TValue[] array, int index);
-     public Dictionary<TKey, TValue>.ValueCollection.Enumerator GetEnumerator();
-     void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
-     void System.Collections.Generic.ICollection<TValue>.Clear();
-     bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
-     bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
-     IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
-     void System.Collections.ICollection.CopyTo(Array array, int index);
-     IEnumerator System.Collections.IEnumerable.GetEnumerator();
-     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
      public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TValue> {
-       public TValue Current { get; }
-       object System.Collections.IEnumerator.Current { get; }
-       public void Dispose();
-       public bool MoveNext();
-       void System.Collections.IEnumerator.Reset();
      }
    }
  }
- public abstract class EqualityComparer<T> : IEqualityComparer, IEqualityComparer<T> {
-   protected EqualityComparer();
-   public static EqualityComparer<T> Default { get; }
-   public abstract bool Equals(T x, T y);
-   public abstract int GetHashCode(T obj);
-   bool System.Collections.IEqualityComparer.Equals(object x, object y);
-   int System.Collections.IEqualityComparer.GetHashCode(object obj);
  }
  public interface ICollection<T> : IEnumerable, IEnumerable<T> {
    int Count { get; }
    bool IsReadOnly { get; }
    void Add(T item);
    void Clear();
    bool Contains(T item);
    void CopyTo(T[] array, int arrayIndex);
    bool Remove(T item);
  }
  public interface IComparer<in T> {
    int Compare(T x, T y);
  }
  public interface IDictionary<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>> {
    ICollection<TKey> Keys { get; }
    TValue this[TKey key] { get; set; }
    ICollection<TValue> Values { get; }
    void Add(TKey key, TValue value);
    bool ContainsKey(TKey key);
    bool Remove(TKey key);
    bool TryGetValue(TKey key, out TValue value);
  }
  public interface IEnumerable<out T> : IEnumerable {
    new IEnumerator<T> GetEnumerator();
  }
  public interface IEnumerator<out T> : IDisposable, IEnumerator {
    new T Current { get; }
  }
  public interface IEqualityComparer<in T> {
    bool Equals(T x, T y);
    int GetHashCode(T obj);
  }
  public interface IList<T> : ICollection<T>, IEnumerable, IEnumerable<T> {
    T this[int index] { get; set; }
    int IndexOf(T item);
    void Insert(int index, T item);
    void RemoveAt(int index);
  }
  public interface IReadOnlyCollection<out T> : IEnumerable, IEnumerable<T> {
    int Count { get; }
  }
  public interface IReadOnlyDictionary<TKey, TValue> : IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>> {
    IEnumerable<TKey> Keys { get; }
    TValue this[TKey key] { get; }
    IEnumerable<TValue> Values { get; }
    bool ContainsKey(TKey key);
    bool TryGetValue(TKey key, out TValue value);
  }
  public interface IReadOnlyList<out T> : IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
    T this[int index] { get; }
  }
+ public interface ISet<T> : ICollection<T>, IEnumerable, IEnumerable<T> {
+   new bool Add(T item);
+   void ExceptWith(IEnumerable<T> other);
+   void IntersectWith(IEnumerable<T> other);
+   bool IsProperSubsetOf(IEnumerable<T> other);
+   bool IsProperSupersetOf(IEnumerable<T> other);
+   bool IsSubsetOf(IEnumerable<T> other);
+   bool IsSupersetOf(IEnumerable<T> other);
+   bool Overlaps(IEnumerable<T> other);
+   bool SetEquals(IEnumerable<T> other);
+   void SymmetricExceptWith(IEnumerable<T> other);
+   void UnionWith(IEnumerable<T> other);
  }
  public class KeyNotFoundException : SystemExceptionException, ISerializable {
    public KeyNotFoundException();
-   protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct KeyValuePair<TKey, TValue> {
    public KeyValuePair(TKey key, TValue value);
    public TKey Key { get; }
    public TValue Value { get; }
    public override string ToString();
  }
- public class List<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
-   public List();
-   public List(IEnumerable<T> collection);
-   public List(int capacity);
-   public int Capacity { get; set; }
-   public int Count { get; }
-   bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IList.IsFixedSize { get; }
-   bool System.Collections.IList.IsReadOnly { get; }
-   object System.Collections.IList.this[int index] { get; set; }
-   public T this[int index] { get; set; }
-   public void Add(T item);
-   public void AddRange(IEnumerable<T> collection);
-   public ReadOnlyCollection<T> AsReadOnly();
-   public int BinarySearch(int index, int count, T item, IComparer<T> comparer);
-   public int BinarySearch(T item);
-   public int BinarySearch(T item, IComparer<T> comparer);
-   public void Clear();
-   public bool Contains(T item);
-   public List<TOutput> ConvertAll<TOutput>(Converter<T, TOutput> converter);
-   public void CopyTo(int index, T[] array, int arrayIndex, int count);
-   public void CopyTo(T[] array);
-   public void CopyTo(T[] array, int arrayIndex);
-   public bool Exists(Predicate<T> match);
-   public T Find(Predicate<T> match);
-   public List<T> FindAll(Predicate<T> match);
-   public int FindIndex(int startIndex, int count, Predicate<T> match);
-   public int FindIndex(int startIndex, Predicate<T> match);
-   public int FindIndex(Predicate<T> match);
-   public T FindLast(Predicate<T> match);
-   public int FindLastIndex(int startIndex, int count, Predicate<T> match);
-   public int FindLastIndex(int startIndex, Predicate<T> match);
-   public int FindLastIndex(Predicate<T> match);
-   public void ForEach(Action<T> action);
-   public List<T>.Enumerator GetEnumerator();
-   public List<T> GetRange(int index, int count);
-   public int IndexOf(T item);
-   public int IndexOf(T item, int index);
-   public int IndexOf(T item, int index, int count);
-   public void Insert(int index, T item);
-   public void InsertRange(int index, IEnumerable<T> collection);
-   public int LastIndexOf(T item);
-   public int LastIndexOf(T item, int index);
-   public int LastIndexOf(T item, int index, int count);
-   public bool Remove(T item);
-   public int RemoveAll(Predicate<T> match);
-   public void RemoveAt(int index);
-   public void RemoveRange(int index, int count);
-   public void Reverse();
-   public void Reverse(int index, int count);
-   public void Sort();
-   public void Sort(IComparer<T> comparer);
-   public void Sort(Comparison<T> comparison);
-   public void Sort(int index, int count, IComparer<T> comparer);
-   IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
-   void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   int System.Collections.IList.Add(object item);
-   bool System.Collections.IList.Contains(object item);
-   int System.Collections.IList.IndexOf(object item);
-   void System.Collections.IList.Insert(int index, object item);
-   void System.Collections.IList.Remove(object item);
-   public T[] ToArray();
-   public void TrimExcess();
-   public bool TrueForAll(Predicate<T> match);
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
-     public T Current { get; }
-     object System.Collections.IEnumerator.Current { get; }
-     public void Dispose();
-     public bool MoveNext();
-     void System.Collections.IEnumerator.Reset();
    }
  }
 }
 namespace System.Collections.ObjectModel {
  public class Collection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
    public Collection();
    public Collection(IList<T> list);
    public int Count { get; }
    protected IList<T> Items { get; }
    bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    bool System.Collections.ICollection.IsSynchronized { get; }
    object System.Collections.ICollection.SyncRoot { get; }
    bool System.Collections.IList.IsFixedSize { get; }
    bool System.Collections.IList.IsReadOnly { get; }
    object System.Collections.IList.this[int index] { get; set; }
    public T this[int index] { get; set; }
    public void Add(T item);
    public void Clear();
    protected virtual void ClearItems();
    public bool Contains(T item);
    public void CopyTo(T[] array, int index);
    public IEnumerator<T> GetEnumerator();
    public int IndexOf(T item);
    public void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public bool Remove(T item);
    public void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    void System.Collections.ICollection.CopyTo(Array array, int index);
    IEnumerator System.Collections.IEnumerable.GetEnumerator();
    int System.Collections.IList.Add(object value);
    bool System.Collections.IList.Contains(object value);
    int System.Collections.IList.IndexOf(object value);
    void System.Collections.IList.Insert(int index, object value);
    void System.Collections.IList.Remove(object value);
  }
- public abstract class KeyedCollection<TKey, TItem> : Collection<TItem> {
-   protected KeyedCollection();
-   protected KeyedCollection(IEqualityComparer<TKey> comparer);
-   protected KeyedCollection(IEqualityComparer<TKey> comparer, int dictionaryCreationThreshold);
-   public IEqualityComparer<TKey> Comparer { get; }
-   protected IDictionary<TKey, TItem> Dictionary { get; }
-   public TItem this[TKey key] { get; }
-   protected void ChangeItemKey(TItem item, TKey newKey);
-   protected override void ClearItems();
-   public bool Contains(TKey key);
-   protected abstract TKey GetKeyForItem(TItem item);
-   protected override void InsertItem(int index, TItem item);
-   public bool Remove(TKey key);
-   protected override void RemoveItem(int index);
-   protected override void SetItem(int index, TItem item);
  }
  public class ReadOnlyCollection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
    public ReadOnlyCollection(IList<T> list);
    public int Count { get; }
    protected IList<T> Items { get; }
    bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    T System.Collections.Generic.IList<T>.this[int index] { get; set; }
    bool System.Collections.ICollection.IsSynchronized { get; }
    object System.Collections.ICollection.SyncRoot { get; }
    bool System.Collections.IList.IsFixedSize { get; }
    bool System.Collections.IList.IsReadOnly { get; }
    object System.Collections.IList.this[int index] { get; set; }
    public T this[int index] { get; }
    public bool Contains(T value);
    public void CopyTo(T[] array, int index);
    public IEnumerator<T> GetEnumerator();
    public int IndexOf(T value);
    void System.Collections.Generic.ICollection<T>.Add(T value);
    void System.Collections.Generic.ICollection<T>.Clear();
    bool System.Collections.Generic.ICollection<T>.Remove(T value);
    void System.Collections.Generic.IList<T>.Insert(int index, T value);
    void System.Collections.Generic.IList<T>.RemoveAt(int index);
    void System.Collections.ICollection.CopyTo(Array array, int index);
    IEnumerator System.Collections.IEnumerable.GetEnumerator();
    int System.Collections.IList.Add(object value);
    void System.Collections.IList.Clear();
    bool System.Collections.IList.Contains(object value);
    int System.Collections.IList.IndexOf(object value);
    void System.Collections.IList.Insert(int index, object value);
    void System.Collections.IList.Remove(object value);
    void System.Collections.IList.RemoveAt(int index);
  }
- public class ReadOnlyDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
-   public ReadOnlyDictionary(IDictionary<TKey, TValue> dictionary);
-   public int Count { get; }
-   protected IDictionary<TKey, TValue> Dictionary { get; }
-   public ReadOnlyDictionary<TKey, TValue>.KeyCollection Keys { get; }
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
-   TValue System.Collections.Generic.IDictionary<TKey,TValue>.this[TKey key] { get; set; }
-   ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
-   ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
-   IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
-   IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
-   bool System.Collections.ICollection.IsSynchronized { get; }
-   object System.Collections.ICollection.SyncRoot { get; }
-   bool System.Collections.IDictionary.IsFixedSize { get; }
-   bool System.Collections.IDictionary.IsReadOnly { get; }
-   object System.Collections.IDictionary.this[object key] { get; set; }
-   ICollection System.Collections.IDictionary.Keys { get; }
-   ICollection System.Collections.IDictionary.Values { get; }
-   public TValue this[TKey key] { get; }
-   public ReadOnlyDictionary<TKey, TValue>.ValueCollection Values { get; }
-   public bool ContainsKey(TKey key);
-   public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> item);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> item);
-   void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
-   bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> item);
-   void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
-   bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   void System.Collections.IDictionary.Add(object key, object value);
-   void System.Collections.IDictionary.Clear();
-   bool System.Collections.IDictionary.Contains(object key);
-   IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
-   void System.Collections.IDictionary.Remove(object key);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public bool TryGetValue(TKey key, out TValue value);
-   public sealed class KeyCollection : ICollection, ICollection<TKey>, IEnumerable, IEnumerable<TKey>, IReadOnlyCollection<TKey> {
-     public int Count { get; }
-     bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
-     bool System.Collections.ICollection.IsSynchronized { get; }
-     object System.Collections.ICollection.SyncRoot { get; }
-     public void CopyTo(TKey[] array, int arrayIndex);
-     public IEnumerator<TKey> GetEnumerator();
-     void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
-     void System.Collections.Generic.ICollection<TKey>.Clear();
-     bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
-     bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
-     void System.Collections.ICollection.CopyTo(Array array, int index);
-     IEnumerator System.Collections.IEnumerable.GetEnumerator();
    }
-   public sealed class ValueCollection : ICollection, ICollection<TValue>, IEnumerable, IEnumerable<TValue>, IReadOnlyCollection<TValue> {
-     public int Count { get; }
-     bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
-     bool System.Collections.ICollection.IsSynchronized { get; }
-     object System.Collections.ICollection.SyncRoot { get; }
-     public void CopyTo(TValue[] array, int arrayIndex);
-     public IEnumerator<TValue> GetEnumerator();
-     void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
-     void System.Collections.Generic.ICollection<TValue>.Clear();
-     bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
-     bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
-     void System.Collections.ICollection.CopyTo(Array array, int index);
-     IEnumerator System.Collections.IEnumerable.GetEnumerator();
    }
  }
 }
+namespace System.ComponentModel {
+ public class DefaultValueAttribute : Attribute {
+   public DefaultValueAttribute(bool value);
+   public DefaultValueAttribute(byte value);
+   public DefaultValueAttribute(char value);
+   public DefaultValueAttribute(double value);
+   public DefaultValueAttribute(short value);
+   public DefaultValueAttribute(int value);
+   public DefaultValueAttribute(long value);
+   public DefaultValueAttribute(object value);
+   public DefaultValueAttribute(float value);
+   public DefaultValueAttribute(string value);
+   public DefaultValueAttribute(Type type, string value);
+   public virtual object Value { get; }
+   public override bool Equals(object obj);
+   public override int GetHashCode();
  }
+ public sealed class EditorBrowsableAttribute : Attribute {
+   public EditorBrowsableAttribute(EditorBrowsableState state);
+   public EditorBrowsableState State { get; }
+   public override bool Equals(object obj);
+   public override int GetHashCode();
  }
+ public enum EditorBrowsableState {
+   Advanced = 2,
+   Always = 0,
+   Never = 1,
  }
 }
-namespace System.Configuration.Assemblies {
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AssemblyHash : ICloneable {
-   public static readonly AssemblyHash Empty;
-   public AssemblyHash(byte[] value);
-   public AssemblyHash(AssemblyHashAlgorithm algorithm, byte[] value);
-   public AssemblyHashAlgorithm Algorithm { get; set; }
-   public object Clone();
-   public byte[] GetValue();
-   public void SetValue(byte[] value);
  }
- public enum AssemblyHashAlgorithm {
-   MD5 = 32771,
-   None = 0,
-   SHA1 = 32772,
-   SHA256 = 32780,
-   SHA384 = 32781,
-   SHA512 = 32782,
  }
- public enum AssemblyVersionCompatibility {
-   SameDomain = 3,
-   SameMachine = 1,
-   SameProcess = 2,
  }
 }
-namespace System.Deployment.Internal {
- public static class InternalActivationContextHelper {
-   public static object GetActivationContextData(ActivationContext appInfo);
-   public static object GetApplicationComponentManifest(ActivationContext appInfo);
-   public static byte[] GetApplicationManifestBytes(ActivationContext appInfo);
-   public static object GetDeploymentComponentManifest(ActivationContext appInfo);
-   public static byte[] GetDeploymentManifestBytes(ActivationContext appInfo);
-   public static bool IsFirstRun(ActivationContext appInfo);
-   public static void PrepareForExecution(ActivationContext appInfo);
  }
- public static class InternalApplicationIdentityHelper {
-   public static object GetInternalAppId(ApplicationIdentity id);
  }
 }
 namespace System.Diagnostics {
  public sealed class ConditionalAttribute : Attribute {
    public ConditionalAttribute(string conditionString);
    public string ConditionString { get; }
  }
  public sealed class DebuggableAttribute : Attribute {
    public DebuggableAttribute(DebuggableAttribute.DebuggingModes modes);
-   public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
-   public DebuggableAttribute.DebuggingModes DebuggingFlags { get; }
-   public bool IsJITOptimizerDisabled { get; }
-   public bool IsJITTrackingEnabled { get; }
    public enum DebuggingModes {
      Default = 1,
      DisableOptimizations = 256,
      EnableEditAndContinue = 4,
      IgnoreSymbolStoreSequencePoints = 2,
      None = 0,
    }
  }
- public sealed class Debugger {
-   public static readonly string DefaultCategory;
-   public Debugger();
-   public static bool IsAttached { [MethodImpl(InternalCall)]get; }
-   public static void Break();
-   [MethodImpl(InternalCall)]public static bool IsLogging();
-   public static bool Launch();
-   [MethodImpl(InternalCall)]public static void Log(int level, string category, string message);
-   public static void NotifyOfCrossThreadDependency();
  }
- public sealed class DebuggerBrowsableAttribute : Attribute {
-   public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
-   public DebuggerBrowsableState State { get; }
  }
- public enum DebuggerBrowsableState {
-   Collapsed = 2,
-   Never = 0,
-   RootHidden = 3,
  }
- public sealed class DebuggerDisplayAttribute : Attribute {
-   public DebuggerDisplayAttribute(string value);
-   public string Name { get; set; }
-   public Type Target { get; set; }
-   public string TargetTypeName { get; set; }
-   public string Type { get; set; }
-   public string Value { get; }
  }
- public sealed class DebuggerHiddenAttribute : Attribute {
-   public DebuggerHiddenAttribute();
  }
- public sealed class DebuggerNonUserCodeAttribute : Attribute {
-   public DebuggerNonUserCodeAttribute();
  }
- public sealed class DebuggerStepperBoundaryAttribute : Attribute {
-   public DebuggerStepperBoundaryAttribute();
  }
- public sealed class DebuggerStepThroughAttribute : Attribute {
-   public DebuggerStepThroughAttribute();
  }
- public sealed class DebuggerTypeProxyAttribute : Attribute {
-   public DebuggerTypeProxyAttribute(string typeName);
-   public DebuggerTypeProxyAttribute(Type type);
-   public string ProxyTypeName { get; }
-   public Type Target { get; set; }
-   public string TargetTypeName { get; set; }
  }
- public sealed class DebuggerVisualizerAttribute : Attribute {
-   public DebuggerVisualizerAttribute(string visualizerTypeName);
-   public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
-   public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
-   public DebuggerVisualizerAttribute(Type visualizer);
-   public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
-   public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
-   public string Description { get; set; }
-   public Type Target { get; set; }
-   public string TargetTypeName { get; set; }
-   public string VisualizerObjectSourceTypeName { get; }
-   public string VisualizerTypeName { get; }
  }
- public class StackFrame {
-   public const int OFFSET_UNKNOWN = -1;
-   public StackFrame();
-   public StackFrame(bool fNeedFileInfo);
-   public StackFrame(int skipFrames);
-   public StackFrame(int skipFrames, bool fNeedFileInfo);
-   public StackFrame(string fileName, int lineNumber);
-   public StackFrame(string fileName, int lineNumber, int colNumber);
-   public virtual int GetFileColumnNumber();
-   public virtual int GetFileLineNumber();
-   public virtual string GetFileName();
-   public virtual int GetILOffset();
-   public virtual MethodBase GetMethod();
-   public virtual int GetNativeOffset();
-   public override string ToString();
  }
- public class StackTrace {
-   public const int METHODS_TO_SKIP = 0;
-   public StackTrace();
-   public StackTrace(bool fNeedFileInfo);
-   public StackTrace(StackFrame frame);
-   public StackTrace(Exception e);
-   public StackTrace(Exception e, bool fNeedFileInfo);
-   public StackTrace(Exception e, int skipFrames);
-   public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
-   public StackTrace(int skipFrames);
-   public StackTrace(int skipFrames, bool fNeedFileInfo);
-   public StackTrace(Thread targetThread, bool needFileInfo);
-   public virtual int FrameCount { get; }
-   public virtual StackFrame GetFrame(int index);
-   public virtual StackFrame[] GetFrames();
-   public override string ToString();
  }
 }
-namespace System.Diagnostics.CodeAnalysis {
- public sealed class SuppressMessageAttribute : Attribute {
-   public SuppressMessageAttribute(string category, string checkId);
-   public string Category { get; }
-   public string CheckId { get; }
-   public string Justification { get; set; }
-   public string MessageId { get; set; }
-   public string Scope { get; set; }
-   public string Target { get; set; }
  }
 }
-namespace System.Diagnostics.Contracts {
- public static class Contract {
-   public static event EventHandler<ContractFailedEventArgs> ContractFailed;
-   public static void Assert(bool condition);
-   public static void Assert(bool condition, string userMessage);
-   public static void Assume(bool condition);
-   public static void Assume(bool condition, string userMessage);
-   public static void EndContractBlock();
-   public static void Ensures(bool condition);
-   public static void Ensures(bool condition, string userMessage);
-   public static void EnsuresOnThrow<TException>(bool condition) where TException : Exception;
-   public static void EnsuresOnThrow<TException>(bool condition, string userMessage) where TException : Exception;
-   public static bool Exists(int fromInclusive, int toExclusive, Predicate<int> predicate);
-   public static bool Exists<T>(IEnumerable<T> collection, Predicate<T> predicate);
-   public static bool ForAll(int fromInclusive, int toExclusive, Predicate<int> predicate);
-   public static bool ForAll<T>(IEnumerable<T> collection, Predicate<T> predicate);
-   public static void Invariant(bool condition);
-   public static void Invariant(bool condition, string userMessage);
-   public static T OldValue<T>(T value);
-   public static void Requires(bool condition);
-   public static void Requires(bool condition, string userMessage);
-   public static void Requires<TException>(bool condition) where TException : Exception;
-   public static void Requires<TException>(bool condition, string userMessage) where TException : Exception;
-   public static T Result<T>();
-   public static T ValueAtReturn<T>(out T value);
  }
- public sealed class ContractAbbreviatorAttribute : Attribute {
-   public ContractAbbreviatorAttribute();
  }
- public sealed class ContractArgumentValidatorAttribute : Attribute {
-   public ContractArgumentValidatorAttribute();
  }
- public sealed class ContractClassAttribute : Attribute {
-   public ContractClassAttribute(Type typeContainingContracts);
-   public Type TypeContainingContracts { get; }
  }
- public sealed class ContractClassForAttribute : Attribute {
-   public ContractClassForAttribute(Type typeContractsAreFor);
-   public Type TypeContractsAreFor { get; }
  }
- public sealed class ContractFailedEventArgs : EventArgs {
-   public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
-   public string Condition { get; }
-   public ContractFailureKind FailureKind { get; }
-   public bool Handled { get; }
-   public string Message { get; }
-   public Exception OriginalException { get; }
-   public bool Unwind { get; }
-   public void SetHandled();
-   public void SetUnwind();
  }
- public enum ContractFailureKind {
-   Assert = 4,
-   Assume = 5,
-   Invariant = 3,
-   Postcondition = 1,
-   PostconditionOnException = 2,
-   Precondition = 0,
  }
- public sealed class ContractInvariantMethodAttribute : Attribute {
-   public ContractInvariantMethodAttribute();
  }
- public sealed class ContractOptionAttribute : Attribute {
-   public ContractOptionAttribute(string category, string setting, bool enabled);
-   public ContractOptionAttribute(string category, string setting, string value);
-   public string Category { get; }
-   public bool Enabled { get; }
-   public string Setting { get; }
-   public string Value { get; }
  }
- public sealed class ContractPublicPropertyNameAttribute : Attribute {
-   public ContractPublicPropertyNameAttribute(string name);
-   public string Name { get; }
  }
- public sealed class ContractReferenceAssemblyAttribute : Attribute {
-   public ContractReferenceAssemblyAttribute();
  }
- public sealed class ContractRuntimeIgnoredAttribute : Attribute {
-   public ContractRuntimeIgnoredAttribute();
  }
- public sealed class ContractVerificationAttribute : Attribute {
-   public ContractVerificationAttribute(bool value);
-   public bool Value { get; }
  }
- public sealed class PureAttribute : Attribute {
-   public PureAttribute();
  }
 }
-namespace System.Diagnostics.Contracts.Internal {
- public static class ContractHelper {
-   public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
-   public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
  }
 }
-namespace System.Diagnostics.SymbolStore {
- public interface ISymbolBinder {
-   ISymbolReader GetReader(int importer, string filename, string searchPath);
  }
- public interface ISymbolBinder1 {
-   ISymbolReader GetReader(IntPtr importer, string filename, string searchPath);
  }
- public interface ISymbolDocument {
-   Guid CheckSumAlgorithmId { get; }
-   Guid DocumentType { get; }
-   bool HasEmbeddedSource { get; }
-   Guid Language { get; }
-   Guid LanguageVendor { get; }
-   int SourceLength { get; }
-   string URL { get; }
-   int FindClosestLine(int line);
-   byte[] GetCheckSum();
-   byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn);
  }
- public interface ISymbolDocumentWriter {
-   void SetCheckSum(Guid algorithmId, byte[] checkSum);
-   void SetSource(byte[] source);
  }
- public interface ISymbolMethod {
-   ISymbolScope RootScope { get; }
-   int SequencePointCount { get; }
-   SymbolToken Token { get; }
-   ISymbolNamespace GetNamespace();
-   int GetOffset(ISymbolDocument document, int line, int column);
-   ISymbolVariable[] GetParameters();
-   int[] GetRanges(ISymbolDocument document, int line, int column);
-   ISymbolScope GetScope(int offset);
-   void GetSequencePoints(int[] offsets, ISymbolDocument[] documents, int[] lines, int[] columns, int[] endLines, int[] endColumns);
-   bool GetSourceStartEnd(ISymbolDocument[] docs, int[] lines, int[] columns);
  }
- public interface ISymbolNamespace {
-   string Name { get; }
-   ISymbolNamespace[] GetNamespaces();
-   ISymbolVariable[] GetVariables();
  }
- public interface ISymbolReader {
-   SymbolToken UserEntryPoint { get; }
-   ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType);
-   ISymbolDocument[] GetDocuments();
-   ISymbolVariable[] GetGlobalVariables();
-   ISymbolMethod GetMethod(SymbolToken method);
-   ISymbolMethod GetMethod(SymbolToken method, int version);
-   ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column);
-   ISymbolNamespace[] GetNamespaces();
-   byte[] GetSymAttribute(SymbolToken parent, string name);
-   ISymbolVariable[] GetVariables(SymbolToken parent);
  }
- public interface ISymbolScope {
-   int EndOffset { get; }
-   ISymbolMethod Method { get; }
-   ISymbolScope Parent { get; }
-   int StartOffset { get; }
-   ISymbolScope[] GetChildren();
-   ISymbolVariable[] GetLocals();
-   ISymbolNamespace[] GetNamespaces();
  }
- public interface ISymbolVariable {
-   int AddressField1 { get; }
-   int AddressField2 { get; }
-   int AddressField3 { get; }
-   SymAddressKind AddressKind { get; }
-   object Attributes { get; }
-   int EndOffset { get; }
-   string Name { get; }
-   int StartOffset { get; }
-   byte[] GetSignature();
  }
- public interface ISymbolWriter {
-   void Close();
-   void CloseMethod();
-   void CloseNamespace();
-   void CloseScope(int endOffset);
-   ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
-   void DefineField(SymbolToken parent, string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
-   void DefineGlobalVariable(string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
-   void DefineLocalVariable(string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
-   void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
-   void DefineSequencePoints(ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);
-   void Initialize(IntPtr emitter, string filename, bool fFullBuild);
-   void OpenMethod(SymbolToken method);
-   void OpenNamespace(string name);
-   int OpenScope(int startOffset);
-   void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
-   void SetScopeRange(int scopeID, int startOffset, int endOffset);
-   void SetSymAttribute(SymbolToken parent, string name, byte[] data);
-   void SetUnderlyingWriter(IntPtr underlyingWriter);
-   void SetUserEntryPoint(SymbolToken entryMethod);
-   void UsingNamespace(string fullName);
  }
- public enum SymAddressKind {
-   BitField = 9,
-   ILOffset = 1,
-   NativeOffset = 5,
-   NativeRegister = 3,
-   NativeRegisterRegister = 6,
-   NativeRegisterRelative = 4,
-   NativeRegisterStack = 7,
-   NativeRVA = 2,
-   NativeSectionOffset = 10,
-   NativeStackRegister = 8,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SymbolToken {
-   public SymbolToken(int val);
-   public bool Equals(SymbolToken obj);
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public int GetToken();
-   public static bool operator ==(SymbolToken a, SymbolToken b);
-   public static bool operator !=(SymbolToken a, SymbolToken b);
  }
- public class SymDocumentType {
-   public static readonly Guid Text;
-   public SymDocumentType();
  }
- public class SymLanguageType {
-   public static readonly Guid Basic;
-   public static readonly Guid C;
-   public static readonly Guid Cobol;
-   public static readonly Guid CPlusPlus;
-   public static readonly Guid CSharp;
-   public static readonly Guid ILAssembly;
-   public static readonly Guid Java;
-   public static readonly Guid JScript;
-   public static readonly Guid MCPlusPlus;
-   public static readonly Guid Pascal;
-   public static readonly Guid SMC;
-   public SymLanguageType();
  }
- public class SymLanguageVendor {
-   public static readonly Guid Microsoft;
-   public SymLanguageVendor();
  }
 }
-namespace System.Diagnostics.Tracing {
- public enum EventActivityOptions {
-   Detachable = 8,
-   Disable = 2,
-   None = 0,
-   Recursive = 4,
  }
- public sealed class EventAttribute : Attribute {
-   public EventAttribute(int eventId);
-   public EventActivityOptions ActivityOptions { get; set; }
-   public EventChannel Channel { get; set; }
-   public int EventId { get; }
-   public EventKeywords Keywords { get; set; }
-   public EventLevel Level { get; set; }
-   public string Message { get; set; }
-   public EventOpcode Opcode { get; set; }
-   public EventTags Tags { get; set; }
-   public EventTask Task { get; set; }
-   public byte Version { get; set; }
  }
- public enum EventChannel : byte {
-   Admin = (byte)16,
-   Analytic = (byte)18,
-   Debug = (byte)19,
-   None = (byte)0,
-   Operational = (byte)17,
  }
- public enum EventCommand {
-   Disable = -3,
-   Enable = -2,
-   SendManifest = -1,
-   Update = 0,
  }
- public class EventCommandEventArgs : EventArgs {
-   public IDictionary<string, string> Arguments { get; }
-   public EventCommand Command { get; }
-   public bool DisableEvent(int eventId);
-   public bool EnableEvent(int eventId);
  }
- public class EventDataAttribute : Attribute {
-   public EventDataAttribute();
-   public string Name { get; set; }
  }
- public class EventFieldAttribute : Attribute {
-   public EventFieldAttribute();
-   public EventFieldFormat Format { get; set; }
-   public EventFieldTags Tags { get; set; }
  }
- public enum EventFieldFormat {
-   Boolean = 3,
-   Default = 0,
-   Hexadecimal = 4,
-   HResult = 15,
-   Json = 12,
-   String = 2,
-   Xml = 11,
  }
- public enum EventFieldTags {
-   None = 0,
  }
- public class EventIgnoreAttribute : Attribute {
-   public EventIgnoreAttribute();
  }
- public enum EventKeywords : long {
-   All = (long)-1,
-   AuditFailure = (long)4503599627370496,
-   AuditSuccess = (long)9007199254740992,
-   CorrelationHint = (long)4503599627370496,
-   EventLogClassic = (long)36028797018963968,
-   MicrosoftTelemetry = (long)562949953421312,
-   None = (long)0,
-   Sqm = (long)2251799813685248,
-   WdiContext = (long)562949953421312,
-   WdiDiagnostic = (long)1125899906842624,
  }
- public enum EventLevel {
-   Critical = 1,
-   Error = 2,
-   Informational = 4,
-   LogAlways = 0,
-   Verbose = 5,
-   Warning = 3,
  }
- public class EventListener : IDisposable {
-   public EventListener();
-   public event EventHandler<EventSourceCreatedEventArgs> EventSourceCreated;
-   public event EventHandler<EventWrittenEventArgs> EventWritten;
-   public void DisableEvents(EventSource eventSource);
-   public virtual void Dispose();
-   public void EnableEvents(EventSource eventSource, EventLevel level);
-   public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
-   public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary<string, string> arguments);
-   protected static int EventSourceIndex(EventSource eventSource);
-   protected internal virtual void OnEventSourceCreated(EventSource eventSource);
-   protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
  }
- public enum EventManifestOptions {
-   AllCultures = 2,
-   AllowEventSourceOverride = 8,
-   None = 0,
-   OnlyIfNeededForRegistration = 4,
-   Strict = 1,
  }
- public enum EventOpcode {
-   DataCollectionStart = 3,
-   DataCollectionStop = 4,
-   Extension = 5,
-   Info = 0,
-   Receive = 240,
-   Reply = 6,
-   Resume = 7,
-   Send = 9,
-   Start = 1,
-   Stop = 2,
-   Suspend = 8,
  }
- public class EventSource : IDisposable {
-   protected EventSource();
-   protected EventSource(bool throwOnEventWriteErrors);
-   protected EventSource(EventSourceSettings settings);
-   protected EventSource(EventSourceSettings settings, params string[] traits);
-   public EventSource(string eventSourceName);
-   public EventSource(string eventSourceName, EventSourceSettings config);
-   public EventSource(string eventSourceName, EventSourceSettings config, params string[] traits);
-   public Exception ConstructionException { get; }
-   public static Guid CurrentThreadActivityId { get; }
-   public Guid Guid { get; }
-   public string Name { get; }
-   public EventSourceSettings Settings { get; }
-   public event EventHandler<EventCommandEventArgs> EventCommandExecuted;
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~EventSource();
-   public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
-   public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
-   public static Guid GetGuid(Type eventSourceType);
-   public static string GetName(Type eventSourceType);
-   public static IEnumerable<EventSource> GetSources();
-   public string GetTrait(string key);
-   public bool IsEnabled();
-   public bool IsEnabled(EventLevel level, EventKeywords keywords);
-   public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
-   protected virtual void OnEventCommand(EventCommandEventArgs command);
-   public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary<string, string> commandArguments);
-   public static void SetCurrentThreadActivityId(Guid activityId);
-   public static void SetCurrentThreadActivityId(Guid activityId, out Guid oldActivityThatWillContinue);
-   public override string ToString();
-   public void Write(string eventName);
-   public void Write(string eventName, EventSourceOptions options);
-   public void Write<T>(string eventName, ref EventSourceOptions options, ref Guid activityId, ref Guid relatedActivityId, ref T data);
-   public void Write<T>(string eventName, ref EventSourceOptions options, ref T data);
-   public void Write<T>(string eventName, T data);
-   protected void WriteEvent(int eventId);
-   protected void WriteEvent(int eventId, byte[] arg1);
-   protected void WriteEvent(int eventId, int arg1);
-   protected void WriteEvent(int eventId, int arg1, int arg2);
-   protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
-   protected void WriteEvent(int eventId, int arg1, string arg2);
-   protected void WriteEvent(int eventId, long arg1);
-   protected void WriteEvent(int eventId, long arg1, byte[] arg2);
-   protected void WriteEvent(int eventId, long arg1, long arg2);
-   protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
-   protected void WriteEvent(int eventId, long arg1, string arg2);
-   protected void WriteEvent(int eventId, params object[] args);
-   protected void WriteEvent(int eventId, string arg1);
-   protected void WriteEvent(int eventId, string arg1, int arg2);
-   protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
-   protected void WriteEvent(int eventId, string arg1, long arg2);
-   protected void WriteEvent(int eventId, string arg1, string arg2);
-   protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
-   protected unsafe void WriteEventCore(int eventId, int eventDataCount, EventSource.EventData* data);
-   protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, params object[] args);
-   protected unsafe void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventSource.EventData* data);
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    protected internal struct EventData {
-     public IntPtr DataPointer { get; set; }
-     public int Size { get; set; }
    }
  }
- public sealed class EventSourceAttribute : Attribute {
-   public EventSourceAttribute();
-   public string Guid { get; set; }
-   public string LocalizationResources { get; set; }
-   public string Name { get; set; }
  }
- public class EventSourceCreatedEventArgs : EventArgs {
-   public EventSourceCreatedEventArgs();
-   public EventSource EventSource { get; }
  }
- public class EventSourceException : Exception {
-   public EventSourceException();
-   protected EventSourceException(SerializationInfo info, StreamingContext context);
-   public EventSourceException(string message);
-   public EventSourceException(string message, Exception innerException);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct EventSourceOptions {
-   public EventActivityOptions ActivityOptions { get; set; }
-   public EventKeywords Keywords { get; set; }
-   public EventLevel Level { get; set; }
-   public EventOpcode Opcode { get; set; }
-   public EventTags Tags { get; set; }
  }
- public enum EventSourceSettings {
-   Default = 0,
-   EtwManifestEventFormat = 4,
-   EtwSelfDescribingEventFormat = 8,
-   ThrowOnEventWriteErrors = 1,
  }
- public enum EventTags {
-   None = 0,
  }
- public enum EventTask {
-   None = 0,
  }
- public class EventWrittenEventArgs : EventArgs {
-   public Guid ActivityId { get; }
-   public EventChannel Channel { get; }
-   public int EventId { get; }
-   public string EventName { get; }
-   public EventSource EventSource { get; }
-   public EventKeywords Keywords { get; }
-   public EventLevel Level { get; }
-   public string Message { get; }
-   public EventOpcode Opcode { get; }
-   public ReadOnlyCollection<object> Payload { get; }
-   public ReadOnlyCollection<string> PayloadNames { get; }
-   public Guid RelatedActivityId { get; }
-   public EventTags Tags { get; }
-   public EventTask Task { get; }
-   public byte Version { get; }
  }
- public sealed class NonEventAttribute : Attribute {
-   public NonEventAttribute();
  }
 }
 namespace System.Globalization {
- public abstract class Calendar : ICloneable {
-   public const int CurrentEra = 0;
-   protected Calendar();
-   public virtual CalendarAlgorithmType AlgorithmType { get; }
-   protected virtual int DaysInYearBeforeMinSupportedYear { get; }
-   public abstract int[] Eras { get; }
-   public bool IsReadOnly { get; }
-   public virtual DateTime MaxSupportedDateTime { get; }
-   public virtual DateTime MinSupportedDateTime { get; }
-   public virtual int TwoDigitYearMax { get; set; }
-   public virtual DateTime AddDays(DateTime time, int days);
-   public virtual DateTime AddHours(DateTime time, int hours);
-   public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
-   public virtual DateTime AddMinutes(DateTime time, int minutes);
-   public abstract DateTime AddMonths(DateTime time, int months);
-   public virtual DateTime AddSeconds(DateTime time, int seconds);
-   public virtual DateTime AddWeeks(DateTime time, int weeks);
-   public abstract DateTime AddYears(DateTime time, int years);
-   public virtual object Clone();
-   public abstract int GetDayOfMonth(DateTime time);
-   public abstract DayOfWeek GetDayOfWeek(DateTime time);
-   public abstract int GetDayOfYear(DateTime time);
-   public virtual int GetDaysInMonth(int year, int month);
-   public abstract int GetDaysInMonth(int year, int month, int era);
-   public virtual int GetDaysInYear(int year);
-   public abstract int GetDaysInYear(int year, int era);
-   public abstract int GetEra(DateTime time);
-   public virtual int GetHour(DateTime time);
-   public virtual int GetLeapMonth(int year);
-   public virtual int GetLeapMonth(int year, int era);
-   public virtual double GetMilliseconds(DateTime time);
-   public virtual int GetMinute(DateTime time);
-   public abstract int GetMonth(DateTime time);
-   public virtual int GetMonthsInYear(int year);
-   public abstract int GetMonthsInYear(int year, int era);
-   public virtual int GetSecond(DateTime time);
-   public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
-   public abstract int GetYear(DateTime time);
-   public virtual bool IsLeapDay(int year, int month, int day);
-   public abstract bool IsLeapDay(int year, int month, int day, int era);
-   public virtual bool IsLeapMonth(int year, int month);
-   public abstract bool IsLeapMonth(int year, int month, int era);
-   public virtual bool IsLeapYear(int year);
-   public abstract bool IsLeapYear(int year, int era);
-   public static Calendar ReadOnly(Calendar calendar);
-   public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
-   public abstract DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public virtual int ToFourDigitYear(int year);
  }
- public enum CalendarAlgorithmType {
-   LunarCalendar = 2,
-   LunisolarCalendar = 3,
-   SolarCalendar = 1,
-   Unknown = 0,
  }
- public enum CalendarWeekRule {
-   FirstDay = 0,
-   FirstFourDayWeek = 2,
-   FirstFullWeek = 1,
  }
- public static class CharUnicodeInfo {
-   public static int GetDecimalDigitValue(char ch);
-   public static int GetDecimalDigitValue(string s, int index);
-   public static int GetDigitValue(char ch);
-   public static int GetDigitValue(string s, int index);
-   public static double GetNumericValue(char ch);
-   public static double GetNumericValue(string s, int index);
-   public static UnicodeCategory GetUnicodeCategory(char ch);
-   public static UnicodeCategory GetUnicodeCategory(string s, int index);
  }
- public class ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
-   public const int ChineseEra = 1;
-   public ChineseLunisolarCalendar();
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int GetEra(DateTime time);
  }
- public class CompareInfo : IDeserializationCallback {
-   public int LCID { get; }
-   public virtual string Name { get; }
-   public SortVersion Version { get; }
-   public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
-   public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
-   public virtual int Compare(string string1, int offset1, string string2, int offset2);
-   public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
-   public virtual int Compare(string string1, string string2);
-   public virtual int Compare(string string1, string string2, CompareOptions options);
-   public override bool Equals(object value);
-   public static CompareInfo GetCompareInfo(int culture);
-   public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
-   public static CompareInfo GetCompareInfo(string name);
-   public static CompareInfo GetCompareInfo(string name, Assembly assembly);
-   public override int GetHashCode();
-   public virtual int GetHashCode(string source, CompareOptions options);
-   public virtual SortKey GetSortKey(string source);
-   public virtual SortKey GetSortKey(string source, CompareOptions options);
-   public virtual int IndexOf(string source, char value);
-   public virtual int IndexOf(string source, char value, CompareOptions options);
-   public virtual int IndexOf(string source, char value, int startIndex);
-   public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
-   public virtual int IndexOf(string source, char value, int startIndex, int count);
-   public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
-   public virtual int IndexOf(string source, string value);
-   public virtual int IndexOf(string source, string value, CompareOptions options);
-   public virtual int IndexOf(string source, string value, int startIndex);
-   public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
-   public virtual int IndexOf(string source, string value, int startIndex, int count);
-   public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
-   public virtual bool IsPrefix(string source, string prefix);
-   public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
-   public static bool IsSortable(char ch);
-   public static bool IsSortable(string text);
-   public virtual bool IsSuffix(string source, string suffix);
-   public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
-   public virtual int LastIndexOf(string source, char value);
-   public virtual int LastIndexOf(string source, char value, CompareOptions options);
-   public virtual int LastIndexOf(string source, char value, int startIndex);
-   public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
-   public virtual int LastIndexOf(string source, char value, int startIndex, int count);
-   public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
-   public virtual int LastIndexOf(string source, string value);
-   public virtual int LastIndexOf(string source, string value, CompareOptions options);
-   public virtual int LastIndexOf(string source, string value, int startIndex);
-   public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
-   public virtual int LastIndexOf(string source, string value, int startIndex, int count);
-   public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   public override string ToString();
  }
- public enum CompareOptions {
-   IgnoreCase = 1,
-   IgnoreKanaType = 8,
-   IgnoreNonSpace = 2,
-   IgnoreSymbols = 4,
-   IgnoreWidth = 16,
-   None = 0,
-   Ordinal = 1073741824,
-   OrdinalIgnoreCase = 268435456,
-   StringSort = 536870912,
  }
- public class CultureInfo : ICloneable, IFormatProvider {
-   public CultureInfo(int culture);
-   public CultureInfo(int culture, bool useUserOverride);
-   public CultureInfo(string name);
-   public CultureInfo(string name, bool useUserOverride);
-   public virtual Calendar Calendar { get; }
-   public virtual CompareInfo CompareInfo { get; }
-   public CultureTypes CultureTypes { get; }
-   public static CultureInfo CurrentCulture { get; set; }
-   public static CultureInfo CurrentUICulture { get; set; }
-   public virtual DateTimeFormatInfo DateTimeFormat { get; set; }
-   public static CultureInfo DefaultThreadCurrentCulture { get; set; }
-   public static CultureInfo DefaultThreadCurrentUICulture { get; set; }
-   public virtual string DisplayName { get; }
-   public virtual string EnglishName { get; }
-   public string IetfLanguageTag { get; }
-   public static CultureInfo InstalledUICulture { get; }
-   public static CultureInfo InvariantCulture { get; }
-   public virtual bool IsNeutralCulture { get; }
-   public bool IsReadOnly { get; }
-   public virtual int KeyboardLayoutId { get; }
-   public virtual int LCID { get; }
-   public virtual string Name { get; }
-   public virtual string NativeName { get; }
-   public virtual NumberFormatInfo NumberFormat { get; set; }
-   public virtual Calendar[] OptionalCalendars { get; }
-   public virtual CultureInfo Parent { get; }
-   public virtual TextInfo TextInfo { get; }
-   public virtual string ThreeLetterISOLanguageName { get; }
-   public virtual string ThreeLetterWindowsLanguageName { get; }
-   public virtual string TwoLetterISOLanguageName { get; }
-   public bool UseUserOverride { get; }
-   public void ClearCachedData();
-   public virtual object Clone();
-   public static CultureInfo CreateSpecificCulture(string name);
-   public override bool Equals(object value);
-   public CultureInfo GetConsoleFallbackUICulture();
-   public static CultureInfo GetCultureInfo(int culture);
-   public static CultureInfo GetCultureInfo(string name);
-   public static CultureInfo GetCultureInfo(string name, string altName);
-   public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
-   public static CultureInfo[] GetCultures(CultureTypes types);
-   public virtual object GetFormat(Type formatType);
-   public override int GetHashCode();
-   public static CultureInfo ReadOnly(CultureInfo ci);
-   public override string ToString();
  }
- public class CultureNotFoundException : ArgumentException, ISerializable {
-   public CultureNotFoundException();
-   protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
-   public CultureNotFoundException(string message);
-   public CultureNotFoundException(string message, Exception innerException);
-   public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
-   public CultureNotFoundException(string paramName, int invalidCultureId, string message);
-   public CultureNotFoundException(string paramName, string message);
-   public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
-   public CultureNotFoundException(string paramName, string invalidCultureName, string message);
-   public virtual Nullable<int> InvalidCultureId { get; }
-   public virtual string InvalidCultureName { get; }
-   public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public enum CultureTypes {
-   AllCultures = 7,
-   FrameworkCultures = 64,
-   InstalledWin32Cultures = 4,
-   NeutralCultures = 1,
-   ReplacementCultures = 16,
-   SpecificCultures = 2,
-   UserCustomCulture = 8,
-   WindowsOnlyCultures = 32,
  }
- public sealed class DateTimeFormatInfo : ICloneable, IFormatProvider {
-   public DateTimeFormatInfo();
-   public string[] AbbreviatedDayNames { get; set; }
-   public string[] AbbreviatedMonthGenitiveNames { get; set; }
-   public string[] AbbreviatedMonthNames { get; set; }
-   public string AMDesignator { get; set; }
-   public Calendar Calendar { get; set; }
-   public CalendarWeekRule CalendarWeekRule { get; set; }
-   public static DateTimeFormatInfo CurrentInfo { get; }
-   public string DateSeparator { get; set; }
-   public string[] DayNames { get; set; }
-   public DayOfWeek FirstDayOfWeek { get; set; }
-   public string FullDateTimePattern { get; set; }
-   public static DateTimeFormatInfo InvariantInfo { get; }
-   public bool IsReadOnly { get; }
-   public string LongDatePattern { get; set; }
-   public string LongTimePattern { get; set; }
-   public string MonthDayPattern { get; set; }
-   public string[] MonthGenitiveNames { get; set; }
-   public string[] MonthNames { get; set; }
-   public string NativeCalendarName { get; }
-   public string PMDesignator { get; set; }
-   public string RFC1123Pattern { get; }
-   public string ShortDatePattern { get; set; }
-   public string[] ShortestDayNames { get; set; }
-   public string ShortTimePattern { get; set; }
-   public string SortableDateTimePattern { get; }
-   public string TimeSeparator { get; set; }
-   public string UniversalSortableDateTimePattern { get; }
-   public string YearMonthPattern { get; set; }
-   public object Clone();
-   public string GetAbbreviatedDayName(DayOfWeek dayofweek);
-   public string GetAbbreviatedEraName(int era);
-   public string GetAbbreviatedMonthName(int month);
-   public string[] GetAllDateTimePatterns();
-   public string[] GetAllDateTimePatterns(char format);
-   public string GetDayName(DayOfWeek dayofweek);
-   public int GetEra(string eraName);
-   public string GetEraName(int era);
-   public object GetFormat(Type formatType);
-   public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
-   public string GetMonthName(int month);
-   public string GetShortestDayName(DayOfWeek dayOfWeek);
-   public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
-   public void SetAllDateTimePatterns(string[] patterns, char format);
  }
  public enum DateTimeStyles {
    AdjustToUniversal = 16,
    AllowInnerWhite = 4,
    AllowLeadingWhite = 1,
    AllowTrailingWhite = 2,
    AllowWhiteSpaces = 7,
    AssumeLocal = 32,
    AssumeUniversal = 64,
    NoCurrentDateDefault = 8,
    None = 0,
    RoundtripKind = 128,
  }
- public class DaylightTime {
-   public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
-   public TimeSpan Delta { get; }
-   public DateTime End { get; }
-   public DateTime Start { get; }
  }
- public enum DigitShapes {
-   Context = 0,
-   NativeNational = 2,
-   None = 1,
  }
- public abstract class EastAsianLunisolarCalendar : Calendar {
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public int GetCelestialStem(int sexagenaryYear);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public virtual int GetSexagenaryYear(DateTime time);
-   public int GetTerrestrialBranch(int sexagenaryYear);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class GregorianCalendar : Calendar {
-   public const int ADEra = 1;
-   public GregorianCalendar();
-   public GregorianCalendar(GregorianCalendarTypes type);
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public virtual GregorianCalendarTypes CalendarType { get; set; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public enum GregorianCalendarTypes {
-   Arabic = 10,
-   Localized = 1,
-   MiddleEastFrench = 9,
-   TransliteratedEnglish = 11,
-   TransliteratedFrench = 12,
-   USEnglish = 2,
  }
- public class HebrewCalendar : Calendar {
-   public static readonly int HebrewEra;
-   public HebrewCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class HijriCalendar : Calendar {
-   public static readonly int HijriEra;
-   public HijriCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public int HijriAdjustment { get; set; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public sealed class IdnMapping {
-   public IdnMapping();
-   public bool AllowUnassigned { get; set; }
-   public bool UseStd3AsciiRules { get; set; }
-   public override bool Equals(object obj);
-   public string GetAscii(string unicode);
-   public string GetAscii(string unicode, int index);
-   public string GetAscii(string unicode, int index, int count);
-   public override int GetHashCode();
-   public string GetUnicode(string ascii);
-   public string GetUnicode(string ascii, int index);
-   public string GetUnicode(string ascii, int index, int count);
  }
- public class JapaneseCalendar : Calendar {
-   public JapaneseCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
-   public const int JapaneseEra = 1;
-   public JapaneseLunisolarCalendar();
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int GetEra(DateTime time);
  }
- public class JulianCalendar : Calendar {
-   public static readonly int JulianEra;
-   public JulianCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class KoreanCalendar : Calendar {
-   public const int KoreanEra = 1;
-   public KoreanCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
-   public const int GregorianEra = 1;
-   public KoreanLunisolarCalendar();
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int GetEra(DateTime time);
  }
- public sealed class NumberFormatInfo : ICloneable, IFormatProvider {
-   public NumberFormatInfo();
-   public int CurrencyDecimalDigits { get; set; }
-   public string CurrencyDecimalSeparator { get; set; }
-   public string CurrencyGroupSeparator { get; set; }
-   public int[] CurrencyGroupSizes { get; set; }
-   public int CurrencyNegativePattern { get; set; }
-   public int CurrencyPositivePattern { get; set; }
-   public string CurrencySymbol { get; set; }
-   public static NumberFormatInfo CurrentInfo { get; }
-   public DigitShapes DigitSubstitution { get; set; }
-   public static NumberFormatInfo InvariantInfo { get; }
-   public bool IsReadOnly { get; }
-   public string NaNSymbol { get; set; }
-   public string[] NativeDigits { get; set; }
-   public string NegativeInfinitySymbol { get; set; }
-   public string NegativeSign { get; set; }
-   public int NumberDecimalDigits { get; set; }
-   public string NumberDecimalSeparator { get; set; }
-   public string NumberGroupSeparator { get; set; }
-   public int[] NumberGroupSizes { get; set; }
-   public int NumberNegativePattern { get; set; }
-   public int PercentDecimalDigits { get; set; }
-   public string PercentDecimalSeparator { get; set; }
-   public string PercentGroupSeparator { get; set; }
-   public int[] PercentGroupSizes { get; set; }
-   public int PercentNegativePattern { get; set; }
-   public int PercentPositivePattern { get; set; }
-   public string PercentSymbol { get; set; }
-   public string PerMilleSymbol { get; set; }
-   public string PositiveInfinitySymbol { get; set; }
-   public string PositiveSign { get; set; }
-   public object Clone();
-   public object GetFormat(Type formatType);
-   public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
-   public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
  }
  public enum NumberStyles {
    AllowCurrencySymbol = 256,
    AllowDecimalPoint = 32,
    AllowExponent = 128,
    AllowHexSpecifier = 512,
    AllowLeadingSign = 4,
    AllowLeadingWhite = 1,
    AllowParentheses = 16,
    AllowThousands = 64,
    AllowTrailingSign = 8,
    AllowTrailingWhite = 2,
    Any = 511,
    Currency = 383,
    Float = 167,
    HexNumber = 515,
    Integer = 7,
    None = 0,
    Number = 111,
  }
- public class PersianCalendar : Calendar {
-   public static readonly int PersianEra;
-   public PersianCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class RegionInfo {
-   public RegionInfo(int culture);
-   public RegionInfo(string name);
-   public virtual string CurrencyEnglishName { get; }
-   public virtual string CurrencyNativeName { get; }
-   public virtual string CurrencySymbol { get; }
-   public static RegionInfo CurrentRegion { get; }
-   public virtual string DisplayName { get; }
-   public virtual string EnglishName { get; }
-   public virtual int GeoId { get; }
-   public virtual bool IsMetric { get; }
-   public virtual string ISOCurrencySymbol { get; }
-   public virtual string Name { get; }
-   public virtual string NativeName { get; }
-   public virtual string ThreeLetterISORegionName { get; }
-   public virtual string ThreeLetterWindowsRegionName { get; }
-   public virtual string TwoLetterISORegionName { get; }
-   public override bool Equals(object value);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public class SortKey {
-   public virtual byte[] KeyData { get; }
-   public virtual string OriginalString { get; }
-   public static int Compare(SortKey sortkey1, SortKey sortkey2);
-   public override bool Equals(object value);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class SortVersion : IEquatable<SortVersion> {
-   public SortVersion(int fullVersion, Guid sortId);
-   public int FullVersion { get; }
-   public Guid SortId { get; }
-   public bool Equals(SortVersion other);
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public static bool operator ==(SortVersion left, SortVersion right);
-   public static bool operator !=(SortVersion left, SortVersion right);
  }
- public class StringInfo {
-   public StringInfo();
-   public StringInfo(string value);
-   public int LengthInTextElements { get; }
-   public string String { get; set; }
-   public override bool Equals(object value);
-   public override int GetHashCode();
-   public static string GetNextTextElement(string str);
-   public static string GetNextTextElement(string str, int index);
-   public static TextElementEnumerator GetTextElementEnumerator(string str);
-   public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
-   public static int[] ParseCombiningCharacters(string str);
-   public string SubstringByTextElements(int startingTextElement);
-   public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
  }
- public class TaiwanCalendar : Calendar {
-   public TaiwanCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public class TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
-   public TaiwanLunisolarCalendar();
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int GetEra(DateTime time);
  }
- public class TextElementEnumerator : IEnumerator {
-   public object Current { get; }
-   public int ElementIndex { get; }
-   public string GetTextElement();
-   public bool MoveNext();
-   public void Reset();
  }
- public class TextInfo : ICloneable, IDeserializationCallback {
-   public virtual int ANSICodePage { get; }
-   public string CultureName { get; }
-   public virtual int EBCDICCodePage { get; }
-   public bool IsReadOnly { get; }
-   public bool IsRightToLeft { get; }
-   public int LCID { get; }
-   public virtual string ListSeparator { get; set; }
-   public virtual int MacCodePage { get; }
-   public virtual int OEMCodePage { get; }
-   public virtual object Clone();
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public static TextInfo ReadOnly(TextInfo textInfo);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   public virtual char ToLower(char c);
-   public virtual string ToLower(string str);
-   public override string ToString();
-   public string ToTitleCase(string str);
-   public virtual char ToUpper(char c);
-   public virtual string ToUpper(string str);
  }
- public class ThaiBuddhistCalendar : Calendar {
-   public const int ThaiBuddhistEra = 1;
-   public ThaiBuddhistCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
  public enum TimeSpanStyles {
    AssumeNegative = 1,
    None = 0,
  }
- public class UmAlQuraCalendar : Calendar {
-   public const int UmAlQuraEra = 1;
-   public UmAlQuraCalendar();
-   public override CalendarAlgorithmType AlgorithmType { get; }
-   protected override int DaysInYearBeforeMinSupportedYear { get; }
-   public override int[] Eras { get; }
-   public override DateTime MaxSupportedDateTime { get; }
-   public override DateTime MinSupportedDateTime { get; }
-   public override int TwoDigitYearMax { get; set; }
-   public override DateTime AddMonths(DateTime time, int months);
-   public override DateTime AddYears(DateTime time, int years);
-   public override int GetDayOfMonth(DateTime time);
-   public override DayOfWeek GetDayOfWeek(DateTime time);
-   public override int GetDayOfYear(DateTime time);
-   public override int GetDaysInMonth(int year, int month, int era);
-   public override int GetDaysInYear(int year, int era);
-   public override int GetEra(DateTime time);
-   public override int GetLeapMonth(int year, int era);
-   public override int GetMonth(DateTime time);
-   public override int GetMonthsInYear(int year, int era);
-   public override int GetYear(DateTime time);
-   public override bool IsLeapDay(int year, int month, int day, int era);
-   public override bool IsLeapMonth(int year, int month, int era);
-   public override bool IsLeapYear(int year, int era);
-   public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
-   public override int ToFourDigitYear(int year);
  }
- public enum UnicodeCategory {
-   ClosePunctuation = 21,
-   ConnectorPunctuation = 18,
-   Control = 14,
-   CurrencySymbol = 26,
-   DashPunctuation = 19,
-   DecimalDigitNumber = 8,
-   EnclosingMark = 7,
-   FinalQuotePunctuation = 23,
-   Format = 15,
-   InitialQuotePunctuation = 22,
-   LetterNumber = 9,
-   LineSeparator = 12,
-   LowercaseLetter = 1,
-   MathSymbol = 25,
-   ModifierLetter = 3,
-   ModifierSymbol = 27,
-   NonSpacingMark = 5,
-   OpenPunctuation = 20,
-   OtherLetter = 4,
-   OtherNotAssigned = 29,
-   OtherNumber = 10,
-   OtherPunctuation = 24,
-   OtherSymbol = 28,
-   ParagraphSeparator = 13,
-   PrivateUse = 17,
-   SpaceSeparator = 11,
-   SpacingCombiningMark = 6,
-   Surrogate = 16,
-   TitlecaseLetter = 2,
-   UppercaseLetter = 0,
  }
 }
 namespace System.IO {
- public class BinaryReader : IDisposable {
-   public BinaryReader(Stream input);
-   public BinaryReader(Stream input, Encoding encoding);
-   public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
-   public virtual Stream BaseStream { get; }
-   public virtual void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   protected virtual void FillBuffer(int numBytes);
-   public virtual int PeekChar();
-   public virtual int Read();
-   public virtual int Read(byte[] buffer, int index, int count);
-   public virtual int Read(char[] buffer, int index, int count);
-   protected internal int Read7BitEncodedInt();
-   public virtual bool ReadBoolean();
-   public virtual byte ReadByte();
-   public virtual byte[] ReadBytes(int count);
-   public virtual char ReadChar();
-   public virtual char[] ReadChars(int count);
-   public virtual decimal ReadDecimal();
-   public virtual double ReadDouble();
-   public virtual short ReadInt16();
-   public virtual int ReadInt32();
-   public virtual long ReadInt64();
-   public virtual sbyte ReadSByte();
-   public virtual float ReadSingle();
-   public virtual string ReadString();
-   public virtual ushort ReadUInt16();
-   public virtual uint ReadUInt32();
-   public virtual ulong ReadUInt64();
  }
- public class BinaryWriter : IDisposable {
-   public static readonly BinaryWriter Null;
-   protected Stream OutStream;
-   protected BinaryWriter();
-   public BinaryWriter(Stream output);
-   public BinaryWriter(Stream output, Encoding encoding);
-   public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
-   public virtual Stream BaseStream { get; }
-   public virtual void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual void Flush();
-   public virtual long Seek(int offset, SeekOrigin origin);
-   public virtual void Write(bool value);
-   public virtual void Write(byte value);
-   public virtual void Write(byte[] buffer);
-   public virtual void Write(byte[] buffer, int index, int count);
-   public virtual void Write(char ch);
-   public virtual void Write(char[] chars);
-   public virtual void Write(char[] chars, int index, int count);
-   public virtual void Write(decimal value);
-   public virtual void Write(double value);
-   public virtual void Write(short value);
-   public virtual void Write(int value);
-   public virtual void Write(long value);
-   public virtual void Write(sbyte value);
-   public virtual void Write(float value);
-   public virtual void Write(string value);
-   public virtual void Write(ushort value);
-   public virtual void Write(uint value);
-   public virtual void Write(ulong value);
-   protected void Write7BitEncodedInt(int value);
  }
- public sealed class BufferedStream : Stream {
-   public BufferedStream(Stream stream);
-   public BufferedStream(Stream stream, int bufferSize);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public override long Length { get; }
-   public override long Position { get; set; }
-   public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
-   public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
-   protected override void Dispose(bool disposing);
-   public override int EndRead(IAsyncResult asyncResult);
-   public override void EndWrite(IAsyncResult asyncResult);
-   public override void Flush();
-   public override Task FlushAsync(CancellationToken cancellationToken);
-   public override int Read(byte[] array, int offset, int count);
-   public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override int ReadByte();
-   public override long Seek(long offset, SeekOrigin origin);
-   public override void SetLength(long value);
-   public override void Write(byte[] array, int offset, int count);
-   public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override void WriteByte(byte value);
  }
- public static class Directory {
-   public static DirectoryInfo CreateDirectory(string path);
-   public static DirectoryInfo CreateDirectory(string path, DirectorySecurity directorySecurity);
-   public static void Delete(string path);
-   public static void Delete(string path, bool recursive);
-   public static IEnumerable<string> EnumerateDirectories(string path);
-   public static IEnumerable<string> EnumerateDirectories(string path, string searchPattern);
-   public static IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
-   public static IEnumerable<string> EnumerateFiles(string path);
-   public static IEnumerable<string> EnumerateFiles(string path, string searchPattern);
-   public static IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
-   public static IEnumerable<string> EnumerateFileSystemEntries(string path);
-   public static IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern);
-   public static IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
-   public static bool Exists(string path);
-   public static DirectorySecurity GetAccessControl(string path);
-   public static DirectorySecurity GetAccessControl(string path, AccessControlSections includeSections);
-   public static DateTime GetCreationTime(string path);
-   public static DateTime GetCreationTimeUtc(string path);
-   public static string GetCurrentDirectory();
-   public static string[] GetDirectories(string path);
-   public static string[] GetDirectories(string path, string searchPattern);
-   public static string[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
-   public static string GetDirectoryRoot(string path);
-   public static string[] GetFiles(string path);
-   public static string[] GetFiles(string path, string searchPattern);
-   public static string[] GetFiles(string path, string searchPattern, SearchOption searchOption);
-   public static string[] GetFileSystemEntries(string path);
-   public static string[] GetFileSystemEntries(string path, string searchPattern);
-   public static string[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
-   public static DateTime GetLastAccessTime(string path);
-   public static DateTime GetLastAccessTimeUtc(string path);
-   public static DateTime GetLastWriteTime(string path);
-   public static DateTime GetLastWriteTimeUtc(string path);
-   public static string[] GetLogicalDrives();
-   public static DirectoryInfo GetParent(string path);
-   public static void Move(string sourceDirName, string destDirName);
-   public static void SetAccessControl(string path, DirectorySecurity directorySecurity);
-   public static void SetCreationTime(string path, DateTime creationTime);
-   public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
-   public static void SetCurrentDirectory(string path);
-   public static void SetLastAccessTime(string path, DateTime lastAccessTime);
-   public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
-   public static void SetLastWriteTime(string path, DateTime lastWriteTime);
-   public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
  }
- public sealed class DirectoryInfo : FileSystemInfo {
-   public DirectoryInfo(string path);
-   public override bool Exists { get; }
-   public override string Name { get; }
-   public DirectoryInfo Parent { get; }
-   public DirectoryInfo Root { get; }
-   public void Create();
-   public void Create(DirectorySecurity directorySecurity);
-   public DirectoryInfo CreateSubdirectory(string path);
-   public DirectoryInfo CreateSubdirectory(string path, DirectorySecurity directorySecurity);
-   public override void Delete();
-   public void Delete(bool recursive);
-   public IEnumerable<DirectoryInfo> EnumerateDirectories();
-   public IEnumerable<DirectoryInfo> EnumerateDirectories(string searchPattern);
-   public IEnumerable<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
-   public IEnumerable<FileInfo> EnumerateFiles();
-   public IEnumerable<FileInfo> EnumerateFiles(string searchPattern);
-   public IEnumerable<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
-   public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos();
-   public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
-   public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
-   public DirectorySecurity GetAccessControl();
-   public DirectorySecurity GetAccessControl(AccessControlSections includeSections);
-   public DirectoryInfo[] GetDirectories();
-   public DirectoryInfo[] GetDirectories(string searchPattern);
-   public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
-   public FileInfo[] GetFiles();
-   public FileInfo[] GetFiles(string searchPattern);
-   public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
-   public FileSystemInfo[] GetFileSystemInfos();
-   public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
-   public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
-   public void MoveTo(string destDirName);
-   public void SetAccessControl(DirectorySecurity directorySecurity);
-   public override string ToString();
  }
  public class DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException();
-   protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
  }
- public sealed class DriveInfo : ISerializable {
-   public DriveInfo(string driveName);
-   public long AvailableFreeSpace { get; }
-   public string DriveFormat { get; }
-   public DriveType DriveType { get; }
-   public bool IsReady { get; }
-   public string Name { get; }
-   public DirectoryInfo RootDirectory { get; }
-   public long TotalFreeSpace { get; }
-   public long TotalSize { get; }
-   public string VolumeLabel { get; set; }
-   public static DriveInfo[] GetDrives();
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
  }
- public class DriveNotFoundException : IOException {
-   public DriveNotFoundException();
-   protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
-   public DriveNotFoundException(string message);
-   public DriveNotFoundException(string message, Exception innerException);
  }
- public enum DriveType {
-   CDRom = 5,
-   Fixed = 3,
-   Network = 4,
-   NoRootDirectory = 1,
-   Ram = 6,
-   Removable = 2,
-   Unknown = 0,
  }
- public class EndOfStreamException : IOException {
-   public EndOfStreamException();
-   protected EndOfStreamException(SerializationInfo info, StreamingContext context);
-   public EndOfStreamException(string message);
-   public EndOfStreamException(string message, Exception innerException);
  }
- public static class File {
-   public static void AppendAllLines(string path, IEnumerable<string> contents);
-   public static void AppendAllLines(string path, IEnumerable<string> contents, Encoding encoding);
-   public static void AppendAllText(string path, string contents);
-   public static void AppendAllText(string path, string contents, Encoding encoding);
-   public static StreamWriter AppendText(string path);
-   public static void Copy(string sourceFileName, string destFileName);
-   public static void Copy(string sourceFileName, string destFileName, bool overwrite);
-   public static FileStream Create(string path);
-   public static FileStream Create(string path, int bufferSize);
-   public static FileStream Create(string path, int bufferSize, FileOptions options);
-   public static FileStream Create(string path, int bufferSize, FileOptions options, FileSecurity fileSecurity);
-   public static StreamWriter CreateText(string path);
-   public static void Decrypt(string path);
-   public static void Delete(string path);
-   public static void Encrypt(string path);
-   public static bool Exists(string path);
-   public static FileSecurity GetAccessControl(string path);
-   public static FileSecurity GetAccessControl(string path, AccessControlSections includeSections);
-   public static FileAttributes GetAttributes(string path);
-   public static DateTime GetCreationTime(string path);
-   public static DateTime GetCreationTimeUtc(string path);
-   public static DateTime GetLastAccessTime(string path);
-   public static DateTime GetLastAccessTimeUtc(string path);
-   public static DateTime GetLastWriteTime(string path);
-   public static DateTime GetLastWriteTimeUtc(string path);
-   public static void Move(string sourceFileName, string destFileName);
-   public static FileStream Open(string path, FileMode mode);
-   public static FileStream Open(string path, FileMode mode, FileAccess access);
-   public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
-   public static FileStream OpenRead(string path);
-   public static StreamReader OpenText(string path);
-   public static FileStream OpenWrite(string path);
-   public static byte[] ReadAllBytes(string path);
-   public static string[] ReadAllLines(string path);
-   public static string[] ReadAllLines(string path, Encoding encoding);
-   public static string ReadAllText(string path);
-   public static string ReadAllText(string path, Encoding encoding);
-   public static IEnumerable<string> ReadLines(string path);
-   public static IEnumerable<string> ReadLines(string path, Encoding encoding);
-   public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
-   public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
-   public static void SetAccessControl(string path, FileSecurity fileSecurity);
-   public static void SetAttributes(string path, FileAttributes fileAttributes);
-   public static void SetCreationTime(string path, DateTime creationTime);
-   public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
-   public static void SetLastAccessTime(string path, DateTime lastAccessTime);
-   public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
-   public static void SetLastWriteTime(string path, DateTime lastWriteTime);
-   public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
-   public static void WriteAllBytes(string path, byte[] bytes);
-   public static void WriteAllLines(string path, IEnumerable<string> contents);
-   public static void WriteAllLines(string path, IEnumerable<string> contents, Encoding encoding);
-   public static void WriteAllLines(string path, string[] contents);
-   public static void WriteAllLines(string path, string[] contents, Encoding encoding);
-   public static void WriteAllText(string path, string contents);
-   public static void WriteAllText(string path, string contents, Encoding encoding);
  }
- public enum FileAccess {
-   Read = 1,
-   ReadWrite = 3,
-   Write = 2,
  }
- public enum FileAttributes {
-   Archive = 32,
-   Compressed = 2048,
-   Device = 64,
-   Directory = 16,
-   Encrypted = 16384,
-   Hidden = 2,
-   IntegrityStream = 32768,
-   Normal = 128,
-   NoScrubData = 131072,
-   NotContentIndexed = 8192,
-   Offline = 4096,
-   ReadOnly = 1,
-   ReparsePoint = 1024,
-   SparseFile = 512,
-   System = 4,
-   Temporary = 256,
  }
- public sealed class FileInfo : FileSystemInfo {
-   public FileInfo(string fileName);
-   public DirectoryInfo Directory { get; }
-   public string DirectoryName { get; }
-   public override bool Exists { get; }
-   public bool IsReadOnly { get; set; }
-   public long Length { get; }
-   public override string Name { get; }
-   public StreamWriter AppendText();
-   public FileInfo CopyTo(string destFileName);
-   public FileInfo CopyTo(string destFileName, bool overwrite);
-   public FileStream Create();
-   public StreamWriter CreateText();
-   public void Decrypt();
-   public override void Delete();
-   public void Encrypt();
-   public FileSecurity GetAccessControl();
-   public FileSecurity GetAccessControl(AccessControlSections includeSections);
-   public void MoveTo(string destFileName);
-   public FileStream Open(FileMode mode);
-   public FileStream Open(FileMode mode, FileAccess access);
-   public FileStream Open(FileMode mode, FileAccess access, FileShare share);
-   public FileStream OpenRead();
-   public StreamReader OpenText();
-   public FileStream OpenWrite();
-   public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
-   public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
-   public void SetAccessControl(FileSecurity fileSecurity);
-   public override string ToString();
  }
  public class FileLoadException : IOException {
    public FileLoadException();
-   protected FileLoadException(SerializationInfo info, StreamingContext context);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    public string FileName { get; }
-   public string FusionLog { get; }
    public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
    public override string ToString();
  }
- public enum FileMode {
-   Append = 6,
-   Create = 2,
-   CreateNew = 1,
-   Open = 3,
-   OpenOrCreate = 4,
-   Truncate = 5,
  }
  public class FileNotFoundException : IOException {
    public FileNotFoundException();
-   protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    public string FileName { get; }
-   public string FusionLog { get; }
    public override string Message { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
    public override string ToString();
  }
- public enum FileOptions {
-   Asynchronous = 1073741824,
-   DeleteOnClose = 67108864,
-   Encrypted = 16384,
-   None = 0,
-   RandomAccess = 268435456,
-   SequentialScan = 134217728,
-   WriteThrough = -2147483648,
  }
- public enum FileShare {
-   Delete = 4,
-   Inheritable = 16,
-   None = 0,
-   Read = 1,
-   ReadWrite = 3,
-   Write = 2,
  }
- public class FileStream : Stream {
-   public FileStream(SafeFileHandle handle, FileAccess access);
-   public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
-   public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
-   public FileStream(IntPtr handle, FileAccess access);
-   public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
-   public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
-   public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
-   public FileStream(string path, FileMode mode);
-   public FileStream(string path, FileMode mode, FileAccess access);
-   public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
-   public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
-   public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
-   public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
-   public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options);
-   public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public virtual IntPtr Handle { get; }
-   public virtual bool IsAsync { get; }
-   public override long Length { get; }
-   public string Name { get; }
-   public override long Position { get; set; }
-   public virtual SafeFileHandle SafeFileHandle { get; }
-   public override IAsyncResult BeginRead(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
-   public override IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
-   protected override void Dispose(bool disposing);
-   public override int EndRead(IAsyncResult asyncResult);
-   public override void EndWrite(IAsyncResult asyncResult);
-   ~FileStream();
-   public override void Flush();
-   public virtual void Flush(bool flushToDisk);
-   public override Task FlushAsync(CancellationToken cancellationToken);
-   public FileSecurity GetAccessControl();
-   public virtual void Lock(long position, long length);
-   public override int Read(byte[] array, int offset, int count);
-   public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override int ReadByte();
-   public override long Seek(long offset, SeekOrigin origin);
-   public void SetAccessControl(FileSecurity fileSecurity);
-   public override void SetLength(long value);
-   public virtual void Unlock(long position, long length);
-   public override void Write(byte[] array, int offset, int count);
-   public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override void WriteByte(byte value);
  }
- public abstract class FileSystemInfo : MarshalByRefObject, ISerializable {
-   protected string FullPath;
-   protected string OriginalPath;
-   protected FileSystemInfo();
-   protected FileSystemInfo(SerializationInfo info, StreamingContext context);
-   public FileAttributes Attributes { get; set; }
-   public DateTime CreationTime { get; set; }
-   public DateTime CreationTimeUtc { get; set; }
-   public abstract bool Exists { get; }
-   public string Extension { get; }
-   public virtual string FullName { get; }
-   public DateTime LastAccessTime { get; set; }
-   public DateTime LastAccessTimeUtc { get; set; }
-   public DateTime LastWriteTime { get; set; }
-   public DateTime LastWriteTimeUtc { get; set; }
-   public abstract string Name { get; }
-   public abstract void Delete();
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public void Refresh();
  }
  public class IOException : SystemExceptionException {
    public IOException();
-   protected IOException(SerializationInfo info, StreamingContext context);
    public IOException(string message);
    public IOException(string message, Exception innerException);
    public IOException(string message, int hresult);
  }
- public class MemoryStream : Stream {
-   public MemoryStream();
-   public MemoryStream(byte[] buffer);
-   public MemoryStream(byte[] buffer, bool writable);
-   public MemoryStream(byte[] buffer, int index, int count);
-   public MemoryStream(byte[] buffer, int index, int count, bool writable);
-   public MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
-   public MemoryStream(int capacity);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public virtual int Capacity { get; set; }
-   public override long Length { get; }
-   public override long Position { get; set; }
-   public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
-   protected override void Dispose(bool disposing);
-   public override void Flush();
-   public override Task FlushAsync(CancellationToken cancellationToken);
-   public virtual byte[] GetBuffer();
-   public override int Read(byte[] buffer, int offset, int count);
-   public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override int ReadByte();
-   public override long Seek(long offset, SeekOrigin loc);
-   public override void SetLength(long value);
-   public virtual byte[] ToArray();
-   public virtual bool TryGetBuffer(out ArraySegment<byte> buffer);
-   public override void Write(byte[] buffer, int offset, int count);
-   public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override void WriteByte(byte value);
-   public virtual void WriteTo(Stream stream);
  }
- public static class Path {
-   public static readonly char AltDirectorySeparatorChar;
-   public static readonly char DirectorySeparatorChar;
-   public static readonly char PathSeparator;
-   public static readonly char VolumeSeparatorChar;
-   public static readonly char[] InvalidPathChars;
-   public static string ChangeExtension(string path, string extension);
-   public static string Combine(string path1, string path2);
-   public static string Combine(string path1, string path2, string path3);
-   public static string Combine(string path1, string path2, string path3, string path4);
-   public static string Combine(params string[] paths);
-   public static string GetDirectoryName(string path);
-   public static string GetExtension(string path);
-   public static string GetFileName(string path);
-   public static string GetFileNameWithoutExtension(string path);
-   public static string GetFullPath(string path);
-   public static char[] GetInvalidFileNameChars();
-   public static char[] GetInvalidPathChars();
-   public static string GetPathRoot(string path);
-   public static string GetRandomFileName();
-   public static string GetTempFileName();
-   public static string GetTempPath();
-   public static bool HasExtension(string path);
-   public static bool IsPathRooted(string path);
  }
  public class PathTooLongException : IOException {
    public PathTooLongException();
-   protected PathTooLongException(SerializationInfo info, StreamingContext context);
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
  }
- public enum SearchOption {
-   AllDirectories = 1,
-   TopDirectoryOnly = 0,
  }
- public enum SeekOrigin {
-   Begin = 0,
-   Current = 1,
-   End = 2,
  }
- public abstract class Stream : MarshalByRefObject, IDisposable {
-   public static readonly Stream Null;
-   protected Stream();
-   public abstract bool CanRead { get; }
-   public abstract bool CanSeek { get; }
-   public virtual bool CanTimeout { get; }
-   public abstract bool CanWrite { get; }
-   public abstract long Length { get; }
-   public abstract long Position { get; set; }
-   public virtual int ReadTimeout { get; set; }
-   public virtual int WriteTimeout { get; set; }
-   public virtual IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
-   public virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
-   public virtual void Close();
-   public void CopyTo(Stream destination);
-   public void CopyTo(Stream destination, int bufferSize);
-   public Task CopyToAsync(Stream destination);
-   public Task CopyToAsync(Stream destination, int bufferSize);
-   public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
-   protected virtual WaitHandle CreateWaitHandle();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual int EndRead(IAsyncResult asyncResult);
-   public virtual void EndWrite(IAsyncResult asyncResult);
-   public abstract void Flush();
-   public Task FlushAsync();
-   public virtual Task FlushAsync(CancellationToken cancellationToken);
-   protected virtual void ObjectInvariant();
-   public abstract int Read(byte[] buffer, int offset, int count);
-   public Task<int> ReadAsync(byte[] buffer, int offset, int count);
-   public virtual Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public virtual int ReadByte();
-   public abstract long Seek(long offset, SeekOrigin origin);
-   public abstract void SetLength(long value);
-   public static Stream Synchronized(Stream stream);
-   public abstract void Write(byte[] buffer, int offset, int count);
-   public Task WriteAsync(byte[] buffer, int offset, int count);
-   public virtual Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public virtual void WriteByte(byte value);
  }
- public class StreamReader : TextReader {
-   public static readonly new StreamReader Null;
-   public StreamReader(Stream stream);
-   public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
-   public StreamReader(Stream stream, Encoding encoding);
-   public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
-   public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-   public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
-   public StreamReader(string path);
-   public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
-   public StreamReader(string path, Encoding encoding);
-   public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
-   public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-   public virtual Stream BaseStream { get; }
-   public virtual Encoding CurrentEncoding { get; }
-   public bool EndOfStream { get; }
-   public override void Close();
-   public void DiscardBufferedData();
-   protected override void Dispose(bool disposing);
-   public override int Peek();
-   public override int Read();
-   public override int Read(char[] buffer, int index, int count);
-   public override Task<int> ReadAsync(char[] buffer, int index, int count);
-   public override int ReadBlock(char[] buffer, int index, int count);
-   public override Task<int> ReadBlockAsync(char[] buffer, int index, int count);
-   public override string ReadLine();
-   public override Task<string> ReadLineAsync();
-   public override string ReadToEnd();
-   public override Task<string> ReadToEndAsync();
  }
- public class StreamWriter : TextWriter {
-   public static readonly new StreamWriter Null;
-   public StreamWriter(Stream stream);
-   public StreamWriter(Stream stream, Encoding encoding);
-   public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
-   public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
-   public StreamWriter(string path);
-   public StreamWriter(string path, bool append);
-   public StreamWriter(string path, bool append, Encoding encoding);
-   public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
-   public virtual bool AutoFlush { get; set; }
-   public virtual Stream BaseStream { get; }
-   public override Encoding Encoding { get; }
-   public override void Close();
-   protected override void Dispose(bool disposing);
-   public override void Flush();
-   public override Task FlushAsync();
-   public override void Write(char value);
-   public override void Write(char[] buffer);
-   public override void Write(char[] buffer, int index, int count);
-   public override void Write(string value);
-   public override Task WriteAsync(char value);
-   public override Task WriteAsync(char[] buffer, int index, int count);
-   public override Task WriteAsync(string value);
-   public override Task WriteLineAsync();
-   public override Task WriteLineAsync(char value);
-   public override Task WriteLineAsync(char[] buffer, int index, int count);
-   public override Task WriteLineAsync(string value);
  }
- public class StringReader : TextReader {
-   public StringReader(string s);
-   public override void Close();
-   protected override void Dispose(bool disposing);
-   public override int Peek();
-   public override int Read();
-   public override int Read(char[] buffer, int index, int count);
-   public override Task<int> ReadAsync(char[] buffer, int index, int count);
-   public override Task<int> ReadBlockAsync(char[] buffer, int index, int count);
-   public override string ReadLine();
-   public override Task<string> ReadLineAsync();
-   public override string ReadToEnd();
-   public override Task<string> ReadToEndAsync();
  }
- public class StringWriter : TextWriter {
-   public StringWriter();
-   public StringWriter(IFormatProvider formatProvider);
-   public StringWriter(StringBuilder sb);
-   public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
-   public override Encoding Encoding { get; }
-   public override void Close();
-   protected override void Dispose(bool disposing);
-   public override Task FlushAsync();
-   public virtual StringBuilder GetStringBuilder();
-   public override string ToString();
-   public override void Write(char value);
-   public override void Write(char[] buffer, int index, int count);
-   public override void Write(string value);
-   public override Task WriteAsync(char value);
-   public override Task WriteAsync(char[] buffer, int index, int count);
-   public override Task WriteAsync(string value);
-   public override Task WriteLineAsync(char value);
-   public override Task WriteLineAsync(char[] buffer, int index, int count);
-   public override Task WriteLineAsync(string value);
  }
- public abstract class TextReader : MarshalByRefObject, IDisposable {
-   public static readonly TextReader Null;
-   protected TextReader();
-   public virtual void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual int Peek();
-   public virtual int Read();
-   public virtual int Read(char[] buffer, int index, int count);
-   public virtual Task<int> ReadAsync(char[] buffer, int index, int count);
-   public virtual int ReadBlock(char[] buffer, int index, int count);
-   public virtual Task<int> ReadBlockAsync(char[] buffer, int index, int count);
-   public virtual string ReadLine();
-   public virtual Task<string> ReadLineAsync();
-   public virtual string ReadToEnd();
-   public virtual Task<string> ReadToEndAsync();
-   public static TextReader Synchronized(TextReader reader);
  }
- public abstract class TextWriter : MarshalByRefObject, IDisposable {
-   protected char[] CoreNewLine;
-   public static readonly TextWriter Null;
-   protected TextWriter();
-   protected TextWriter(IFormatProvider formatProvider);
-   public abstract Encoding Encoding { get; }
-   public virtual IFormatProvider FormatProvider { get; }
-   public virtual string NewLine { get; set; }
-   public virtual void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual void Flush();
-   public virtual Task FlushAsync();
-   public static TextWriter Synchronized(TextWriter writer);
-   public virtual void Write(bool value);
-   public virtual void Write(char value);
-   public virtual void Write(char[] buffer);
-   public virtual void Write(char[] buffer, int index, int count);
-   public virtual void Write(decimal value);
-   public virtual void Write(double value);
-   public virtual void Write(int value);
-   public virtual void Write(long value);
-   public virtual void Write(object value);
-   public virtual void Write(float value);
-   public virtual void Write(string value);
-   public virtual void Write(string format, object arg0);
-   public virtual void Write(string format, object arg0, object arg1);
-   public virtual void Write(string format, object arg0, object arg1, object arg2);
-   public virtual void Write(string format, params object[] arg);
-   public virtual void Write(uint value);
-   public virtual void Write(ulong value);
-   public virtual Task WriteAsync(char value);
-   public Task WriteAsync(char[] buffer);
-   public virtual Task WriteAsync(char[] buffer, int index, int count);
-   public virtual Task WriteAsync(string value);
-   public virtual void WriteLine();
-   public virtual void WriteLine(bool value);
-   public virtual void WriteLine(char value);
-   public virtual void WriteLine(char[] buffer);
-   public virtual void WriteLine(char[] buffer, int index, int count);
-   public virtual void WriteLine(decimal value);
-   public virtual void WriteLine(double value);
-   public virtual void WriteLine(int value);
-   public virtual void WriteLine(long value);
-   public virtual void WriteLine(object value);
-   public virtual void WriteLine(float value);
-   public virtual void WriteLine(string value);
-   public virtual void WriteLine(string format, object arg0);
-   public virtual void WriteLine(string format, object arg0, object arg1);
-   public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
-   public virtual void WriteLine(string format, params object[] arg);
-   public virtual void WriteLine(uint value);
-   public virtual void WriteLine(ulong value);
-   public virtual Task WriteLineAsync();
-   public virtual Task WriteLineAsync(char value);
-   public Task WriteLineAsync(char[] buffer);
-   public virtual Task WriteLineAsync(char[] buffer, int index, int count);
-   public virtual Task WriteLineAsync(string value);
  }
- public class UnmanagedMemoryAccessor : IDisposable {
-   protected UnmanagedMemoryAccessor();
-   public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
-   public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
-   public bool CanRead { get; }
-   public bool CanWrite { get; }
-   public long Capacity { get; }
-   protected bool IsOpen { get; }
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
-   public void Read<T>(long position, out T structure) where T : struct;
-   public int ReadArray<T>(long position, T[] array, int offset, int count) where T : struct;
-   public bool ReadBoolean(long position);
-   public byte ReadByte(long position);
-   public char ReadChar(long position);
-   public decimal ReadDecimal(long position);
-   public double ReadDouble(long position);
-   public short ReadInt16(long position);
-   public int ReadInt32(long position);
-   public long ReadInt64(long position);
-   public sbyte ReadSByte(long position);
-   public float ReadSingle(long position);
-   public ushort ReadUInt16(long position);
-   public uint ReadUInt32(long position);
-   public ulong ReadUInt64(long position);
-   public void Write(long position, bool value);
-   public void Write(long position, byte value);
-   public void Write(long position, char value);
-   public void Write(long position, decimal value);
-   public void Write(long position, double value);
-   public void Write(long position, short value);
-   public void Write(long position, int value);
-   public void Write(long position, long value);
-   public void Write(long position, sbyte value);
-   public void Write(long position, float value);
-   public void Write(long position, ushort value);
-   public void Write(long position, uint value);
-   public void Write(long position, ulong value);
-   public void Write<T>(long position, ref T structure) where T : struct;
-   public void WriteArray<T>(long position, T[] array, int offset, int count) where T : struct;
  }
- public class UnmanagedMemoryStream : Stream {
-   protected UnmanagedMemoryStream();
-   public unsafe UnmanagedMemoryStream(byte* pointer, long length);
-   public unsafe UnmanagedMemoryStream(byte* pointer, long length, long capacity, FileAccess access);
-   public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
-   public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public long Capacity { get; }
-   public override long Length { get; }
-   public override long Position { get; set; }
-   public unsafe byte* PositionPointer { get; set; }
-   protected override void Dispose(bool disposing);
-   public override void Flush();
-   public override Task FlushAsync(CancellationToken cancellationToken);
-   protected unsafe void Initialize(byte* pointer, long length, long capacity, FileAccess access);
-   protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
-   public override int Read(byte[] buffer, int offset, int count);
-   public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override int ReadByte();
-   public override long Seek(long offset, SeekOrigin loc);
-   public override void SetLength(long value);
-   public override void Write(byte[] buffer, int offset, int count);
-   public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override void WriteByte(byte value);
  }
 }
-namespace System.IO.IsolatedStorage {
- public interface INormalizeForIsolatedStorage {
-   object Normalize();
  }
- public abstract class IsolatedStorage : MarshalByRefObject {
-   protected IsolatedStorage();
-   public object ApplicationIdentity { get; }
-   public object AssemblyIdentity { get; }
-   public virtual long AvailableFreeSpace { get; }
-   public virtual ulong CurrentSize { get; }
-   public object DomainIdentity { get; }
-   public virtual ulong MaximumSize { get; }
-   public virtual long Quota { get; }
-   public IsolatedStorageScope Scope { get; }
-   protected virtual char SeparatorExternal { get; }
-   protected virtual char SeparatorInternal { get; }
-   public virtual long UsedSize { get; }
-   protected abstract IsolatedStoragePermission GetPermission(PermissionSet ps);
-   public virtual bool IncreaseQuotaTo(long newQuotaSize);
-   protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType);
-   protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
-   public abstract void Remove();
  }
- public class IsolatedStorageException : Exception {
-   public IsolatedStorageException();
-   protected IsolatedStorageException(SerializationInfo info, StreamingContext context);
-   public IsolatedStorageException(string message);
-   public IsolatedStorageException(string message, Exception inner);
  }
- public sealed class IsolatedStorageFile : IsolatedStorage, IDisposable {
-   public override long AvailableFreeSpace { get; }
-   public override ulong CurrentSize { get; }
-   public static bool IsEnabled { get; }
-   public override ulong MaximumSize { get; }
-   public override long Quota { get; }
-   public override long UsedSize { get; }
-   public void Close();
-   public void CopyFile(string sourceFileName, string destinationFileName);
-   public void CopyFile(string sourceFileName, string destinationFileName, bool overwrite);
-   public void CreateDirectory(string dir);
-   public IsolatedStorageFileStream CreateFile(string path);
-   public void DeleteDirectory(string dir);
-   public void DeleteFile(string file);
-   public bool DirectoryExists(string path);
-   public void Dispose();
-   public bool FileExists(string path);
-   ~IsolatedStorageFile();
-   public DateTimeOffset GetCreationTime(string path);
-   public string[] GetDirectoryNames();
-   public string[] GetDirectoryNames(string searchPattern);
-   public static IEnumerator GetEnumerator(IsolatedStorageScope scope);
-   public string[] GetFileNames();
-   public string[] GetFileNames(string searchPattern);
-   public DateTimeOffset GetLastAccessTime(string path);
-   public DateTimeOffset GetLastWriteTime(string path);
-   public static IsolatedStorageFile GetMachineStoreForApplication();
-   public static IsolatedStorageFile GetMachineStoreForAssembly();
-   public static IsolatedStorageFile GetMachineStoreForDomain();
-   protected override IsolatedStoragePermission GetPermission(PermissionSet ps);
-   public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity);
-   public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);
-   public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Evidence domainEvidence, Type domainEvidenceType, Evidence assemblyEvidence, Type assemblyEvidenceType);
-   public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType);
-   public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
-   public static IsolatedStorageFile GetUserStoreForApplication();
-   public static IsolatedStorageFile GetUserStoreForAssembly();
-   public static IsolatedStorageFile GetUserStoreForDomain();
-   public static IsolatedStorageFile GetUserStoreForSite();
-   public override bool IncreaseQuotaTo(long newQuotaSize);
-   public void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName);
-   public void MoveFile(string sourceFileName, string destinationFileName);
-   public IsolatedStorageFileStream OpenFile(string path, FileMode mode);
-   public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access);
-   public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
-   public override void Remove();
-   public static void Remove(IsolatedStorageScope scope);
  }
- public class IsolatedStorageFileStream : FileStream {
-   public IsolatedStorageFileStream(string path, FileMode mode);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf);
-   public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf);
-   public IsolatedStorageFileStream(string path, FileMode mode, IsolatedStorageFile isf);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public override IntPtr Handle { get; }
-   public override bool IsAsync { get; }
-   public override long Length { get; }
-   public override long Position { get; set; }
-   public override SafeFileHandle SafeFileHandle { get; }
-   public override IAsyncResult BeginRead(byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
-   public override IAsyncResult BeginWrite(byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
-   protected override void Dispose(bool disposing);
-   public override int EndRead(IAsyncResult asyncResult);
-   public override void EndWrite(IAsyncResult asyncResult);
-   public override void Flush();
-   public override void Flush(bool flushToDisk);
-   public override void Lock(long position, long length);
-   public override int Read(byte[] buffer, int offset, int count);
-   public override int ReadByte();
-   public override long Seek(long offset, SeekOrigin origin);
-   public override void SetLength(long value);
-   public override void Unlock(long position, long length);
-   public override void Write(byte[] buffer, int offset, int count);
-   public override void WriteByte(byte value);
  }
- public enum IsolatedStorageScope {
-   Application = 32,
-   Assembly = 4,
-   Domain = 2,
-   Machine = 16,
-   None = 0,
-   Roaming = 8,
-   User = 1,
  }
- public enum IsolatedStorageSecurityOptions {
-   IncreaseQuotaForApplication = 4,
  }
- public class IsolatedStorageSecurityState : SecurityState {
-   public IsolatedStorageSecurityOptions Options { get; }
-   public long Quota { get; set; }
-   public long UsedSize { get; }
-   public override void EnsureState();
  }
 }
 namespace System.Reflection {
  public sealed class AmbiguousMatchException : SystemExceptionException {
    public AmbiguousMatchException();
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
  }
  public abstract class Assembly : _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable {
-   protected Assembly();
    public virtual string CodeBase { get; }
    public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
    public virtualabstract IEnumerable<TypeInfo> DefinedTypes { get; }
    public virtual MethodInfo EntryPoint { get; }
    public virtual string EscapedCodeBase { get; }
-   public virtual Evidence Evidence { get; }
    public virtual IEnumerable<Type> ExportedTypes { get; }
    public virtual string FullName { get; }
-   public virtual bool GlobalAssemblyCache { get; }
-   public virtual long HostContext { get; }
    ^ Pallavi Taneja: AssemblyLoadContext should have this.
-   public virtual string ImageRuntimeVersion { get; }
    ^ Immo Landwerth: Expose unless a problem exists.
    ^ Pallavi Taneja: Can implement, not sure if we should?
    public virtual bool IsDynamic { get; }
-   public bool IsFullyTrusted { get; }
    public virtual string Location { get; }
    public virtual Module ManifestModule { get; }
    public virtualabstract IEnumerable<Module> Modules { get; }
-   public virtual PermissionSet PermissionSet { get; }
-   public virtual bool ReflectionOnly { get; }
-   public virtual SecurityRuleSet SecurityRuleSet { get; }
-   public virtual event ModuleResolveEventHandler ModuleResolve;
    ^ Pallavi Taneja: Part of ALC
-   public object CreateInstance(string typeName);
    ^ Pallavi Taneja: [Add Back]
-   public object CreateInstance(string typeName, bool ignoreCase);
-   public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   public static string CreateQualifiedName(string assemblyName, string typeName);
    ^ Pallavi Taneja: [Add back]
    public override bool Equals(object o);
-   public static Assembly GetAssembly(Type type);
    ^ Immo Landwerth: Expose
-   [MethodImpl(NoInlining)]public static Assembly GetCallingAssembly();
    ^ Pallavi Taneja: StackCrawling
-   public virtual object[] GetCustomAttributes(bool inherit);
-   public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public virtual IList<CustomAttributeData> GetCustomAttributesData();
    public static Assembly GetEntryAssembly();
-   [MethodImpl(NoInlining)]public static Assembly GetExecutingAssembly();
    ^ Immo Landwerth: follow up whether there are any problems with NGEN/CoreRT/N. If not, expose.
    ^ Pallavi Taneja: StackCrawling
-   public virtual Type[] GetExportedTypes();
    ^ Pallavi Taneja: [Add Back]
-   public virtual FileStream GetFile(string name);
    ^ Pallavi Taneja: System.IO.FileSystem dependency + multi module sceanrios only.
-   public virtual FileStream[] GetFiles();
-   public virtual FileStream[] GetFiles(bool getResourceModules);
    public override int GetHashCode();
-   public Module[] GetLoadedModules();
    ^ Pallavi Taneja: Queries the loader to get the loaded modules so be in AssemblyLoadContext
-   public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
-   public virtual Stream GetManifestResourceStream(Type type, string name);
    ^ Immo Landwerth: Expose
-   public virtual Module GetModule(string name);
    ^ Pallavi Taneja: MultiModule scenarios
-   public Module[] GetModules();
-   public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName();
-   public virtual AssemblyName GetName(bool copiedName);
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual AssemblyName[] GetReferencedAssemblies();
    ^ Pallavi Taneja: [Add Back]
-   public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
-   public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Type GetType(string name);
-   public virtual Type GetType(string name, bool throwOnError);
    ^ Pallavi Taneja: [Add Back]
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
-   public virtual Type[] GetTypes();
    ^ Immo Landwerth: Expose, used a lot
-   public virtual bool IsDefined(Type attributeType, bool inherit);
-   [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly);
-   [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
-   [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
-   [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, SecurityContextSource securityContextSource);
-   [MethodImpl(NoInlining)]public static Assembly Load(AssemblyName assemblyRef);
-   [MethodImpl(NoInlining)]public static Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
-   [MethodImpl(NoInlining)]public static Assembly Load(string assemblyString);
-   [MethodImpl(NoInlining)]public static Assembly Load(string assemblyString, Evidence assemblySecurity);
-   public static Assembly LoadFile(string path);
-   public static Assembly LoadFile(string path, Evidence securityEvidence);
-   [MethodImpl(NoInlining)]public static Assembly LoadFrom(string assemblyFile);
-   [MethodImpl(NoInlining)]public static Assembly LoadFrom(string assemblyFile, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   [MethodImpl(NoInlining)]public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence);
-   [MethodImpl(NoInlining)]public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
-   public Module LoadModule(string moduleName, byte[] rawModule);
-   public virtual Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore);
-   [MethodImpl(NoInlining)]public static Assembly LoadWithPartialName(string partialName);
-   [MethodImpl(NoInlining)]public static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence);
-   public static bool operator ==(Assembly left, Assembly right);
-   public static bool operator !=(Assembly left, Assembly right);
-   [MethodImpl(NoInlining)]public static Assembly ReflectionOnlyLoad(byte[] rawAssembly);
-   [MethodImpl(NoInlining)]public static Assembly ReflectionOnlyLoad(string assemblyString);
-   [MethodImpl(NoInlining)]public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
-   Type System.Runtime.InteropServices._Assembly.GetType();
    public override string ToString();
-   [MethodImpl(NoInlining)]public static Assembly UnsafeLoadFrom(string assemblyFile);
  }
- public sealed class AssemblyAlgorithmIdAttribute : Attribute {
    ^ Pallavi Taneja: Not sure who consumes this
-   public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
-   public AssemblyAlgorithmIdAttribute(uint algorithmId);
-   public uint AlgorithmId { get; }
  }
  public sealed class AssemblyCompanyAttribute : Attribute {
    public AssemblyCompanyAttribute(string company);
    public string Company { get; }
  }
  public sealed class AssemblyConfigurationAttribute : Attribute {
    public AssemblyConfigurationAttribute(string configuration);
    public string Configuration { get; }
  }
  public enum AssemblyContentType {
    Default = 0,
    WindowsRuntime = 1,
  }
  public sealed class AssemblyCopyrightAttribute : Attribute {
    public AssemblyCopyrightAttribute(string copyright);
    public string Copyright { get; }
  }
  public sealed class AssemblyCultureAttribute : Attribute {
    public AssemblyCultureAttribute(string culture);
    public string Culture { get; }
  }
  public sealed class AssemblyDefaultAliasAttribute : Attribute {
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string DefaultAlias { get; }
  }
  public sealed class AssemblyDelaySignAttribute : Attribute {
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool DelaySign { get; }
  }
  public sealed class AssemblyDescriptionAttribute : Attribute {
    public AssemblyDescriptionAttribute(string description);
    public string Description { get; }
  }
  public sealed class AssemblyFileVersionAttribute : Attribute {
    public AssemblyFileVersionAttribute(string version);
    public string Version { get; }
  }
  public sealed class AssemblyFlagsAttribute : Attribute {
-   public AssemblyFlagsAttribute(int assemblyFlags);
    ^ Pallavi Taneja: Marked Obsolete
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
-   public AssemblyFlagsAttribute(uint flags);
    ^ Pallavi Taneja: Marked Obsolete
    public int AssemblyFlags { get; }
-   public uint Flags { get; }
    ^ Pallavi Taneja: Marked Obsolete
  }
  public sealed class AssemblyInformationalVersionAttribute : Attribute {
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string InformationalVersion { get; }
  }
  public sealed class AssemblyKeyFileAttribute : Attribute {
    public AssemblyKeyFileAttribute(string keyFile);
    public string KeyFile { get; }
  }
  public sealed class AssemblyKeyNameAttribute : Attribute {
    public AssemblyKeyNameAttribute(string keyName);
    public string KeyName { get; }
  }
  public sealed class AssemblyMetadataAttribute : Attribute {
    public AssemblyMetadataAttribute(string key, string value);
    public string Key { get; }
    public string Value { get; }
  }
  public sealed class AssemblyName : _AssemblyName, ICloneable, IDeserializationCallback, ISerializable {
    public AssemblyName();
    public AssemblyName(string assemblyName);
-   public string CodeBase { get; set; }
    public AssemblyContentType ContentType { get; set; }
-   public CultureInfo CultureInfo { get; set; }
    public string CultureName { get; set; }
-   public string EscapedCodeBase { get; }
    public AssemblyNameFlags Flags { get; set; }
    public string FullName { get; }
-   public AssemblyHashAlgorithm HashAlgorithm { get; set; }
    ^ Pallavi Taneja: [Add back]
-   public StrongNameKeyPair KeyPair { get; set; }
    ^ Pallavi Taneja: Sequncing  Can be used only in dynamic assemblies.
    public string Name { get; set; }
    public ProcessorArchitecture ProcessorArchitecture { get; set; }
    public Version Version { get; set; }
-   public AssemblyVersionCompatibility VersionCompatibility { get; set; }
-   public object Clone();
-   public static AssemblyName GetAssemblyName(string assemblyFile);
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
    public byte[] GetPublicKey();
    public byte[] GetPublicKeyToken();
-   public void OnDeserialization(object sender);
-   public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    ^ Pallavi Taneja: Comapres AssemblySpecs
    public void SetPublicKey(byte[] publicKey);
    public void SetPublicKeyToken(byte[] publicKeyToken);
-   void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._AssemblyName.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public override string ToString();
  }
  public enum AssemblyNameFlags {
-   EnableJITcompileOptimizer = 16384,
-   EnableJITcompileTracking = 32768,
    None = 0,
    PublicKey = 1,
    Retargetable = 256,
  }
- public class AssemblyNameProxy : MarshalByRefObject {
    ^ Pallavi Taneja: Remoting compatible name of the assembly.
-   public AssemblyNameProxy();
-   public AssemblyName GetAssemblyName(string assemblyFile);
  }
  public sealed class AssemblyProductAttribute : Attribute {
    public AssemblyProductAttribute(string product);
    public string Product { get; }
  }
  public sealed class AssemblySignatureKeyAttribute : Attribute {
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string Countersignature { get; }
    public string PublicKey { get; }
  }
  public sealed class AssemblyTitleAttribute : Attribute {
    public AssemblyTitleAttribute(string title);
    public string Title { get; }
  }
  public sealed class AssemblyTrademarkAttribute : Attribute {
    public AssemblyTrademarkAttribute(string trademark);
    public string Trademark { get; }
  }
  public sealed class AssemblyVersionAttribute : Attribute {
    public AssemblyVersionAttribute(string version);
    public string Version { get; }
  }
  public abstract class Binder {
    ^ Pallavi Taneja: Expose as Empty in System.Reflection. Options added separately.
    protected Binder();
-   public abstract FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
-   public abstract MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] names, out object state);
-   public abstract object ChangeType(object value, Type type, CultureInfo culture);
-   public abstract void ReorderArgumentArray(ref object[] args, object state);
-   public abstract MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
-   public abstract PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
  }
  public enum BindingFlags {
    CreateInstance = 512,
    DeclaredOnly = 2,
    Default = 0,
-   ExactBinding = 65536,
    ^ Pallavi Taneja: Used only in case Binder is extensible.
    FlattenHierarchy = 64,
    GetField = 1024,
    GetProperty = 4096,
    IgnoreCase = 1,
-   IgnoreReturn = 16777216,
    ^ Pallavi Taneja: Only used in Interop.
    Instance = 4,
    InvokeMethod = 256,
    NonPublic = 32,
-   OptionalParamBinding = 262144,
    ^ Pallavi Taneja: [Unsure] used most only in varArgs scenario.
    Public = 16,
-   PutDispProperty = 16384,
    ^ Pallavi Taneja: Interop scenario.
-   PutRefDispProperty = 32768,
    SetField = 2048,
    SetProperty = 8192,
    Static = 8,
-   SuppressChangeType = 131072,
  }
  public enum CallingConventions {
    Any = 3,
    ExplicitThis = 64,
    HasThis = 32,
    Standard = 1,
    VarArgs = 2,
  }
  public abstract class ConstructorInfo : MethodBase, _ConstructorInfo {
    public static readonly string ConstructorName;
    public static readonly string TypeConstructorName;
-   protected ConstructorInfo();
    public override MemberTypes MemberType { get; }
    public override bool Equals(object obj);
    public override int GetHashCode();
    public virtual object Invoke(object[] parameters);
-   public abstract object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
    ^ Pallavi Taneja: System.Globalization dependency. Usage < 2%. No reflection contract currently take glob dep not just S.R.dll
-   public static bool operator ==(ConstructorInfo left, ConstructorInfo right);
-   public static bool operator !=(ConstructorInfo left, ConstructorInfo right);
-   void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._ConstructorInfo.GetType();
-   void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ConstructorInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, object[] parameters);
-   object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(object[] parameters);
  }
  public class CustomAttributeData {
-   protected CustomAttributeData();
    public virtual Type AttributeType { get; }
    public virtual ConstructorInfo Constructor { get; }
    public virtual IList<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public virtual IList<CustomAttributeNamedArgument> NamedArguments { get; }
-   public override bool Equals(object obj);
    public static IList<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
-   public override int GetHashCode();
-   public override string ToString();
  }
  public static class CustomAttributeExtensions {
    public static Attribute GetCustomAttribute(this Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(this Module element, Type attributeType);
    public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType, bool inherit);
    public static T GetCustomAttribute<T>(this Assembly element) where T : Attribute;
    public static T GetCustomAttribute<T>(this MemberInfo element) where T : Attribute;
    public static T GetCustomAttribute<T>(this MemberInfo element, bool inherit) where T : Attribute;
    public static T GetCustomAttribute<T>(this Module element) where T : Attribute;
    public static T GetCustomAttribute<T>(this ParameterInfo element) where T : Attribute;
    public static T GetCustomAttribute<T>(this ParameterInfo element, bool inherit) where T : Attribute;
    public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element);
    public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element, Type attributeType);
    public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element);
    public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, bool inherit);
    public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType);
    public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType, bool inherit);
    public static IEnumerable<Attribute> GetCustomAttributes(this Module element);
    public static IEnumerable<Attribute> GetCustomAttributes(this Module element, Type attributeType);
    public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element);
    public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, bool inherit);
    public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType);
    public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType, bool inherit);
    public static IEnumerable<T> GetCustomAttributes<T>(this Assembly element) where T : Attribute;
    public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element) where T : Attribute;
    public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element, bool inherit) where T : Attribute;
    public static IEnumerable<T> GetCustomAttributes<T>(this Module element) where T : Attribute;
    public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element) where T : Attribute;
    public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element, bool inherit) where T : Attribute;
    public static bool IsDefined(this Assembly element, Type attributeType);
    public static bool IsDefined(this MemberInfo element, Type attributeType);
    public static bool IsDefined(this MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(this Module element, Type attributeType);
    public static bool IsDefined(this ParameterInfo element, Type attributeType);
    public static bool IsDefined(this ParameterInfo element, Type attributeType, bool inherit);
  }
- public class CustomAttributeFormatException : FormatException {
    ^ Pallavi Taneja: [Not sure] Used mainly in case a tool formatted a custom attribute incorrectly.
-   public CustomAttributeFormatException();
-   protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
-   public CustomAttributeFormatException(string message);
-   public CustomAttributeFormatException(string message, Exception inner);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CustomAttributeNamedArgument {
-   public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
-   public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public bool IsField { get; }
    public MemberInfo MemberInfo { get; }
    public string MemberName { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public static bool operator ==(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    ^ Pallavi Taneja: I have left out equality operators across reflection since, there were concerns earlier that its behavior might not be consistent with .Equals
-   public static bool operator !=(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
-   public override string ToString();
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CustomAttributeTypedArgument {
-   public CustomAttributeTypedArgument(object value);
-   public CustomAttributeTypedArgument(Type argumentType, object value);
    public Type ArgumentType { get; }
    public object Value { get; }
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public static bool operator ==(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
-   public static bool operator !=(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
-   public override string ToString();
  }
  public sealed class DefaultMemberAttribute : Attribute {
    public DefaultMemberAttribute(string memberName);
    public string MemberName { get; }
  }
  public enum EventAttributes {
    None = 0,
-   ReservedMask = 1024,
    RTSpecialName = 1024,
    SpecialName = 512,
  }
  public abstract class EventInfo : MemberInfo, _EventInfo {
-   protected EventInfo();
    public virtual MethodInfo AddMethod { get; }
    public abstract EventAttributes Attributes { get; }
    public virtual Type EventHandlerType { get; }
    public virtual bool IsMulticast { get; }
    public bool IsSpecialName { get; }
    public override MemberTypes MemberType { get; }
    public virtual MethodInfo RaiseMethod { get; }
    public virtual MethodInfo RemoveMethod { get; }
    public virtual void AddEventHandler(object target, Delegate handler);
    public override bool Equals(object obj);
    public MethodInfo GetAddMethod();
    ^ Pallavi Taneja: Get*Method are exposed via S.R.TE. Consider removing from there.
    public abstractvirtual MethodInfo GetAddMethod(bool nonPublic);
    public override int GetHashCode();
-   public MethodInfo[] GetOtherMethods();
    ^ Pallavi Taneja: .other directive in events is not exposed in any language semantics we care about AFAIK and currently can be leveraged using ilasm only.
-   public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public MethodInfo GetRaiseMethod();
    public abstractvirtual MethodInfo GetRaiseMethod(bool nonPublic);
    public MethodInfo GetRemoveMethod();
    public abstractvirtual MethodInfo GetRemoveMethod(bool nonPublic);
-   public static bool operator ==(EventInfo left, EventInfo right);
-   public static bool operator !=(EventInfo left, EventInfo right);
    public virtual void RemoveEventHandler(object target, Delegate handler);
-   void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._EventInfo.GetType();
-   void System.Runtime.InteropServices._EventInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._EventInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public class ExceptionHandlingClause {
    ^ Pallavi Taneja: Not sure if we would want to expose SEH inspection or IL inspection in general.
-   protected ExceptionHandlingClause();
-   public virtual Type CatchType { get; }
-   public virtual int FilterOffset { get; }
-   public virtual ExceptionHandlingClauseOptions Flags { get; }
-   public virtual int HandlerLength { get; }
-   public virtual int HandlerOffset { get; }
-   public virtual int TryLength { get; }
-   public virtual int TryOffset { get; }
-   public override string ToString();
  }
- public enum ExceptionHandlingClauseOptions {
    ^ Pallavi Taneja: Same as above.
-   Clause = 0,
-   Fault = 4,
-   Filter = 1,
-   Finally = 2,
  }
  public enum FieldAttributes {
    Assembly = 3,
    FamANDAssem = 2,
    Family = 4,
    FamORAssem = 5,
    FieldAccessMask = 7,
    HasDefault = 32768,
    HasFieldMarshal = 4096,
    HasFieldRVA = 256,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    PinvokeImpl = 8192,
    Private = 1,
    PrivateScope = 0,
    Public = 6,
-   ReservedMask = 38144,
    RTSpecialName = 1024,
    SpecialName = 512,
    Static = 16,
  }
  public abstract class FieldInfo : MemberInfo, _FieldInfo {
-   protected FieldInfo();
    public abstract FieldAttributes Attributes { get; }
    public abstractvirtual RuntimeFieldHandle FieldHandle { get; }
    public abstract Type FieldType { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
-   public bool IsNotSerialized { get; }
    ^ Pallavi Taneja: We do not expose NotSerializedAttribute notion.
-   public bool IsPinvokeImpl { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
-   public virtual bool IsSecurityCritical { get; }
-   public virtual bool IsSecuritySafeCritical { get; }
-   public virtual bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public override MemberTypes MemberType { get; }
    public override bool Equals(object obj);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public override int GetHashCode();
-   public virtual Type[] GetOptionalCustomModifiers();
    ^ Pallavi Taneja: [Not sure] Used in Compiler only context. Usage < 1% except xamarin using GetRawConstantValue 10%. Should there not be an alternative in metadata instead?
-   public virtual object GetRawConstantValue();
-   public virtual Type[] GetRequiredCustomModifiers();
    public abstract object GetValue(object obj);
-   public virtual object GetValueDirect(TypedReference obj);
    ^ Pallavi Taneja: TypedReference is not exposed.
-   public static bool operator ==(FieldInfo left, FieldInfo right);
-   public static bool operator !=(FieldInfo left, FieldInfo right);
    public virtual void SetValue(object obj, object value);
-   public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
-   public virtual void SetValueDirect(TypedReference obj, object value);
-   void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._FieldInfo.GetType();
-   void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._FieldInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
  public enum GenericParameterAttributes {
    Contravariant = 2,
    Covariant = 1,
    DefaultConstructorConstraint = 16,
    None = 0,
    NotNullableValueTypeConstraint = 8,
    ReferenceTypeConstraint = 4,
    SpecialConstraintMask = 28,
    VarianceMask = 3,
  }
- public interface ICustomAttributeProvider {
    ^ Pallavi Taneja: We do not expose ICustomAttributeProvider, however we expose the members via extension methods via S.R.E. Hence, exposing this correctly will be difficult.
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   bool IsDefined(Type attributeType, bool inherit);
  }
- public enum ImageFileMachine {
    ^ Pallavi Taneja: Use S.R.I.RuntimeInformation instead
-   AMD64 = 34404,
-   ARM = 452,
-   I386 = 332,
-   IA64 = 512,
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct InterfaceMapping {
    public MethodInfo[] InterfaceMethods;
    public MethodInfo[] TargetMethods;
    public Type InterfaceType;
    public Type TargetType;
  }
  public static class IntrospectionExtensions {
    public static TypeInfo GetTypeInfo(this Type type);
  }
  public class InvalidFilterCriteriaException : ApplicationExceptionException {
    ^ Pallavi Taneja: Used my Module and TYpe. Although Type.Filter* can't be exposed yet, we can expose Module.Filter* members.
    public InvalidFilterCriteriaException();
-   protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
  }
- public interface IReflect {
    ^ Pallavi Taneja: Exposed in S.R.IS as used with IDispatch.
-   Type UnderlyingSystemType { get; }
-   FieldInfo GetField(string name, BindingFlags bindingAttr);
-   FieldInfo[] GetFields(BindingFlags bindingAttr);
-   MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
-   MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   MethodInfo GetMethod(string name, BindingFlags bindingAttr);
-   MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
-   MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
-   PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
  }
  public interface IReflectableType {
    TypeInfo GetTypeInfo();
  }
  public class LocalVariableInfo {
    protected LocalVariableInfo();
    public virtual bool IsPinned { get; }
    public virtual int LocalIndex { get; }
    public virtual Type LocalType { get; }
    public override string ToString();
  }
  public class ManifestResourceInfo {
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    public virtual string FileName { get; }
    public virtual Assembly ReferencedAssembly { get; }
    public virtual ResourceLocation ResourceLocation { get; }
  }
  public delegate bool MemberFilter(MemberInfo m, object filterCriteria);
  public abstract class MemberInfo : _MemberInfo, ICustomAttributeProvider {
-   protected MemberInfo();
    public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
    public abstract Type DeclaringType { get; }
    public abstractvirtual MemberTypes MemberType { get; }
    public virtual int MetadataToken { get; }
    public virtual Module Module { get; }
    public abstract string Name { get; }
    public abstractvirtual Type ReflectedType { get; }
    ^ Pallavi Taneja: Some concerns around PN implementation.
    public override bool Equals(object obj);
-   public abstract object[] GetCustomAttributes(bool inherit);
    ^ Pallavi Taneja: Already exposed via extensions.
-   public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public virtual IList<CustomAttributeData> GetCustomAttributesData();
    public override int GetHashCode();
-   public abstract bool IsDefined(Type attributeType, bool inherit);
-   public static bool operator ==(MemberInfo left, MemberInfo right);
    ^ Pallavi Taneja: Operator overloads behave different than .Equals().
-   public static bool operator !=(MemberInfo left, MemberInfo right);
-   void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._MemberInfo.GetType();
-   void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._MemberInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
  public enum MemberTypes {
    All = 191,
    Constructor = 1,
    Custom = 64,
    Event = 2,
    Field = 4,
    Method = 8,
    NestedType = 128,
    Property = 16,
    TypeInfo = 32,
  }
  public enum MethodAttributes {
    Abstract = 1024,
    Assembly = 3,
    CheckAccessOnOverride = 512,
    FamANDAssem = 2,
    Family = 4,
    FamORAssem = 5,
    Final = 32,
    HasSecurity = 16384,
    HideBySig = 128,
    MemberAccessMask = 7,
    NewSlot = 256,
    PinvokeImpl = 8192,
    Private = 1,
    PrivateScope = 0,
    Public = 6,
    RequireSecObject = 32768,
-   ReservedMask = 53248,
    ReuseSlot = 0,
    RTSpecialName = 4096,
    SpecialName = 2048,
    Static = 16,
    UnmanagedExport = 8,
    Virtual = 64,
    VtableLayoutMask = 256,
  }
  public abstract class MethodBase : MemberInfo, _MethodBase {
-   protected MethodBase();
    public abstract MethodAttributes Attributes { get; }
    public virtual CallingConventions CallingConvention { get; }
    public virtual bool ContainsGenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public virtual bool IsGenericMethod { get; }
    public virtual bool IsGenericMethodDefinition { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
-   public virtual bool IsSecurityCritical { get; }
-   public virtual bool IsSecuritySafeCritical { get; }
-   public virtual bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public abstractvirtual RuntimeMethodHandle MethodHandle { get; }
    public virtualabstract MethodImplAttributes MethodImplementationFlags { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }
-   bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }
    public override bool Equals(object obj);
-   [MethodImpl(NoInlining)]public static MethodBase GetCurrentMethod();
    public virtual Type[] GetGenericArguments();
    public override int GetHashCode();
-   public virtual MethodBody GetMethodBody();
    ^ Pallavi Taneja: [Not sure] Used for IL inspection. Usage ~ 1%
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public abstractvirtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, object[] parameters);
-   public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
    ^ Pallavi Taneja: Dependency on System.Glob
-   public static bool operator ==(MethodBase left, MethodBase right);
-   public static bool operator !=(MethodBase left, MethodBase right);
-   void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._MethodBase.GetType();
-   void System.Runtime.InteropServices._MethodBase.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._MethodBase.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public class MethodBody {
    ^ Pallavi Taneja: [Not sure] IL inspection
-   protected MethodBody();
-   public virtual IList<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
-   public virtual bool InitLocals { get; }
-   public virtual int LocalSignatureMetadataToken { get; }
-   public virtual IList<LocalVariableInfo> LocalVariables { get; }
-   public virtual int MaxStackSize { get; }
-   public virtual byte[] GetILAsByteArray();
  }
  public enum MethodImplAttributes {
    AggressiveInlining = 256,
    CodeTypeMask = 3,
    ForwardRef = 16,
    IL = 0,
    InternalCall = 4096,
    Managed = 0,
    ManagedMask = 4,
-   MaxMethodImplVal = 65535,
    Native = 1,
    NoInlining = 8,
    NoOptimization = 64,
    OPTIL = 2,
    PreserveSig = 128,
    Runtime = 3,
    Synchronized = 32,
    Unmanaged = 4,
  }
  public abstract class MethodInfo : MethodBase, _MethodInfo {
-   protected MethodInfo();
    public override MemberTypes MemberType { get; }
    public virtual ParameterInfo ReturnParameter { get; }
    public virtual Type ReturnType { get; }
-   public abstract ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    ^ Pallavi Taneja: Issues with exposing ICustomAttributeProvider
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public override bool Equals(object obj);
    public abstractvirtual MethodInfo GetBaseDefinition();
    public override Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public override int GetHashCode();
    public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments);
-   public static bool operator ==(MethodInfo left, MethodInfo right);
-   public static bool operator !=(MethodInfo left, MethodInfo right);
-   void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._MethodInfo.GetType();
-   void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._MethodInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public sealed class Missing : ISerializable {
    ^ Pallavi Taneja: Interop sceanrio, used in IDispatch.
-   public static readonly Missing Value;
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public abstract class Module : _Module, ICustomAttributeProvider, ISerializable {
    public static readonly TypeFilter FilterTypeName;
    public static readonly TypeFilter FilterTypeNameIgnoreCase;
-   protected Module();
    public virtual Assembly Assembly { get; }
    public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
    public virtual string FullyQualifiedName { get; }
    public virtual int MDStreamVersion { get; }
    public virtual int MetadataToken { get; }
-   public ModuleHandle ModuleHandle { get; }
    ^ Pallavi Taneja: ModuleHandle is not exposed.
    public virtual Guid ModuleVersionId { get; }
    public virtual string Name { get; }
    public virtual string ScopeName { get; }
    public override bool Equals(object o);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
-   public virtual object[] GetCustomAttributes(bool inherit);
-   public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public virtual IList<CustomAttributeData> GetCustomAttributesData();
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public override int GetHashCode();
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, Type[] types);
-   protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual void GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine);
-   public virtual X509Certificate GetSignerCertificate();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
-   public virtual bool IsDefined(Type attributeType, bool inherit);
-   public virtual bool IsResource();
-   public static bool operator ==(Module left, Module right);
-   public static bool operator !=(Module left, Module right);
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
-   void System.Runtime.InteropServices._Module.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._Module.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._Module.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._Module.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public override string ToString();
  }
- public delegate Module ModuleResolveEventHandler(object sender, ResolveEventArgs e);
- public sealed class ObfuscateAssemblyAttribute : Attribute {
    ^ Pallavi Taneja: Not a reflection concept.
-   public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
-   public bool AssemblyIsPrivate { get; }
-   public bool StripAfterObfuscation { get; set; }
  }
- public sealed class ObfuscationAttribute : Attribute {
    ^ Pallavi Taneja: Same as above.s
-   public ObfuscationAttribute();
-   public bool ApplyToMembers { get; set; }
-   public bool Exclude { get; set; }
-   public string Feature { get; set; }
-   public bool StripAfterObfuscation { get; set; }
  }
  public enum ParameterAttributes {
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    In = 1,
    Lcid = 4,
    None = 0,
    Optional = 16,
    Out = 2,
-   Reserved3 = 16384,
-   Reserved4 = 32768,
-   ReservedMask = 61440,
    Retval = 8,
  }
  public class ParameterInfo : _ParameterInfo, ICustomAttributeProvider, IObjectReference {
-   protected int PositionImpl;
-   protected object DefaultValueImpl;
-   protected MemberInfo MemberImpl;
-   protected ParameterAttributes AttrsImpl;
-   protected string NameImpl;
-   protected Type ClassImpl;
-   protected ParameterInfo();
    public virtual ParameterAttributes Attributes { get; }
    public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
    public virtual object DefaultValue { get; }
    public virtual bool HasDefaultValue { get; }
    public bool IsIn { get; }
-   public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public virtual MemberInfo Member { get; }
    public virtual int MetadataToken { get; }
    public virtual string Name { get; }
    public virtual Type ParameterType { get; }
    public virtual int Position { get; }
    public virtual object RawDefaultValue { get; }
-   public virtual object[] GetCustomAttributes(bool inherit);
-   public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public virtual IList<CustomAttributeData> GetCustomAttributesData();
-   public virtual Type[] GetOptionalCustomModifiers();
-   public object GetRealObject(StreamingContext context);
-   public virtual Type[] GetRequiredCustomModifiers();
    ^ Pallavi Taneja: [Not sure] Compiler only scenario.
-   public virtual bool IsDefined(Type attributeType, bool inherit);
-   void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ParameterInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ParameterModifier {
    public ParameterModifier(int parameterCount);
    public bool this[int index] { get; set; }
  }
- public sealed class Pointer : ISerializable {
    ^ Pallavi Taneja: Interop scenario.
-   public unsafe static object Box(void* ptr, Type type);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public unsafe static void* Unbox(object ptr);
  }
- public enum PortableExecutableKinds {
-   ILOnly = 1,
-   NotAPortableExecutableImage = 0,
-   PE32Plus = 4,
-   Preferred32Bit = 16,
-   Required32Bit = 2,
-   Unmanaged32Bit = 8,
  }
  public enum ProcessorArchitecture {
    Amd64 = 4,
    Arm = 5,
    IA64 = 3,
    MSIL = 1,
    None = 0,
    X86 = 2,
  }
  public enum PropertyAttributes {
    HasDefault = 4096,
    None = 0,
-   Reserved2 = 8192,
-   Reserved3 = 16384,
-   Reserved4 = 32768,
-   ReservedMask = 62464,
    RTSpecialName = 1024,
    SpecialName = 512,
  }
  public abstract class PropertyInfo : MemberInfo, _PropertyInfo {
-   protected PropertyInfo();
    public abstract PropertyAttributes Attributes { get; }
    public abstract bool CanRead { get; }
    public abstract bool CanWrite { get; }
    public virtual MethodInfo GetMethod { get; }
    public bool IsSpecialName { get; }
    public override MemberTypes MemberType { get; }
    public abstract Type PropertyType { get; }
    public virtual MethodInfo SetMethod { get; }
    public override bool Equals(object obj);
    public MethodInfo[] GetAccessors();
    ^ Pallavi Taneja: Get* APIs exposed via TypeExtensions
    public abstractvirtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual object GetConstantValue();
    public MethodInfo GetGetMethod();
    public abstractvirtual MethodInfo GetGetMethod(bool nonPublic);
    public override int GetHashCode();
    public abstract ParameterInfo[] GetIndexParameters();
-   public virtual Type[] GetOptionalCustomModifiers();
    ^ Pallavi Taneja: Compiler only scenario.
-   public virtual object GetRawConstantValue();
-   public virtual Type[] GetRequiredCustomModifiers();
    public MethodInfo GetSetMethod();
    public abstractvirtual MethodInfo GetSetMethod(bool nonPublic);
    public object GetValue(object obj);
    public virtual object GetValue(object obj, object[] index);
-   public abstract object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
    ^ Pallavi Taneja: CultureInfo dependency.
-   public static bool operator ==(PropertyInfo left, PropertyInfo right);
-   public static bool operator !=(PropertyInfo left, PropertyInfo right);
    public void SetValue(object obj, object value);
    public virtual void SetValue(object obj, object value, object[] index);
-   public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
-   void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type System.Runtime.InteropServices._PropertyInfo.GetType();
-   void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._PropertyInfo.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
  public abstract class ReflectionContext {
    protected ReflectionContext();
    public virtual TypeInfo GetTypeForObject(object value);
    public abstract Assembly MapAssembly(Assembly assembly);
    public abstract TypeInfo MapType(TypeInfo type);
  }
  public sealed class ReflectionTypeLoadException : SystemExceptionException, ISerializable {
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    public Exception[] LoaderExceptions { get; }
    public Type[] Types { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public enum ResourceAttributes {
-   Private = 2,
-   Public = 1,
  }
  public enum ResourceLocation {
    ContainedInAnotherAssembly = 2,
    ContainedInManifestFile = 4,
    Embedded = 1,
  }
  public static class RuntimeReflectionExtensions {
    public static MethodInfo GetMethodInfo(this Delegate del);
    public static MethodInfo GetRuntimeBaseDefinition(this MethodInfo method);
    public static EventInfo GetRuntimeEvent(this Type type, string name);
    public static IEnumerable<EventInfo> GetRuntimeEvents(this Type type);
    public static FieldInfo GetRuntimeField(this Type type, string name);
    public static IEnumerable<FieldInfo> GetRuntimeFields(this Type type);
    public static InterfaceMapping GetRuntimeInterfaceMap(this TypeInfo typeInfo, Type interfaceType);
    public static MethodInfo GetRuntimeMethod(this Type type, string name, Type[] parameters);
    public static IEnumerable<MethodInfo> GetRuntimeMethods(this Type type);
    public static IEnumerable<PropertyInfo> GetRuntimeProperties(this Type type);
    public static PropertyInfo GetRuntimeProperty(this Type type, string name);
  }
- public class StrongNameKeyPair : IDeserializationCallback, ISerializable {
    ^ Pallavi Taneja: Is System.Reflection the right place for this?
-   public StrongNameKeyPair(byte[] keyPairArray);
-   public StrongNameKeyPair(FileStream keyPairFile);
-   protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
-   public StrongNameKeyPair(string keyPairContainer);
-   public byte[] PublicKey { get; }
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
  }
  public class TargetException : ApplicationExceptionException {
    public TargetException();
-   protected TargetException(SerializationInfo info, StreamingContext context);
    public TargetException(string message);
    public TargetException(string message, Exception inner);
  }
  public sealed class TargetInvocationException : ApplicationExceptionException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
  }
  public sealed class TargetParameterCountException : ApplicationExceptionException {
    public TargetParameterCountException();
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
  }
  public enum TypeAttributes {
    Abstract = 128,
    AnsiClass = 0,
    AutoClass = 131072,
    AutoLayout = 0,
    BeforeFieldInit = 1048576,
    Class = 0,
    ClassSemanticsMask = 32,
    CustomFormatClass = 196608,
    CustomFormatMask = 12582912,
    ExplicitLayout = 16,
    HasSecurity = 262144,
    Import = 4096,
    Interface = 32,
    LayoutMask = 24,
    NestedAssembly = 5,
    NestedFamANDAssem = 6,
    NestedFamily = 4,
    NestedFamORAssem = 7,
    NestedPrivate = 3,
    NestedPublic = 2,
    NotPublic = 0,
    Public = 1,
-   ReservedMask = 264192,
    RTSpecialName = 2048,
    Sealed = 256,
    SequentialLayout = 8,
    Serializable = 8192,
    SpecialName = 1024,
    StringFormatMask = 196608,
    UnicodeClass = 65536,
    VisibilityMask = 7,
    WindowsRuntime = 16384,
  }
- public class TypeDelegator : TypeInfo {
    ^ Pallavi Taneja: Used in extension scenarios.
-   protected Type typeImpl;
-   protected TypeDelegator();
-   public TypeDelegator(Type delegatingType);
-   public override Assembly Assembly { get; }
-   public override string AssemblyQualifiedName { get; }
-   public override Type BaseType { get; }
-   public override string FullName { get; }
-   public override Guid GUID { get; }
-   public override bool IsConstructedGenericType { get; }
-   public override int MetadataToken { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override string Namespace { get; }
-   public override RuntimeTypeHandle TypeHandle { get; }
-   public override Type UnderlyingSystemType { get; }
-   protected override TypeAttributes GetAttributeFlagsImpl();
-   protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override Type GetElementType();
-   public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   public override EventInfo[] GetEvents();
-   public override EventInfo[] GetEvents(BindingFlags bindingAttr);
-   public override FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public override FieldInfo[] GetFields(BindingFlags bindingAttr);
-   public override Type GetInterface(string name, bool ignoreCase);
-   public override InterfaceMapping GetInterfaceMap(Type interfaceType);
-   public override Type[] GetInterfaces();
-   public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   public override Type GetNestedType(string name, BindingFlags bindingAttr);
-   public override Type[] GetNestedTypes(BindingFlags bindingAttr);
-   public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   protected override bool HasElementTypeImpl();
-   public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   protected override bool IsArrayImpl();
-   public override bool IsAssignableFrom(TypeInfo typeInfo);
-   protected override bool IsByRefImpl();
-   protected override bool IsCOMObjectImpl();
-   public override bool IsDefined(Type attributeType, bool inherit);
-   protected override bool IsPointerImpl();
-   protected override bool IsPrimitiveImpl();
-   protected override bool IsValueTypeImpl();
  }
  public delegate bool TypeFilter(Type m, object filterCriteria);
  public abstract class TypeInfo : TypeMemberInfo, IReflectableType {
+   public abstract Assembly Assembly { get; }
+   public abstract string AssemblyQualifiedName { get; }
+   public abstract TypeAttributes Attributes { get; }
+   public abstract Type BaseType { get; }
+   public abstract bool ContainsGenericParameters { get; }
    public virtual IEnumerable<ConstructorInfo> DeclaredConstructors { get; }
    public virtual IEnumerable<EventInfo> DeclaredEvents { get; }
    public virtual IEnumerable<FieldInfo> DeclaredFields { get; }
    public virtual IEnumerable<MemberInfo> DeclaredMembers { get; }
    public virtual IEnumerable<MethodInfo> DeclaredMethods { get; }
    public virtual IEnumerable<TypeInfo> DeclaredNestedTypes { get; }
    public virtual IEnumerable<PropertyInfo> DeclaredProperties { get; }
+   public abstract MethodBase DeclaringMethod { get; }
+   public abstract string FullName { get; }
+   public abstract GenericParameterAttributes GenericParameterAttributes { get; }
+   public abstract int GenericParameterPosition { get; }
+   public abstract Type[] GenericTypeArguments { get; }
    public virtual Type[] GenericTypeParameters { get; }
+   public abstract Guid GUID { get; }
+   public bool HasElementType { get; }
    public virtual IEnumerable<Type> ImplementedInterfaces { get; }
+   public bool IsAbstract { get; }
+   public bool IsAnsiClass { get; }
+   public bool IsArray { get; }
+   public bool IsAutoClass { get; }
+   public bool IsAutoLayout { get; }
+   public bool IsByRef { get; }
+   public bool IsClass { get; }
+   public virtual bool IsCOMObject { get; }
+   public abstract bool IsEnum { get; }
+   public bool IsExplicitLayout { get; }
+   public abstract bool IsGenericParameter { get; }
+   public abstract bool IsGenericType { get; }
+   public abstract bool IsGenericTypeDefinition { get; }
+   public bool IsImport { get; }
+   public bool IsInterface { get; }
+   public bool IsLayoutSequential { get; }
+   public bool IsMarshalByRef { get; }
+   public bool IsNested { get; }
+   public bool IsNestedAssembly { get; }
+   public bool IsNestedFamANDAssem { get; }
+   public bool IsNestedFamily { get; }
+   public bool IsNestedFamORAssem { get; }
+   public bool IsNestedPrivate { get; }
+   public bool IsNestedPublic { get; }
+   public bool IsNotPublic { get; }
+   public bool IsPointer { get; }
+   public virtual bool IsPrimitive { get; }
+   public bool IsPublic { get; }
+   public bool IsSealed { get; }
+   public abstract bool IsSerializable { get; }
+   public bool IsSpecialName { get; }
+   public bool IsUnicodeClass { get; }
+   public virtual bool IsValueType { get; }
+   public bool IsVisible { get; }
+   public abstract string Namespace { get; }
+   public virtual StructLayoutAttribute StructLayoutAttribute { get; }
+   public ConstructorInfo TypeInitializer { get; }
+   public abstract Type UnderlyingSystemType { get; }
    public virtual Type AsType();
+   public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
+   public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
+   public abstract int GetArrayRank();
+   public ConstructorInfo GetConstructor(Type[] types);
+   public ConstructorInfo[] GetConstructors();
+   public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual IEnumerable<MethodInfo> GetDeclaredMethods(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
+   public virtual MemberInfo[] GetDefaultMembers();
+   public abstract Type GetElementType();
+   public virtual string GetEnumName(object value);
+   public virtual string[] GetEnumNames();
+   public virtual Type GetEnumUnderlyingType();
+   public virtual Array GetEnumValues();
+   public EventInfo GetEvent(string name);
+   public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);
+   public virtual EventInfo[] GetEvents();
+   public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);
+   public FieldInfo GetField(string name);
+   public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);
+   public FieldInfo[] GetFields();
+   public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);
+   public virtual Type[] GetGenericArguments();
+   public abstract Type[] GetGenericParameterConstraints();
+   public abstract Type GetGenericTypeDefinition();
+   public Type GetInterface(string name);
+   public abstract Type GetInterface(string name, bool ignoreCase);
+   public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
+   public abstract Type[] GetInterfaces();
+   public MemberInfo[] GetMember(string name);
+   public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
+   public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+   public MemberInfo[] GetMembers();
+   public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);
+   public MethodInfo GetMethod(string name);
+   public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
+   public MethodInfo GetMethod(string name, Type[] types);
+   public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
+   public MethodInfo[] GetMethods();
+   public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);
+   public Type GetNestedType(string name);
+   public abstract Type GetNestedType(string name, BindingFlags bindingAttr);
+   public Type[] GetNestedTypes();
+   public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);
+   public PropertyInfo[] GetProperties();
+   public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+   public PropertyInfo GetProperty(string name);
+   public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
+   public PropertyInfo GetProperty(string name, Type returnType);
+   public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
+   public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
+   public PropertyInfo GetProperty(string name, Type[] types);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
+   public virtual bool IsAssignableFrom(Type c);
+   public abstract bool IsDefined(Type attributeType, bool inherit);
+   public virtual bool IsEnumDefined(object value);
+   public virtual bool IsEquivalentTo(Type other);
+   public virtual bool IsInstanceOfType(object o);
+   public virtual bool IsSubclassOf(Type c);
+   public abstract Type MakeArrayType();
+   public abstract Type MakeArrayType(int rank);
+   public abstract Type MakeByRefType();
+   public abstract Type MakeGenericType(params Type[] typeArguments);
+   public abstract Type MakePointerType();
    TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
  }
 }
 namespace System.Reflection.Emit {
- public sealed class AssemblyBuilder : Assembly, _AssemblyBuilder {
-   public override string CodeBase { get; }
-   public override MethodInfo EntryPoint { get; }
-   public override Evidence Evidence { get; }
-   public override string FullName { get; }
-   public override bool GlobalAssemblyCache { get; }
-   public override long HostContext { get; }
-   public override string ImageRuntimeVersion { get; }
-   public override bool IsDynamic { get; }
-   public override string Location { get; }
-   public override Module ManifestModule { get; }
-   public override PermissionSet PermissionSet { get; }
-   public override bool ReflectionOnly { get; }
-   public override SecurityRuleSet SecurityRuleSet { get; }
-   public void AddResourceFile(string name, string fileName);
-   public void AddResourceFile(string name, string fileName, ResourceAttributes attribute);
-   [MethodImpl(NoInlining)]public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
-   [MethodImpl(NoInlining)]public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
-   [MethodImpl(NoInlining)]public ModuleBuilder DefineDynamicModule(string name);
-   [MethodImpl(NoInlining)]public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
-   [MethodImpl(NoInlining)]public ModuleBuilder DefineDynamicModule(string name, string fileName);
-   [MethodImpl(NoInlining)]public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo);
-   public IResourceWriter DefineResource(string name, string description, string fileName);
-   public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute);
-   public void DefineUnmanagedResource(byte[] resource);
-   public void DefineUnmanagedResource(string resourceFileName);
-   public void DefineVersionInfoResource();
-   public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark);
-   public override bool Equals(object obj);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override IList<CustomAttributeData> GetCustomAttributesData();
-   public ModuleBuilder GetDynamicModule(string name);
-   public override Type[] GetExportedTypes();
-   public override FileStream GetFile(string name);
-   public override FileStream[] GetFiles(bool getResourceModules);
-   public override int GetHashCode();
-   public override Module[] GetLoadedModules(bool getResourceModules);
-   public override ManifestResourceInfo GetManifestResourceInfo(string resourceName);
-   public override string[] GetManifestResourceNames();
-   public override Stream GetManifestResourceStream(string name);
-   public override Stream GetManifestResourceStream(Type type, string name);
-   public override Module GetModule(string name);
-   public override Module[] GetModules(bool getResourceModules);
-   public override AssemblyName GetName(bool copiedName);
-   public override AssemblyName[] GetReferencedAssemblies();
-   [MethodImpl(NoInlining)]public override Assembly GetSatelliteAssembly(CultureInfo culture);
-   [MethodImpl(NoInlining)]public override Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
-   public override Type GetType(string name, bool throwOnError, bool ignoreCase);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public void Save(string assemblyFileName);
-   public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetEntryPoint(MethodInfo entryMethod);
-   public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind);
-   void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._AssemblyBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public enum AssemblyBuilderAccess {
-   ReflectionOnly = 6,
-   Run = 1,
-   RunAndCollect = 9,
-   RunAndSave = 3,
-   Save = 2,
  }
- public sealed class ConstructorBuilder : ConstructorInfo, _ConstructorBuilder {
-   public override MethodAttributes Attributes { get; }
-   public override CallingConventions CallingConvention { get; }
-   public override Type DeclaringType { get; }
-   public bool InitLocals { get; set; }
-   public override RuntimeMethodHandle MethodHandle { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override Type ReflectedType { get; }
-   public Type ReturnType { get; }
-   public string Signature { get; }
-   public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
-   public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public ILGenerator GetILGenerator();
-   public ILGenerator GetILGenerator(int streamSize);
-   public override MethodImplAttributes GetMethodImplementationFlags();
-   public Module GetModule();
-   public override ParameterInfo[] GetParameters();
-   public MethodToken GetToken();
-   public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   public override object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetImplementationFlags(MethodImplAttributes attributes);
-   public void SetMethodBody(byte[] il, int maxStack, byte[] localSignature, IEnumerable<ExceptionHandler> exceptionHandlers, IEnumerable<int> tokenFixups);
-   public void SetSymCustomAttribute(string name, byte[] data);
-   void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ConstructorBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
  }
- public class CustomAttributeBuilder : _CustomAttributeBuilder {
-   public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs);
-   public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, FieldInfo[] namedFields, object[] fieldValues);
-   public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues);
-   public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues);
-   void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public class DynamicILInfo {
-   public DynamicMethod DynamicMethod { get; }
-   public int GetTokenFor(byte[] signature);
-   public int GetTokenFor(DynamicMethod method);
-   public int GetTokenFor(RuntimeFieldHandle field);
-   public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
-   public int GetTokenFor(RuntimeMethodHandle method);
-   public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
-   public int GetTokenFor(RuntimeTypeHandle type);
-   public int GetTokenFor(string literal);
-   public unsafe void SetCode(byte* code, int codeSize, int maxStackSize);
-   public void SetCode(byte[] code, int maxStackSize);
-   public unsafe void SetExceptions(byte* exceptions, int exceptionsSize);
-   public void SetExceptions(byte[] exceptions);
-   public unsafe void SetLocalSignature(byte* localSignature, int signatureSize);
-   public void SetLocalSignature(byte[] localSignature);
  }
- public sealed class DynamicMethod : MethodInfo {
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
-   [MethodImpl(NoInlining)]public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
-   public override MethodAttributes Attributes { get; }
-   public override CallingConventions CallingConvention { get; }
-   public override Type DeclaringType { get; }
-   public bool InitLocals { get; set; }
-   public override bool IsSecurityCritical { get; }
-   public override bool IsSecuritySafeCritical { get; }
-   public override bool IsSecurityTransparent { get; }
-   public override RuntimeMethodHandle MethodHandle { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override Type ReflectedType { get; }
-   public override ParameterInfo ReturnParameter { get; }
-   public override Type ReturnType { get; }
-   public override ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
-   public sealed override Delegate CreateDelegate(Type delegateType);
-   public sealed override Delegate CreateDelegate(Type delegateType, object target);
-   public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
-   public override MethodInfo GetBaseDefinition();
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public DynamicILInfo GetDynamicILInfo();
-   public ILGenerator GetILGenerator();
-   public ILGenerator GetILGenerator(int streamSize);
-   public override MethodImplAttributes GetMethodImplementationFlags();
-   public override ParameterInfo[] GetParameters();
-   public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public override string ToString();
  }
- public sealed class EnumBuilder : TypeInfo, _EnumBuilder {
-   public override Assembly Assembly { get; }
-   public override string AssemblyQualifiedName { get; }
-   public override Type BaseType { get; }
-   public override Type DeclaringType { get; }
-   public override string FullName { get; }
-   public override Guid GUID { get; }
-   public override bool IsConstructedGenericType { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override string Namespace { get; }
-   public override Type ReflectedType { get; }
-   public override RuntimeTypeHandle TypeHandle { get; }
-   public TypeToken TypeToken { get; }
-   public FieldBuilder UnderlyingField { get; }
-   public override Type UnderlyingSystemType { get; }
-   public Type CreateType();
-   public TypeInfo CreateTypeInfo();
-   public FieldBuilder DefineLiteral(string literalName, object literalValue);
-   protected override TypeAttributes GetAttributeFlagsImpl();
-   protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override Type GetElementType();
-   public override Type GetEnumUnderlyingType();
-   public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   public override EventInfo[] GetEvents();
-   public override EventInfo[] GetEvents(BindingFlags bindingAttr);
-   public override FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public override FieldInfo[] GetFields(BindingFlags bindingAttr);
-   public override Type GetInterface(string name, bool ignoreCase);
-   public override InterfaceMapping GetInterfaceMap(Type interfaceType);
-   public override Type[] GetInterfaces();
-   public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   public override Type GetNestedType(string name, BindingFlags bindingAttr);
-   public override Type[] GetNestedTypes(BindingFlags bindingAttr);
-   public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   protected override bool HasElementTypeImpl();
-   public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   protected override bool IsArrayImpl();
-   public override bool IsAssignableFrom(TypeInfo typeInfo);
-   protected override bool IsByRefImpl();
-   protected override bool IsCOMObjectImpl();
-   public override bool IsDefined(Type attributeType, bool inherit);
-   protected override bool IsPointerImpl();
-   protected override bool IsPrimitiveImpl();
-   protected override bool IsValueTypeImpl();
-   public override Type MakeArrayType();
-   public override Type MakeArrayType(int rank);
-   public override Type MakeByRefType();
-   public override Type MakePointerType();
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._EnumBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public sealed class EventBuilder : _EventBuilder {
-   public void AddOtherMethod(MethodBuilder mdBuilder);
-   public EventToken GetEventToken();
-   public void SetAddOnMethod(MethodBuilder mdBuilder);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetRaiseMethod(MethodBuilder mdBuilder);
-   public void SetRemoveOnMethod(MethodBuilder mdBuilder);
-   void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._EventBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct EventToken {
-   public static readonly EventToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(EventToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(EventToken a, EventToken b);
-   public static bool operator !=(EventToken a, EventToken b);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ExceptionHandler : IEquatable<ExceptionHandler> {
-   public ExceptionHandler(int tryOffset, int tryLength, int filterOffset, int handlerOffset, int handlerLength, ExceptionHandlingClauseOptions kind, int exceptionTypeToken);
-   public int ExceptionTypeToken { get; }
-   public int FilterOffset { get; }
-   public int HandlerLength { get; }
-   public int HandlerOffset { get; }
-   public ExceptionHandlingClauseOptions Kind { get; }
-   public int TryLength { get; }
-   public int TryOffset { get; }
-   public override bool Equals(object obj);
-   public bool Equals(ExceptionHandler other);
-   public override int GetHashCode();
-   public static bool operator ==(ExceptionHandler left, ExceptionHandler right);
-   public static bool operator !=(ExceptionHandler left, ExceptionHandler right);
  }
- public sealed class FieldBuilder : FieldInfo, _FieldBuilder {
-   public override FieldAttributes Attributes { get; }
-   public override Type DeclaringType { get; }
-   public override RuntimeFieldHandle FieldHandle { get; }
-   public override Type FieldType { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override Type ReflectedType { get; }
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public FieldToken GetToken();
-   public override object GetValue(object obj);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public void SetConstant(object defaultValue);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
-   public void SetOffset(int iOffset);
-   public override void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
-   void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._FieldBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct FieldToken {
-   public static readonly FieldToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(FieldToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(FieldToken a, FieldToken b);
-   public static bool operator !=(FieldToken a, FieldToken b);
  }
  public enum FlowControl {
    Branch = 0,
    Break = 1,
    Call = 2,
    Cond_Branch = 3,
    Meta = 4,
    Next = 5,
-   Phi = 6,
    Return = 7,
    Throw = 8,
  }
- public sealed class GenericTypeParameterBuilder : TypeInfo {
-   public override Assembly Assembly { get; }
-   public override string AssemblyQualifiedName { get; }
-   public override Type BaseType { get; }
-   public override bool ContainsGenericParameters { get; }
-   public override MethodBase DeclaringMethod { get; }
-   public override Type DeclaringType { get; }
-   public override string FullName { get; }
-   public override GenericParameterAttributes GenericParameterAttributes { get; }
-   public override int GenericParameterPosition { get; }
-   public override Guid GUID { get; }
-   public override bool IsConstructedGenericType { get; }
-   public override bool IsGenericParameter { get; }
-   public override bool IsGenericType { get; }
-   public override bool IsGenericTypeDefinition { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override string Namespace { get; }
-   public override Type ReflectedType { get; }
-   public override RuntimeTypeHandle TypeHandle { get; }
-   public override Type UnderlyingSystemType { get; }
-   public override bool Equals(object o);
-   protected override TypeAttributes GetAttributeFlagsImpl();
-   protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override Type GetElementType();
-   public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   public override EventInfo[] GetEvents();
-   public override EventInfo[] GetEvents(BindingFlags bindingAttr);
-   public override FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public override FieldInfo[] GetFields(BindingFlags bindingAttr);
-   public override Type[] GetGenericArguments();
-   public override Type GetGenericTypeDefinition();
-   public override int GetHashCode();
-   public override Type GetInterface(string name, bool ignoreCase);
-   public override InterfaceMapping GetInterfaceMap(Type interfaceType);
-   public override Type[] GetInterfaces();
-   public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   public override Type GetNestedType(string name, BindingFlags bindingAttr);
-   public override Type[] GetNestedTypes(BindingFlags bindingAttr);
-   public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   protected override bool HasElementTypeImpl();
-   public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   protected override bool IsArrayImpl();
-   public override bool IsAssignableFrom(TypeInfo typeInfo);
-   public override bool IsAssignableFrom(Type c);
-   protected override bool IsByRefImpl();
-   protected override bool IsCOMObjectImpl();
-   public override bool IsDefined(Type attributeType, bool inherit);
-   protected override bool IsPointerImpl();
-   protected override bool IsPrimitiveImpl();
-   public override bool IsSubclassOf(Type c);
-   protected override bool IsValueTypeImpl();
-   public override Type MakeArrayType();
-   public override Type MakeArrayType(int rank);
-   public override Type MakeByRefType();
-   public override Type MakeGenericType(params Type[] typeArguments);
-   public override Type MakePointerType();
-   public void SetBaseTypeConstraint(Type baseTypeConstraint);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
-   public void SetInterfaceConstraints(params Type[] interfaceConstraints);
-   public override string ToString();
  }
- public class ILGenerator : _ILGenerator {
-   public virtual int ILOffset { get; }
-   public virtual void BeginCatchBlock(Type exceptionType);
-   public virtual void BeginExceptFilterBlock();
-   public virtual Label BeginExceptionBlock();
-   public virtual void BeginFaultBlock();
-   public virtual void BeginFinallyBlock();
-   public virtual void BeginScope();
-   public virtual LocalBuilder DeclareLocal(Type localType);
-   public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
-   public virtual Label DefineLabel();
-   public virtual void Emit(OpCode opcode);
-   public virtual void Emit(OpCode opcode, byte arg);
-   public virtual void Emit(OpCode opcode, double arg);
-   public virtual void Emit(OpCode opcode, short arg);
-   public virtual void Emit(OpCode opcode, int arg);
-   public virtual void Emit(OpCode opcode, long arg);
-   public virtual void Emit(OpCode opcode, ConstructorInfo con);
-   public virtual void Emit(OpCode opcode, Label label);
-   public virtual void Emit(OpCode opcode, Label[] labels);
-   public virtual void Emit(OpCode opcode, LocalBuilder local);
-   public virtual void Emit(OpCode opcode, SignatureHelper signature);
-   public virtual void Emit(OpCode opcode, FieldInfo field);
-   public virtual void Emit(OpCode opcode, MethodInfo meth);
-   public void Emit(OpCode opcode, sbyte arg);
-   public virtual void Emit(OpCode opcode, float arg);
-   public virtual void Emit(OpCode opcode, string str);
-   public virtual void Emit(OpCode opcode, Type cls);
-   public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
-   public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
-   public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
-   public virtual void EmitWriteLine(LocalBuilder localBuilder);
-   public virtual void EmitWriteLine(FieldInfo fld);
-   public virtual void EmitWriteLine(string value);
-   public virtual void EndExceptionBlock();
-   public virtual void EndScope();
-   public virtual void MarkLabel(Label loc);
-   public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
-   void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ILGenerator.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public virtual void ThrowException(Type excType);
-   public virtual void UsingNamespace(string usingNamespace);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct Label {
-   public override bool Equals(object obj);
-   public bool Equals(Label obj);
-   public override int GetHashCode();
-   public static bool operator ==(Label a, Label b);
-   public static bool operator !=(Label a, Label b);
  }
- public sealed class LocalBuilder : LocalVariableInfo, _LocalBuilder {
-   public override bool IsPinned { get; }
-   public override int LocalIndex { get; }
-   public override Type LocalType { get; }
-   public void SetLocalSymInfo(string name);
-   public void SetLocalSymInfo(string name, int startOffset, int endOffset);
-   void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._LocalBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public sealed class MethodBuilder : MethodInfo, _MethodBuilder {
-   public override MethodAttributes Attributes { get; }
-   public override CallingConventions CallingConvention { get; }
-   public override bool ContainsGenericParameters { get; }
-   public override Type DeclaringType { get; }
-   public bool InitLocals { get; set; }
-   public override bool IsGenericMethod { get; }
-   public override bool IsGenericMethodDefinition { get; }
-   public override bool IsSecurityCritical { get; }
-   public override bool IsSecuritySafeCritical { get; }
-   public override bool IsSecurityTransparent { get; }
-   public override RuntimeMethodHandle MethodHandle { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override Type ReflectedType { get; }
-   public override ParameterInfo ReturnParameter { get; }
-   public override Type ReturnType { get; }
-   public override ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
-   public string Signature { get; }
-   public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
-   public void CreateMethodBody(byte[] il, int count);
-   public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names);
-   public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
-   public override bool Equals(object obj);
-   public override MethodInfo GetBaseDefinition();
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override Type[] GetGenericArguments();
-   public override MethodInfo GetGenericMethodDefinition();
-   public override int GetHashCode();
-   public ILGenerator GetILGenerator();
-   public ILGenerator GetILGenerator(int size);
-   public override MethodImplAttributes GetMethodImplementationFlags();
-   public Module GetModule();
-   public override ParameterInfo[] GetParameters();
-   public MethodToken GetToken();
-   public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public override MethodInfo MakeGenericMethod(params Type[] typeArguments);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetImplementationFlags(MethodImplAttributes attributes);
-   public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
-   public void SetMethodBody(byte[] il, int maxStack, byte[] localSignature, IEnumerable<ExceptionHandler> exceptionHandlers, IEnumerable<int> tokenFixups);
-   public void SetParameters(params Type[] parameterTypes);
-   public void SetReturnType(Type returnType);
-   public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
-   public void SetSymCustomAttribute(string name, byte[] data);
-   void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._MethodBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
  }
- public sealed class MethodRental : _MethodRental {
-   public const int JitImmediate = 1;
-   public const int JitOnDemand = 0;
-   [MethodImpl(NoInlining)]public static void SwapMethodBody(Type cls, int methodtoken, IntPtr rgIL, int methodSize, int flags);
-   void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._MethodRental.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._MethodRental.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct MethodToken {
-   public static readonly MethodToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(MethodToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(MethodToken a, MethodToken b);
-   public static bool operator !=(MethodToken a, MethodToken b);
  }
- public class ModuleBuilder : Module, _ModuleBuilder {
-   public override Assembly Assembly { get; }
-   public override string FullyQualifiedName { get; }
-   public override int MDStreamVersion { get; }
-   public override int MetadataToken { get; }
-   public override Guid ModuleVersionId { get; }
-   public override string Name { get; }
-   public override string ScopeName { get; }
-   public void CreateGlobalFunctions();
-   public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
-   public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
-   public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
-   public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
-   public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
-   public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes);
-   public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute);
-   public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
-   public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
-   public IResourceWriter DefineResource(string name, string description);
-   public IResourceWriter DefineResource(string name, string description, ResourceAttributes attribute);
-   public TypeBuilder DefineType(string name);
-   public TypeBuilder DefineType(string name, TypeAttributes attr);
-   public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
-   public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
-   public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
-   public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
-   public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
-   public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
-   public void DefineUnmanagedResource(byte[] resource);
-   public void DefineUnmanagedResource(string resourceFileName);
-   public override bool Equals(object obj);
-   public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
-   public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
-   public MethodToken GetConstructorToken(ConstructorInfo con);
-   public MethodToken GetConstructorToken(ConstructorInfo constructor, IEnumerable<Type> optionalParameterTypes);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override IList<CustomAttributeData> GetCustomAttributesData();
-   public override FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public override FieldInfo[] GetFields(BindingFlags bindingFlags);
-   public FieldToken GetFieldToken(FieldInfo field);
-   public override int GetHashCode();
-   protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override MethodInfo[] GetMethods(BindingFlags bindingFlags);
-   public MethodToken GetMethodToken(MethodInfo method);
-   public MethodToken GetMethodToken(MethodInfo method, IEnumerable<Type> optionalParameterTypes);
-   public override void GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine);
-   public SignatureToken GetSignatureToken(byte[] sigBytes, int sigLength);
-   public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
-   public override X509Certificate GetSignerCertificate();
-   public StringToken GetStringConstant(string str);
-   public ISymbolWriter GetSymWriter();
-   public override Type GetType(string className);
-   public override Type GetType(string className, bool ignoreCase);
-   public override Type GetType(string className, bool throwOnError, bool ignoreCase);
-   public override Type[] GetTypes();
-   public TypeToken GetTypeToken(string name);
-   public TypeToken GetTypeToken(Type type);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public override bool IsResource();
-   public bool IsTransient();
-   public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
-   public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
-   public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
-   public override byte[] ResolveSignature(int metadataToken);
-   public override string ResolveString(int metadataToken);
-   public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetSymCustomAttribute(string name, byte[] data);
-   public void SetUserEntryPoint(MethodInfo entryPoint);
-   void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ModuleBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct OpCode {
    public FlowControl FlowControl { get; }
    public string Name { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public int Size { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public short Value { get; }
    public override bool Equals(object obj);
    public bool Equals(OpCode obj);
    public override int GetHashCode();
    public static bool operator ==(OpCode a, OpCode b);
    public static bool operator !=(OpCode a, OpCode b);
    public override string ToString();
  }
  public class OpCodes {
    public static readonly OpCode Add;
    public static readonly OpCode Add_Ovf;
    public static readonly OpCode Add_Ovf_Un;
    public static readonly OpCode And;
    public static readonly OpCode Arglist;
    public static readonly OpCode Beq;
    public static readonly OpCode Beq_S;
    public static readonly OpCode Bge;
    public static readonly OpCode Bge_S;
    public static readonly OpCode Bge_Un;
    public static readonly OpCode Bge_Un_S;
    public static readonly OpCode Bgt;
    public static readonly OpCode Bgt_S;
    public static readonly OpCode Bgt_Un;
    public static readonly OpCode Bgt_Un_S;
    public static readonly OpCode Ble;
    public static readonly OpCode Ble_S;
    public static readonly OpCode Ble_Un;
    public static readonly OpCode Ble_Un_S;
    public static readonly OpCode Blt;
    public static readonly OpCode Blt_S;
    public static readonly OpCode Blt_Un;
    public static readonly OpCode Blt_Un_S;
    public static readonly OpCode Bne_Un;
    public static readonly OpCode Bne_Un_S;
    public static readonly OpCode Box;
    public static readonly OpCode Br;
    public static readonly OpCode Br_S;
    public static readonly OpCode Break;
    public static readonly OpCode Brfalse;
    public static readonly OpCode Brfalse_S;
    public static readonly OpCode Brtrue;
    public static readonly OpCode Brtrue_S;
    public static readonly OpCode Call;
    public static readonly OpCode Calli;
    public static readonly OpCode Callvirt;
    public static readonly OpCode Castclass;
    public static readonly OpCode Ceq;
    public static readonly OpCode Cgt;
    public static readonly OpCode Cgt_Un;
    public static readonly OpCode Ckfinite;
    public static readonly OpCode Clt;
    public static readonly OpCode Clt_Un;
    public static readonly OpCode Constrained;
    public static readonly OpCode Conv_I;
    public static readonly OpCode Conv_I1;
    public static readonly OpCode Conv_I2;
    public static readonly OpCode Conv_I4;
    public static readonly OpCode Conv_I8;
    public static readonly OpCode Conv_Ovf_I;
    public static readonly OpCode Conv_Ovf_I_Un;
    public static readonly OpCode Conv_Ovf_I1;
    public static readonly OpCode Conv_Ovf_I1_Un;
    public static readonly OpCode Conv_Ovf_I2;
    public static readonly OpCode Conv_Ovf_I2_Un;
    public static readonly OpCode Conv_Ovf_I4;
    public static readonly OpCode Conv_Ovf_I4_Un;
    public static readonly OpCode Conv_Ovf_I8;
    public static readonly OpCode Conv_Ovf_I8_Un;
    public static readonly OpCode Conv_Ovf_U;
    public static readonly OpCode Conv_Ovf_U_Un;
    public static readonly OpCode Conv_Ovf_U1;
    public static readonly OpCode Conv_Ovf_U1_Un;
    public static readonly OpCode Conv_Ovf_U2;
    public static readonly OpCode Conv_Ovf_U2_Un;
    public static readonly OpCode Conv_Ovf_U4;
    public static readonly OpCode Conv_Ovf_U4_Un;
    public static readonly OpCode Conv_Ovf_U8;
    public static readonly OpCode Conv_Ovf_U8_Un;
    public static readonly OpCode Conv_R_Un;
    public static readonly OpCode Conv_R4;
    public static readonly OpCode Conv_R8;
    public static readonly OpCode Conv_U;
    public static readonly OpCode Conv_U1;
    public static readonly OpCode Conv_U2;
    public static readonly OpCode Conv_U4;
    public static readonly OpCode Conv_U8;
    public static readonly OpCode Cpblk;
    public static readonly OpCode Cpobj;
    public static readonly OpCode Div;
    public static readonly OpCode Div_Un;
    public static readonly OpCode Dup;
    public static readonly OpCode Endfilter;
    public static readonly OpCode Endfinally;
    public static readonly OpCode Initblk;
    public static readonly OpCode Initobj;
    public static readonly OpCode Isinst;
    public static readonly OpCode Jmp;
    public static readonly OpCode Ldarg;
    public static readonly OpCode Ldarg_0;
    public static readonly OpCode Ldarg_1;
    public static readonly OpCode Ldarg_2;
    public static readonly OpCode Ldarg_3;
    public static readonly OpCode Ldarg_S;
    public static readonly OpCode Ldarga;
    public static readonly OpCode Ldarga_S;
    public static readonly OpCode Ldc_I4;
    public static readonly OpCode Ldc_I4_0;
    public static readonly OpCode Ldc_I4_1;
    public static readonly OpCode Ldc_I4_2;
    public static readonly OpCode Ldc_I4_3;
    public static readonly OpCode Ldc_I4_4;
    public static readonly OpCode Ldc_I4_5;
    public static readonly OpCode Ldc_I4_6;
    public static readonly OpCode Ldc_I4_7;
    public static readonly OpCode Ldc_I4_8;
    public static readonly OpCode Ldc_I4_M1;
    public static readonly OpCode Ldc_I4_S;
    public static readonly OpCode Ldc_I8;
    public static readonly OpCode Ldc_R4;
    public static readonly OpCode Ldc_R8;
    public static readonly OpCode Ldelem;
    public static readonly OpCode Ldelem_I;
    public static readonly OpCode Ldelem_I1;
    public static readonly OpCode Ldelem_I2;
    public static readonly OpCode Ldelem_I4;
    public static readonly OpCode Ldelem_I8;
    public static readonly OpCode Ldelem_R4;
    public static readonly OpCode Ldelem_R8;
    public static readonly OpCode Ldelem_Ref;
    public static readonly OpCode Ldelem_U1;
    public static readonly OpCode Ldelem_U2;
    public static readonly OpCode Ldelem_U4;
    public static readonly OpCode Ldelema;
    public static readonly OpCode Ldfld;
    public static readonly OpCode Ldflda;
    public static readonly OpCode Ldftn;
    public static readonly OpCode Ldind_I;
    public static readonly OpCode Ldind_I1;
    public static readonly OpCode Ldind_I2;
    public static readonly OpCode Ldind_I4;
    public static readonly OpCode Ldind_I8;
    public static readonly OpCode Ldind_R4;
    public static readonly OpCode Ldind_R8;
    public static readonly OpCode Ldind_Ref;
    public static readonly OpCode Ldind_U1;
    public static readonly OpCode Ldind_U2;
    public static readonly OpCode Ldind_U4;
    public static readonly OpCode Ldlen;
    public static readonly OpCode Ldloc;
    public static readonly OpCode Ldloc_0;
    public static readonly OpCode Ldloc_1;
    public static readonly OpCode Ldloc_2;
    public static readonly OpCode Ldloc_3;
    public static readonly OpCode Ldloc_S;
    public static readonly OpCode Ldloca;
    public static readonly OpCode Ldloca_S;
    public static readonly OpCode Ldnull;
    public static readonly OpCode Ldobj;
    public static readonly OpCode Ldsfld;
    public static readonly OpCode Ldsflda;
    public static readonly OpCode Ldstr;
    public static readonly OpCode Ldtoken;
    public static readonly OpCode Ldvirtftn;
    public static readonly OpCode Leave;
    public static readonly OpCode Leave_S;
    public static readonly OpCode Localloc;
    public static readonly OpCode Mkrefany;
    public static readonly OpCode Mul;
    public static readonly OpCode Mul_Ovf;
    public static readonly OpCode Mul_Ovf_Un;
    public static readonly OpCode Neg;
    public static readonly OpCode Newarr;
    public static readonly OpCode Newobj;
    public static readonly OpCode Nop;
    public static readonly OpCode Not;
    public static readonly OpCode Or;
    public static readonly OpCode Pop;
    public static readonly OpCode Prefix1;
    public static readonly OpCode Prefix2;
    public static readonly OpCode Prefix3;
    public static readonly OpCode Prefix4;
    public static readonly OpCode Prefix5;
    public static readonly OpCode Prefix6;
    public static readonly OpCode Prefix7;
    public static readonly OpCode Prefixref;
    public static readonly OpCode Readonly;
    public static readonly OpCode Refanytype;
    public static readonly OpCode Refanyval;
    public static readonly OpCode Rem;
    public static readonly OpCode Rem_Un;
    public static readonly OpCode Ret;
    public static readonly OpCode Rethrow;
    public static readonly OpCode Shl;
    public static readonly OpCode Shr;
    public static readonly OpCode Shr_Un;
    public static readonly OpCode Sizeof;
    public static readonly OpCode Starg;
    public static readonly OpCode Starg_S;
    public static readonly OpCode Stelem;
    public static readonly OpCode Stelem_I;
    public static readonly OpCode Stelem_I1;
    public static readonly OpCode Stelem_I2;
    public static readonly OpCode Stelem_I4;
    public static readonly OpCode Stelem_I8;
    public static readonly OpCode Stelem_R4;
    public static readonly OpCode Stelem_R8;
    public static readonly OpCode Stelem_Ref;
    public static readonly OpCode Stfld;
    public static readonly OpCode Stind_I;
    public static readonly OpCode Stind_I1;
    public static readonly OpCode Stind_I2;
    public static readonly OpCode Stind_I4;
    public static readonly OpCode Stind_I8;
    public static readonly OpCode Stind_R4;
    public static readonly OpCode Stind_R8;
    public static readonly OpCode Stind_Ref;
    public static readonly OpCode Stloc;
    public static readonly OpCode Stloc_0;
    public static readonly OpCode Stloc_1;
    public static readonly OpCode Stloc_2;
    public static readonly OpCode Stloc_3;
    public static readonly OpCode Stloc_S;
    public static readonly OpCode Stobj;
    public static readonly OpCode Stsfld;
    public static readonly OpCode Sub;
    public static readonly OpCode Sub_Ovf;
    public static readonly OpCode Sub_Ovf_Un;
    public static readonly OpCode Switch;
    public static readonly OpCode Tailcall;
    public static readonly OpCode Throw;
    public static readonly OpCode Unaligned;
    public static readonly OpCode Unbox;
    public static readonly OpCode Unbox_Any;
    public static readonly OpCode Volatile;
    public static readonly OpCode Xor;
    public static bool TakesSingleByteArgument(OpCode inst);
  }
  public enum OpCodeType {
-   Annotation = 0,
    Macro = 1,
    Nternal = 2,
    Objmodel = 3,
    Prefix = 4,
    Primitive = 5,
  }
  public enum OperandType {
    InlineBrTarget = 0,
    InlineField = 1,
    InlineI = 2,
    InlineI8 = 3,
    InlineMethod = 4,
    InlineNone = 5,
-   InlinePhi = 6,
    InlineR = 7,
    InlineSig = 9,
    InlineString = 10,
    InlineSwitch = 11,
    InlineTok = 12,
    InlineType = 13,
    InlineVar = 14,
    ShortInlineBrTarget = 15,
    ShortInlineI = 16,
    ShortInlineR = 17,
    ShortInlineVar = 18,
  }
  public enum PackingSize {
    Size1 = 1,
    Size128 = 128,
    Size16 = 16,
    Size2 = 2,
    Size32 = 32,
    Size4 = 4,
    Size64 = 64,
    Size8 = 8,
    Unspecified = 0,
  }
- public class ParameterBuilder : _ParameterBuilder {
-   public virtual int Attributes { get; }
-   public bool IsIn { get; }
-   public bool IsOptional { get; }
-   public bool IsOut { get; }
-   public virtual string Name { get; }
-   public virtual int Position { get; }
-   public virtual ParameterToken GetToken();
-   public virtual void SetConstant(object defaultValue);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public virtual void SetMarshal(UnmanagedMarshal unmanagedMarshal);
-   void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._ParameterBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ParameterToken {
-   public static readonly ParameterToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(ParameterToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(ParameterToken a, ParameterToken b);
-   public static bool operator !=(ParameterToken a, ParameterToken b);
  }
- public enum PEFileKinds {
-   ConsoleApplication = 2,
-   Dll = 1,
-   WindowApplication = 3,
  }
- public sealed class PropertyBuilder : PropertyInfo, _PropertyBuilder {
-   public override PropertyAttributes Attributes { get; }
-   public override bool CanRead { get; }
-   public override bool CanWrite { get; }
-   public override Type DeclaringType { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public PropertyToken PropertyToken { get; }
-   public override Type PropertyType { get; }
-   public override Type ReflectedType { get; }
-   public void AddOtherMethod(MethodBuilder mdBuilder);
-   public override MethodInfo[] GetAccessors(bool nonPublic);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override MethodInfo GetGetMethod(bool nonPublic);
-   public override ParameterInfo[] GetIndexParameters();
-   public override MethodInfo GetSetMethod(bool nonPublic);
-   public override object GetValue(object obj, object[] index);
-   public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
-   public override bool IsDefined(Type attributeType, bool inherit);
-   public void SetConstant(object defaultValue);
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetGetMethod(MethodBuilder mdBuilder);
-   public void SetSetMethod(MethodBuilder mdBuilder);
-   public override void SetValue(object obj, object value, object[] index);
-   public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
-   void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._PropertyBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct PropertyToken {
-   public static readonly PropertyToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(PropertyToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(PropertyToken a, PropertyToken b);
-   public static bool operator !=(PropertyToken a, PropertyToken b);
  }
- public sealed class SignatureHelper : _SignatureHelper {
-   public void AddArgument(Type clsArgument);
-   public void AddArgument(Type argument, bool pinned);
-   public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
-   public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
-   public void AddSentinel();
-   public override bool Equals(object obj);
-   public static SignatureHelper GetFieldSigHelper(Module mod);
-   public override int GetHashCode();
-   public static SignatureHelper GetLocalVarSigHelper();
-   public static SignatureHelper GetLocalVarSigHelper(Module mod);
-   public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
-   public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
-   public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
-   public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
-   public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
-   public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
-   public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
-   public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
-   public byte[] GetSignature();
-   void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._SignatureHelper.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SignatureToken {
-   public static readonly SignatureToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(SignatureToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(SignatureToken a, SignatureToken b);
-   public static bool operator !=(SignatureToken a, SignatureToken b);
  }
  public enum StackBehaviour {
    Pop0 = 0,
    Pop1 = 1,
    Pop1_pop1 = 2,
    Popi = 3,
    Popi_pop1 = 4,
    Popi_popi = 5,
    Popi_popi_popi = 7,
    Popi_popi8 = 6,
    Popi_popr4 = 8,
    Popi_popr8 = 9,
    Popref = 10,
    Popref_pop1 = 11,
    Popref_popi = 12,
    Popref_popi_pop1 = 28,
    Popref_popi_popi = 13,
    Popref_popi_popi8 = 14,
    Popref_popi_popr4 = 15,
    Popref_popi_popr8 = 16,
    Popref_popi_popref = 17,
    Push0 = 18,
    Push1 = 19,
    Push1_push1 = 20,
    Pushi = 21,
    Pushi8 = 22,
    Pushr4 = 23,
    Pushr8 = 24,
    Pushref = 25,
    Varpop = 26,
    Varpush = 27,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct StringToken {
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(StringToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(StringToken a, StringToken b);
-   public static bool operator !=(StringToken a, StringToken b);
  }
- public sealed class TypeBuilder : TypeInfo, _TypeBuilder {
-   public const int UnspecifiedTypeSize = 0;
-   public override Assembly Assembly { get; }
-   public override string AssemblyQualifiedName { get; }
-   public override Type BaseType { get; }
-   public override MethodBase DeclaringMethod { get; }
-   public override Type DeclaringType { get; }
-   public override string FullName { get; }
-   public override GenericParameterAttributes GenericParameterAttributes { get; }
-   public override int GenericParameterPosition { get; }
-   public override Guid GUID { get; }
-   public override bool IsConstructedGenericType { get; }
-   public override bool IsGenericParameter { get; }
-   public override bool IsGenericType { get; }
-   public override bool IsGenericTypeDefinition { get; }
-   public override bool IsSecurityCritical { get; }
-   public override bool IsSecuritySafeCritical { get; }
-   public override bool IsSecurityTransparent { get; }
-   public override Module Module { get; }
-   public override string Name { get; }
-   public override string Namespace { get; }
-   public PackingSize PackingSize { get; }
-   public override Type ReflectedType { get; }
-   public int Size { get; }
-   public override RuntimeTypeHandle TypeHandle { get; }
-   public TypeToken TypeToken { get; }
-   public override Type UnderlyingSystemType { get; }
-   public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
-   public void AddInterfaceImplementation(Type interfaceType);
-   public Type CreateType();
-   public TypeInfo CreateTypeInfo();
-   public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
-   public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
-   public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
-   public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
-   public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
-   public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
-   public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names);
-   public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes);
-   public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
-   public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
-   public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
-   public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
-   public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
-   public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
-   public TypeBuilder DefineNestedType(string name);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
-   public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
-   public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
-   public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
-   public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
-   public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
-   public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
-   public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
-   public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
-   public ConstructorBuilder DefineTypeInitializer();
-   public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
-   protected override TypeAttributes GetAttributeFlagsImpl();
-   public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
-   protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   public override object[] GetCustomAttributes(bool inherit);
-   public override object[] GetCustomAttributes(Type attributeType, bool inherit);
-   public override Type GetElementType();
-   public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   public override EventInfo[] GetEvents();
-   public override EventInfo[] GetEvents(BindingFlags bindingAttr);
-   public override FieldInfo GetField(string name, BindingFlags bindingAttr);
-   public static FieldInfo GetField(Type type, FieldInfo field);
-   public override FieldInfo[] GetFields(BindingFlags bindingAttr);
-   public override Type[] GetGenericArguments();
-   public override Type GetGenericTypeDefinition();
-   public override Type GetInterface(string name, bool ignoreCase);
-   public override InterfaceMapping GetInterfaceMap(Type interfaceType);
-   public override Type[] GetInterfaces();
-   public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   public static MethodInfo GetMethod(Type type, MethodInfo method);
-   protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   public override Type GetNestedType(string name, BindingFlags bindingAttr);
-   public override Type[] GetNestedTypes(BindingFlags bindingAttr);
-   public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   protected override bool HasElementTypeImpl();
-   public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   protected override bool IsArrayImpl();
-   public override bool IsAssignableFrom(TypeInfo typeInfo);
-   public override bool IsAssignableFrom(Type c);
-   protected override bool IsByRefImpl();
-   protected override bool IsCOMObjectImpl();
-   public bool IsCreated();
-   public override bool IsDefined(Type attributeType, bool inherit);
-   protected override bool IsPointerImpl();
-   protected override bool IsPrimitiveImpl();
-   public override bool IsSubclassOf(Type c);
-   public override Type MakeArrayType();
-   public override Type MakeArrayType(int rank);
-   public override Type MakeByRefType();
-   public override Type MakeGenericType(params Type[] typeArguments);
-   public override Type MakePointerType();
-   public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
-   public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
-   public void SetParent(Type parent);
-   void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._TypeBuilder.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public override string ToString();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TypeToken {
-   public static readonly TypeToken Empty;
-   public int Token { get; }
-   public override bool Equals(object obj);
-   public bool Equals(TypeToken obj);
-   public override int GetHashCode();
-   public static bool operator ==(TypeToken a, TypeToken b);
-   public static bool operator !=(TypeToken a, TypeToken b);
  }
- public sealed class UnmanagedMarshal {
-   public UnmanagedType BaseType { get; }
-   public int ElementCount { get; }
-   public UnmanagedType GetUnmanagedType { get; }
-   public Guid IIDGuid { get; }
-   public static UnmanagedMarshal DefineByValArray(int elemCount);
-   public static UnmanagedMarshal DefineByValTStr(int elemCount);
-   public static UnmanagedMarshal DefineLPArray(UnmanagedType elemType);
-   public static UnmanagedMarshal DefineSafeArray(UnmanagedType elemType);
-   public static UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType);
  }
 }
-namespace System.Resources {
- public interface IResourceReader : IDisposable, IEnumerable {
-   void Close();
-   new IDictionaryEnumerator GetEnumerator();
  }
- public interface IResourceWriter : IDisposable {
-   void AddResource(string name, byte[] value);
-   void AddResource(string name, object value);
-   void AddResource(string name, string value);
-   void Close();
-   void Generate();
  }
- public class MissingManifestResourceException : SystemException {
-   public MissingManifestResourceException();
-   protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
-   public MissingManifestResourceException(string message);
-   public MissingManifestResourceException(string message, Exception inner);
  }
- public class MissingSatelliteAssemblyException : SystemException {
-   public MissingSatelliteAssemblyException();
-   protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
-   public MissingSatelliteAssemblyException(string message);
-   public MissingSatelliteAssemblyException(string message, Exception inner);
-   public MissingSatelliteAssemblyException(string message, string cultureName);
-   public string CultureName { get; }
  }
- public sealed class NeutralResourcesLanguageAttribute : Attribute {
-   public NeutralResourcesLanguageAttribute(string cultureName);
-   public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
-   public string CultureName { get; }
-   public UltimateResourceFallbackLocation Location { get; }
  }
- public class ResourceManager {
-   protected Hashtable ResourceSets;
-   public static readonly int HeaderVersionNumber;
-   public static readonly int MagicNumber;
-   protected Assembly MainAssembly;
-   protected string BaseNameField;
-   protected ResourceManager();
-   [MethodImpl(NoInlining)]public ResourceManager(string baseName, Assembly assembly);
-   [MethodImpl(NoInlining)]public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
-   [MethodImpl(NoInlining)]public ResourceManager(Type resourceSource);
-   public virtual string BaseName { get; }
-   protected UltimateResourceFallbackLocation FallbackLocation { get; set; }
-   public virtual bool IgnoreCase { get; set; }
-   public virtual Type ResourceSetType { get; }
-   public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
-   protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
-   public virtual object GetObject(string name);
-   public virtual object GetObject(string name, CultureInfo culture);
-   protected virtual string GetResourceFileName(CultureInfo culture);
-   [MethodImpl(NoInlining)]public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
-   protected static Version GetSatelliteContractVersion(Assembly a);
-   public UnmanagedMemoryStream GetStream(string name);
-   public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
-   public virtual string GetString(string name);
-   public virtual string GetString(string name, CultureInfo culture);
-   [MethodImpl(NoInlining)]protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
-   public virtual void ReleaseAllResources();
  }
- public sealed class ResourceReader : IDisposable, IEnumerable, IResourceReader {
-   public ResourceReader(Stream stream);
-   public ResourceReader(string fileName);
-   public void Close();
-   public void Dispose();
-   public IDictionaryEnumerator GetEnumerator();
-   public void GetResourceData(string resourceName, out string resourceType, out byte[] resourceData);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public class ResourceSet : IDisposable, IEnumerable {
-   protected Hashtable Table;
-   protected IResourceReader Reader;
-   protected ResourceSet();
-   public ResourceSet(Stream stream);
-   public ResourceSet(IResourceReader reader);
-   public ResourceSet(string fileName);
-   public virtual void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual Type GetDefaultReader();
-   public virtual Type GetDefaultWriter();
-   public virtual IDictionaryEnumerator GetEnumerator();
-   public virtual object GetObject(string name);
-   public virtual object GetObject(string name, bool ignoreCase);
-   public virtual string GetString(string name);
-   public virtual string GetString(string name, bool ignoreCase);
-   protected virtual void ReadResources();
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public sealed class ResourceWriter : IDisposable, IResourceWriter {
-   public ResourceWriter(Stream stream);
-   public ResourceWriter(string fileName);
-   public Func<Type, string> TypeNameConverter { get; set; }
-   public void AddResource(string name, byte[] value);
-   public void AddResource(string name, Stream value);
-   public void AddResource(string name, Stream value, bool closeAfterWrite);
-   public void AddResource(string name, object value);
-   public void AddResource(string name, string value);
-   public void AddResourceData(string name, string typeName, byte[] serializedData);
-   public void Close();
-   public void Dispose();
-   public void Generate();
  }
- public sealed class SatelliteContractVersionAttribute : Attribute {
-   public SatelliteContractVersionAttribute(string version);
-   public string Version { get; }
  }
- public enum UltimateResourceFallbackLocation {
-   MainAssembly = 0,
-   Satellite = 1,
  }
 }
 namespace System.Runtime {
- public sealed class AssemblyTargetedPatchBandAttribute : Attribute {
-   public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
-   public string TargetedPatchBand { get; }
  }
  public enum GCLargeObjectHeapCompactionMode {
    CompactOnce = 2,
    Default = 1,
  }
  public enum GCLatencyMode {
    Batch = 0,
    Interactive = 1,
    LowLatency = 2,
-   NoGCRegion = 4,
    SustainedLowLatency = 3,
  }
  public static class GCSettings {
    public static bool IsServerGC { get; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }
    public static GCLatencyMode LatencyMode { get; set; }
  }
- public sealed class MemoryFailPoint : CriticalFinalizerObject, IDisposable {
-   public MemoryFailPoint(int sizeInMegabytes);
-   public void Dispose();
-   ~MemoryFailPoint();
  }
- public static class ProfileOptimization {
-   public static void SetProfileRoot(string directoryPath);
-   public static void StartProfile(string profile);
  }
- public sealed class TargetedPatchingOptOutAttribute : Attribute {
-   public TargetedPatchingOptOutAttribute(string reason);
-   public string Reason { get; }
  }
 }
 namespace System.Runtime.CompilerServices {
  public sealed class AccessedThroughPropertyAttribute : Attribute {
    public AccessedThroughPropertyAttribute(string propertyName);
    public string PropertyName { get; }
  }
  public sealed class AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AsyncTaskMethodBuilder {
-   public Task Task { get; }
-   public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public static AsyncTaskMethodBuilder Create();
-   public void SetException(Exception exception);
-   public void SetResult();
-   public void SetStateMachine(IAsyncStateMachine stateMachine);
-   public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AsyncTaskMethodBuilder<TResult> {
-   public Task<TResult> Task { get; }
-   public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public static AsyncTaskMethodBuilder<TResult> Create();
-   public void SetException(Exception exception);
-   public void SetResult(TResult result);
-   public void SetStateMachine(IAsyncStateMachine stateMachine);
-   public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AsyncVoidMethodBuilder {
-   public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
-   public static AsyncVoidMethodBuilder Create();
-   public void SetException(Exception exception);
-   public void SetResult();
-   public void SetStateMachine(IAsyncStateMachine stateMachine);
-   public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
  }
- public class CallConvCdecl {
-   public CallConvCdecl();
  }
- public class CallConvFastcall {
-   public CallConvFastcall();
  }
- public class CallConvStdcall {
-   public CallConvStdcall();
  }
- public class CallConvThiscall {
-   public CallConvThiscall();
  }
  public sealed class CallerFilePathAttribute : Attribute {
    public CallerFilePathAttribute();
  }
  public sealed class CallerLineNumberAttribute : Attribute {
    public CallerLineNumberAttribute();
  }
  public sealed class CallerMemberNameAttribute : Attribute {
    public CallerMemberNameAttribute();
  }
- public enum CompilationRelaxations {
-   NoStringInterning = 8,
  }
  public class CompilationRelaxationsAttribute : Attribute {
    public CompilationRelaxationsAttribute(int relaxations);
-   public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int CompilationRelaxations { get; }
  }
  public sealed class CompilerGeneratedAttribute : Attribute {
    public CompilerGeneratedAttribute();
  }
- public class CompilerGlobalScopeAttribute : Attribute {
-   public CompilerGlobalScopeAttribute();
  }
- public static class CompilerMarshalOverride {
  }
  public sealed class ConditionalWeakTable<TKey, TValue> where TKey : class where TValue : class {
    public ConditionalWeakTable();
    public void Add(TKey key, TValue value);
    ~ConditionalWeakTable();
    public TValue GetOrCreateValue(TKey key);
    public TValue GetValue(TKey key, ConditionalWeakTable<TKey, TValue>.CreateValueCallback createValueCallback);
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, out TValue value);
    public delegate TValue CreateValueCallback(TKey key);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ConfiguredTaskAwaitable {
-   public ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter();
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
-     public bool IsCompleted { get; }
-     public void GetResult();
-     public void OnCompleted(Action continuation);
-     public void UnsafeOnCompleted(Action continuation);
    }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ConfiguredTaskAwaitable<TResult> {
-   public ConfiguredTaskAwaitable<TResult>.ConfiguredTaskAwaiter GetAwaiter();
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
-     public bool IsCompleted { get; }
-     public TResult GetResult();
-     public void OnCompleted(Action continuation);
-     public void UnsafeOnCompleted(Action continuation);
    }
  }
- public static class ContractHelper {
-   public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
-   public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
  }
  public abstract class CustomConstantAttribute : Attribute {
    protected CustomConstantAttribute();
    public abstract object Value { get; }
  }
  public sealed class DateTimeConstantAttribute : CustomConstantAttribute {
    public DateTimeConstantAttribute(long ticks);
    public override object Value { get; }
  }
  public sealed class DecimalConstantAttribute : Attribute {
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low);
    public decimal Value { get; }
  }
- public sealed class DefaultDependencyAttribute : Attribute {
-   public DefaultDependencyAttribute(LoadHint loadHintArgument);
-   public LoadHint LoadHint { get; }
  }
- public sealed class DependencyAttribute : Attribute {
-   public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
-   public string DependentAssembly { get; }
-   public LoadHint LoadHint { get; }
  }
  public sealed class DisablePrivateReflectionAttribute : Attribute {
    public DisablePrivateReflectionAttribute();
  }
- public class DiscardableAttribute : Attribute {
-   public DiscardableAttribute();
  }
  public sealed class ExtensionAttribute : Attribute {
    public ExtensionAttribute();
  }
- public sealed class FixedAddressValueTypeAttribute : Attribute {
-   public FixedAddressValueTypeAttribute();
  }
  public sealed class FixedBufferAttribute : Attribute {
    public FixedBufferAttribute(Type elementType, int length);
    public Type ElementType { get; }
    public int Length { get; }
  }
  public static class FormattableStringFactory {
    public static FormattableString Create(string format, params object[] arguments);
  }
- public sealed class HasCopySemanticsAttribute : Attribute {
-   public HasCopySemanticsAttribute();
  }
- public interface IAsyncStateMachine {
-   void MoveNext();
-   void SetStateMachine(IAsyncStateMachine stateMachine);
  }
- public interface ICriticalNotifyCompletion : INotifyCompletion {
-   void UnsafeOnCompleted(Action continuation);
  }
- public sealed class IDispatchConstantAttribute : CustomConstantAttribute {
-   public IDispatchConstantAttribute();
-   public override object Value { get; }
  }
  public sealed class IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
  }
- public interface INotifyCompletion {
-   void OnCompleted(Action continuation);
  }
  public sealed class InternalsVisibleToAttribute : Attribute {
    public InternalsVisibleToAttribute(string assemblyName);
-   public bool AllInternalsVisible { get; set; }
    public string AssemblyName { get; }
  }
- public static class IsBoxed {
  }
- public static class IsByValue {
  }
  public static class IsConst {
  }
- public static class IsCopyConstructed {
  }
- public static class IsExplicitlyDereferenced {
  }
- public static class IsImplicitlyDereferenced {
  }
- public static class IsJitIntrinsic {
  }
- public static class IsLong {
  }
- public static class IsPinned {
  }
- public static class IsSignUnspecifiedByte {
  }
+ public interface IStrongBox {
+   object Value { get; set; }
  }
- public static class IsUdtReturn {
  }
  public static class IsVolatile {
  }
  public sealed class IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
  }
- public sealed class IUnknownConstantAttribute : CustomConstantAttribute {
-   public IUnknownConstantAttribute();
-   public override object Value { get; }
  }
- public enum LoadHint {
-   Always = 1,
-   Default = 0,
-   Sometimes = 2,
  }
- public enum MethodCodeType {
-   IL = 0,
-   Native = 1,
-   OPTIL = 2,
-   Runtime = 3,
  }
  public sealed class MethodImplAttribute : Attribute {
-   public MethodCodeType MethodCodeType;
-   public MethodImplAttribute();
-   public MethodImplAttribute(short value);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplOptions Value { get; }
  }
  public enum MethodImplOptions {
    AggressiveInlining = 256,
-   ForwardRef = 16,
-   InternalCall = 4096,
    NoInlining = 8,
    NoOptimization = 64,
    PreserveSig = 128,
-   Synchronized = 32,
-   Unmanaged = 4,
  }
- public sealed class NativeCppClassAttribute : Attribute {
-   public NativeCppClassAttribute();
  }
  public sealed class ReferenceAssemblyAttribute : Attribute {
    public ReferenceAssemblyAttribute();
    public ReferenceAssemblyAttribute(string description);
    public string Description { get; }
  }
- public sealed class RequiredAttributeAttribute : Attribute {
-   public RequiredAttributeAttribute(Type requiredContract);
-   public Type RequiredContract { get; }
  }
  public sealed class RuntimeCompatibilityAttribute : Attribute {
    public RuntimeCompatibilityAttribute();
    public bool WrapNonExceptionThrows { get; set; }
  }
  public static class RuntimeHelpers {
    public static int OffsetToStringData { get; }
-   [MethodImpl(InternalCall)]public static void EnsureSufficientExecutionStack();
-   [MethodImpl(InternalCall)]public static new bool Equals(object o1, object o2);
-   [MethodImpl(InternalCall)]public static void ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers.TryCode code, RuntimeHelpers.CleanupCode backoutCode, object userData);
-   [MethodImpl(InternalCall)]public static int GetHashCode(object o);
-   [MethodImpl(InternalCall)]public static object GetObjectValue(object obj);
-   [MethodImpl(InternalCall)]public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
-   public static void PrepareConstrainedRegions();
-   public static void PrepareConstrainedRegionsNoOP();
-   [MethodImpl(InternalCall)]public static void PrepareContractedDelegate(Delegate d);
-   [MethodImpl(InternalCall)]public static void PrepareDelegate(Delegate d);
-   public static void PrepareMethod(RuntimeMethodHandle method);
-   public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
-   [MethodImpl(InternalCall)]public static void ProbeForSufficientStack();
    public static void RunClassConstructor(RuntimeTypeHandle type);
-   public static void RunModuleConstructor(ModuleHandle module);
-   public delegate void CleanupCode(object userData, bool exceptionThrown);
-   public delegate void TryCode(object userData);
  }
- public sealed class RuntimeWrappedException : Exception {
-   public object WrappedException { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public sealed class ScopelessEnumAttribute : Attribute {
-   public ScopelessEnumAttribute();
  }
- public sealed class SpecialNameAttribute : Attribute {
-   public SpecialNameAttribute();
  }
  public class StateMachineAttribute : Attribute {
    public StateMachineAttribute(Type stateMachineType);
    public Type StateMachineType { get; }
  }
- public sealed class StringFreezingAttribute : Attribute {
-   public StringFreezingAttribute();
  }
+ public class StrongBox<T> : IStrongBox {
+   public T Value;
+   public StrongBox();
+   public StrongBox(T value);
+   object System.Runtime.CompilerServices.IStrongBox.Value { get; set; }
  }
- public sealed class SuppressIldasmAttribute : Attribute {
-   public SuppressIldasmAttribute();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
-   public bool IsCompleted { get; }
-   public void GetResult();
-   public void OnCompleted(Action continuation);
-   public void UnsafeOnCompleted(Action continuation);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TaskAwaiter<TResult> : ICriticalNotifyCompletion, INotifyCompletion {
-   public bool IsCompleted { get; }
-   public TResult GetResult();
-   public void OnCompleted(Action continuation);
-   public void UnsafeOnCompleted(Action continuation);
  }
  public sealed class TypeForwardedFromAttribute : Attribute {
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string AssemblyFullName { get; }
  }
  public sealed class TypeForwardedToAttribute : Attribute {
    public TypeForwardedToAttribute(Type destination);
    public Type Destination { get; }
  }
  public sealed class UnsafeValueTypeAttribute : Attribute {
    public UnsafeValueTypeAttribute();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
  public struct YieldAwaitable {
-   public YieldAwaitable.YieldAwaiter GetAwaiter();
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
    public struct YieldAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
-     public bool IsCompleted { get; }
-     public void GetResult();
-     public void OnCompleted(Action continuation);
-     public void UnsafeOnCompleted(Action continuation);
    }
  }
 }
-namespace System.Runtime.ConstrainedExecution {
- public enum Cer {
-   MayFail = 1,
-   None = 0,
-   Success = 2,
  }
- public enum Consistency {
-   MayCorruptAppDomain = 1,
-   MayCorruptInstance = 2,
-   MayCorruptProcess = 0,
-   WillNotCorruptState = 3,
  }
- public abstract class CriticalFinalizerObject {
-   protected CriticalFinalizerObject();
-   ~CriticalFinalizerObject();
  }
- public sealed class PrePrepareMethodAttribute : Attribute {
-   public PrePrepareMethodAttribute();
  }
- public sealed class ReliabilityContractAttribute : Attribute {
-   public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
-   public Cer Cer { get; }
-   public Consistency ConsistencyGuarantee { get; }
  }
 }
-namespace System.Runtime.DesignerServices {
- public sealed class WindowsRuntimeDesignerContext {
-   public WindowsRuntimeDesignerContext(IEnumerable<string> paths, string name);
-   public string Name { get; }
-   [MethodImpl(NoInlining)]public Assembly GetAssembly(string assemblyName);
-   [MethodImpl(NoInlining)]public Type GetType(string typeName);
-   public static void InitializeSharedContext(IEnumerable<string> paths);
-   public static void SetIterationContext(WindowsRuntimeDesignerContext context);
  }
 }
 namespace System.Runtime.ExceptionServices {
  public sealed class ExceptionDispatchInfo {
    public Exception SourceException { get; }
    public static ExceptionDispatchInfo Capture(Exception source);
    public void Throw();
  }
- public class FirstChanceExceptionEventArgs : EventArgs {
-   public FirstChanceExceptionEventArgs(Exception exception);
-   public Exception Exception { get; }
  }
- public sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
-   public HandleProcessCorruptedStateExceptionsAttribute();
  }
 }
-namespace System.Runtime.Hosting {
- public sealed class ActivationArguments : EvidenceBase {
-   public ActivationArguments(ActivationContext activationData);
-   public ActivationArguments(ActivationContext activationContext, string[] activationData);
-   public ActivationArguments(ApplicationIdentity applicationIdentity);
-   public ActivationArguments(ApplicationIdentity applicationIdentity, string[] activationData);
-   public ActivationContext ActivationContext { get; }
-   public string[] ActivationData { get; }
-   public ApplicationIdentity ApplicationIdentity { get; }
-   public override EvidenceBase Clone();
  }
- public class ApplicationActivator {
-   public ApplicationActivator();
-   public virtual ObjectHandle CreateInstance(ActivationContext activationContext);
-   public virtual ObjectHandle CreateInstance(ActivationContext activationContext, string[] activationCustomData);
-   protected static ObjectHandle CreateInstanceHelper(AppDomainSetup adSetup);
  }
 }
 namespace System.Runtime.InteropServices {
- public interface _Activator {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _Assembly {
-   string CodeBase { get; }
-   MethodInfo EntryPoint { get; }
-   string EscapedCodeBase { get; }
-   Evidence Evidence { get; }
-   string FullName { get; }
-   bool GlobalAssemblyCache { get; }
-   string Location { get; }
-   event ModuleResolveEventHandler ModuleResolve;
-   object CreateInstance(string typeName);
-   object CreateInstance(string typeName, bool ignoreCase);
-   object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
-   bool Equals(object other);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   Type[] GetExportedTypes();
-   FileStream GetFile(string name);
-   FileStream[] GetFiles();
-   FileStream[] GetFiles(bool getResourceModules);
-   int GetHashCode();
-   Module[] GetLoadedModules();
-   Module[] GetLoadedModules(bool getResourceModules);
-   ManifestResourceInfo GetManifestResourceInfo(string resourceName);
-   string[] GetManifestResourceNames();
-   Stream GetManifestResourceStream(string name);
-   Stream GetManifestResourceStream(Type type, string name);
-   Module GetModule(string name);
-   Module[] GetModules();
-   Module[] GetModules(bool getResourceModules);
-   AssemblyName GetName();
-   AssemblyName GetName(bool copiedName);
-   void GetObjectData(SerializationInfo info, StreamingContext context);
-   AssemblyName[] GetReferencedAssemblies();
-   Assembly GetSatelliteAssembly(CultureInfo culture);
-   Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
-   Type GetType();
-   Type GetType(string name);
-   Type GetType(string name, bool throwOnError);
-   Type GetType(string name, bool throwOnError, bool ignoreCase);
-   Type[] GetTypes();
-   bool IsDefined(Type attributeType, bool inherit);
-   Module LoadModule(string moduleName, byte[] rawModule);
-   Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore);
-   string ToString();
  }
- public interface _AssemblyBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _AssemblyName {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _Attribute {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _ConstructorBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _ConstructorInfo {
-   MethodAttributes Attributes { get; }
-   CallingConventions CallingConvention { get; }
-   Type DeclaringType { get; }
-   bool IsAbstract { get; }
-   bool IsAssembly { get; }
-   bool IsConstructor { get; }
-   bool IsFamily { get; }
-   bool IsFamilyAndAssembly { get; }
-   bool IsFamilyOrAssembly { get; }
-   bool IsFinal { get; }
-   bool IsHideBySig { get; }
-   bool IsPrivate { get; }
-   bool IsPublic { get; }
-   bool IsSpecialName { get; }
-   bool IsStatic { get; }
-   bool IsVirtual { get; }
-   MemberTypes MemberType { get; }
-   RuntimeMethodHandle MethodHandle { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   bool Equals(object other);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   MethodImplAttributes GetMethodImplementationFlags();
-   ParameterInfo[] GetParameters();
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   object Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   object Invoke_3(object obj, object[] parameters);
-   object Invoke_4(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   object Invoke_5(object[] parameters);
-   bool IsDefined(Type attributeType, bool inherit);
-   string ToString();
  }
- public interface _CustomAttributeBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _EnumBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _EventBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _EventInfo {
-   EventAttributes Attributes { get; }
-   Type DeclaringType { get; }
-   Type EventHandlerType { get; }
-   bool IsMulticast { get; }
-   bool IsSpecialName { get; }
-   MemberTypes MemberType { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   void AddEventHandler(object target, Delegate handler);
-   bool Equals(object other);
-   MethodInfo GetAddMethod();
-   MethodInfo GetAddMethod(bool nonPublic);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   MethodInfo GetRaiseMethod();
-   MethodInfo GetRaiseMethod(bool nonPublic);
-   MethodInfo GetRemoveMethod();
-   MethodInfo GetRemoveMethod(bool nonPublic);
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   void RemoveEventHandler(object target, Delegate handler);
-   string ToString();
  }
- public interface _Exception {
-   string HelpLink { get; set; }
-   Exception InnerException { get; }
-   string Message { get; }
-   string Source { get; set; }
-   string StackTrace { get; }
-   MethodBase TargetSite { get; }
-   bool Equals(object obj);
-   Exception GetBaseException();
-   int GetHashCode();
-   void GetObjectData(SerializationInfo info, StreamingContext context);
-   Type GetType();
-   string ToString();
  }
- public interface _FieldBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _FieldInfo {
-   FieldAttributes Attributes { get; }
-   Type DeclaringType { get; }
-   RuntimeFieldHandle FieldHandle { get; }
-   Type FieldType { get; }
-   bool IsAssembly { get; }
-   bool IsFamily { get; }
-   bool IsFamilyAndAssembly { get; }
-   bool IsFamilyOrAssembly { get; }
-   bool IsInitOnly { get; }
-   bool IsLiteral { get; }
-   bool IsNotSerialized { get; }
-   bool IsPinvokeImpl { get; }
-   bool IsPrivate { get; }
-   bool IsPublic { get; }
-   bool IsSpecialName { get; }
-   bool IsStatic { get; }
-   MemberTypes MemberType { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   bool Equals(object other);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   object GetValue(object obj);
-   object GetValueDirect(TypedReference obj);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   void SetValue(object obj, object value);
-   void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
-   void SetValueDirect(TypedReference obj, object value);
-   string ToString();
  }
- public interface _ILGenerator {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _LocalBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _MemberInfo {
-   Type DeclaringType { get; }
-   MemberTypes MemberType { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   bool Equals(object other);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   string ToString();
  }
- public interface _MethodBase {
-   MethodAttributes Attributes { get; }
-   CallingConventions CallingConvention { get; }
-   Type DeclaringType { get; }
-   bool IsAbstract { get; }
-   bool IsAssembly { get; }
-   bool IsConstructor { get; }
-   bool IsFamily { get; }
-   bool IsFamilyAndAssembly { get; }
-   bool IsFamilyOrAssembly { get; }
-   bool IsFinal { get; }
-   bool IsHideBySig { get; }
-   bool IsPrivate { get; }
-   bool IsPublic { get; }
-   bool IsSpecialName { get; }
-   bool IsStatic { get; }
-   bool IsVirtual { get; }
-   MemberTypes MemberType { get; }
-   RuntimeMethodHandle MethodHandle { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   bool Equals(object other);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   MethodImplAttributes GetMethodImplementationFlags();
-   ParameterInfo[] GetParameters();
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   object Invoke(object obj, object[] parameters);
-   object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   string ToString();
  }
- public interface _MethodBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _MethodInfo {
-   MethodAttributes Attributes { get; }
-   CallingConventions CallingConvention { get; }
-   Type DeclaringType { get; }
-   bool IsAbstract { get; }
-   bool IsAssembly { get; }
-   bool IsConstructor { get; }
-   bool IsFamily { get; }
-   bool IsFamilyAndAssembly { get; }
-   bool IsFamilyOrAssembly { get; }
-   bool IsFinal { get; }
-   bool IsHideBySig { get; }
-   bool IsPrivate { get; }
-   bool IsPublic { get; }
-   bool IsSpecialName { get; }
-   bool IsStatic { get; }
-   bool IsVirtual { get; }
-   MemberTypes MemberType { get; }
-   RuntimeMethodHandle MethodHandle { get; }
-   string Name { get; }
-   Type ReflectedType { get; }
-   Type ReturnType { get; }
-   ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
-   bool Equals(object other);
-   MethodInfo GetBaseDefinition();
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   MethodImplAttributes GetMethodImplementationFlags();
-   ParameterInfo[] GetParameters();
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   object Invoke(object obj, object[] parameters);
-   object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   string ToString();
  }
- public interface _MethodRental {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _Module {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _ModuleBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _ParameterBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _ParameterInfo {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _PropertyBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _PropertyInfo {
-   PropertyAttributes Attributes { get; }
-   bool CanRead { get; }
-   bool CanWrite { get; }
-   Type DeclaringType { get; }
-   bool IsSpecialName { get; }
-   MemberTypes MemberType { get; }
-   string Name { get; }
-   Type PropertyType { get; }
-   Type ReflectedType { get; }
-   bool Equals(object other);
-   MethodInfo[] GetAccessors();
-   MethodInfo[] GetAccessors(bool nonPublic);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   MethodInfo GetGetMethod();
-   MethodInfo GetGetMethod(bool nonPublic);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   ParameterInfo[] GetIndexParameters();
-   MethodInfo GetSetMethod();
-   MethodInfo GetSetMethod(bool nonPublic);
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   object GetValue(object obj, object[] index);
-   object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   bool IsDefined(Type attributeType, bool inherit);
-   void SetValue(object obj, object value, object[] index);
-   void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
-   string ToString();
  }
- public interface _SignatureHelper {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _Thread {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public interface _Type {
-   Assembly Assembly { get; }
-   string AssemblyQualifiedName { get; }
-   TypeAttributes Attributes { get; }
-   Type BaseType { get; }
-   Type DeclaringType { get; }
-   string FullName { get; }
-   Guid GUID { get; }
-   bool HasElementType { get; }
-   bool IsAbstract { get; }
-   bool IsAnsiClass { get; }
-   bool IsArray { get; }
-   bool IsAutoClass { get; }
-   bool IsAutoLayout { get; }
-   bool IsByRef { get; }
-   bool IsClass { get; }
-   bool IsCOMObject { get; }
-   bool IsContextful { get; }
-   bool IsEnum { get; }
-   bool IsExplicitLayout { get; }
-   bool IsImport { get; }
-   bool IsInterface { get; }
-   bool IsLayoutSequential { get; }
-   bool IsMarshalByRef { get; }
-   bool IsNestedAssembly { get; }
-   bool IsNestedFamANDAssem { get; }
-   bool IsNestedFamily { get; }
-   bool IsNestedFamORAssem { get; }
-   bool IsNestedPrivate { get; }
-   bool IsNestedPublic { get; }
-   bool IsNotPublic { get; }
-   bool IsPointer { get; }
-   bool IsPrimitive { get; }
-   bool IsPublic { get; }
-   bool IsSealed { get; }
-   bool IsSerializable { get; }
-   bool IsSpecialName { get; }
-   bool IsUnicodeClass { get; }
-   bool IsValueType { get; }
-   MemberTypes MemberType { get; }
-   Module Module { get; }
-   string Name { get; }
-   string Namespace { get; }
-   Type ReflectedType { get; }
-   RuntimeTypeHandle TypeHandle { get; }
-   ConstructorInfo TypeInitializer { get; }
-   Type UnderlyingSystemType { get; }
-   bool Equals(object other);
-   bool Equals(Type o);
-   Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
-   MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
-   int GetArrayRank();
-   ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
-   ConstructorInfo GetConstructor(Type[] types);
-   ConstructorInfo[] GetConstructors();
-   ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
-   object[] GetCustomAttributes(bool inherit);
-   object[] GetCustomAttributes(Type attributeType, bool inherit);
-   MemberInfo[] GetDefaultMembers();
-   Type GetElementType();
-   EventInfo GetEvent(string name);
-   EventInfo GetEvent(string name, BindingFlags bindingAttr);
-   EventInfo[] GetEvents();
-   EventInfo[] GetEvents(BindingFlags bindingAttr);
-   FieldInfo GetField(string name);
-   FieldInfo GetField(string name, BindingFlags bindingAttr);
-   FieldInfo[] GetFields();
-   FieldInfo[] GetFields(BindingFlags bindingAttr);
-   int GetHashCode();
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   Type GetInterface(string name);
-   Type GetInterface(string name, bool ignoreCase);
-   InterfaceMapping GetInterfaceMap(Type interfaceType);
-   Type[] GetInterfaces();
-   MemberInfo[] GetMember(string name);
-   MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
-   MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
-   MemberInfo[] GetMembers();
-   MemberInfo[] GetMembers(BindingFlags bindingAttr);
-   MethodInfo GetMethod(string name);
-   MethodInfo GetMethod(string name, BindingFlags bindingAttr);
-   MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
-   MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
-   MethodInfo GetMethod(string name, Type[] types);
-   MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
-   MethodInfo[] GetMethods();
-   MethodInfo[] GetMethods(BindingFlags bindingAttr);
-   Type GetNestedType(string name);
-   Type GetNestedType(string name, BindingFlags bindingAttr);
-   Type[] GetNestedTypes();
-   Type[] GetNestedTypes(BindingFlags bindingAttr);
-   PropertyInfo[] GetProperties();
-   PropertyInfo[] GetProperties(BindingFlags bindingAttr);
-   PropertyInfo GetProperty(string name);
-   PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
-   PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   PropertyInfo GetProperty(string name, Type returnType);
-   PropertyInfo GetProperty(string name, Type returnType, Type[] types);
-   PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
-   PropertyInfo GetProperty(string name, Type[] types);
-   Type GetType();
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);
-   object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture);
-   object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
-   bool IsAssignableFrom(Type c);
-   bool IsDefined(Type attributeType, bool inherit);
-   bool IsInstanceOfType(object o);
-   bool IsSubclassOf(Type c);
-   string ToString();
  }
- public interface _TypeBuilder {
-   void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void GetTypeInfoCount(out uint pcTInfo);
-   void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
  }
- public sealed class AllowReversePInvokeCallsAttribute : Attribute {
-   public AllowReversePInvokeCallsAttribute();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ArrayWithOffset {
-   public ArrayWithOffset(object array, int offset);
-   public override bool Equals(object obj);
-   public bool Equals(ArrayWithOffset obj);
-   public object GetArray();
-   public override int GetHashCode();
-   public int GetOffset();
-   public static bool operator ==(ArrayWithOffset a, ArrayWithOffset b);
-   public static bool operator !=(ArrayWithOffset a, ArrayWithOffset b);
  }
- public enum AssemblyRegistrationFlags {
-   None = 0,
-   SetCodeBase = 1,
  }
- public sealed class AutomationProxyAttribute : Attribute {
-   public AutomationProxyAttribute(bool val);
-   public bool Value { get; }
  }
- public sealed class BestFitMappingAttribute : Attribute {
-   public bool ThrowOnUnmappableChar;
-   public BestFitMappingAttribute(bool BestFitMapping);
-   public bool BestFitMapping { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct BIND_OPTS {
-   public int cbStruct;
-   public int dwTickCountDeadline;
-   public int grfFlags;
-   public int grfMode;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
  public struct BINDPTR {
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lpfuncdesc;
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lptcomp;
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lpvardesc;
  }
- public sealed class BStrWrapper {
-   public BStrWrapper(object value);
-   public BStrWrapper(string value);
-   public string WrappedObject { get; }
  }
- public enum CALLCONV {
-   CC_CDECL = 1,
-   CC_MACPASCAL = 3,
-   CC_MAX = 9,
-   CC_MPWCDECL = 7,
-   CC_MPWPASCAL = 8,
-   CC_MSCPASCAL = 2,
-   CC_PASCAL = 2,
-   CC_RESERVED = 5,
-   CC_STDCALL = 4,
-   CC_SYSCALL = 6,
  }
- public enum CallingConvention {
-   Cdecl = 2,
-   FastCall = 5,
-   StdCall = 3,
-   ThisCall = 4,
-   Winapi = 1,
  }
  public enum CharSet {
    Ansi = 2,
-   Auto = 4,
-   None = 1,
    Unicode = 3,
  }
- public sealed class ClassInterfaceAttribute : Attribute {
-   public ClassInterfaceAttribute(short classInterfaceType);
-   public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
-   public ClassInterfaceType Value { get; }
  }
- public enum ClassInterfaceType {
-   AutoDispatch = 1,
-   AutoDual = 2,
-   None = 0,
  }
- public sealed class CoClassAttribute : Attribute {
-   public CoClassAttribute(Type coClass);
-   public Type CoClass { get; }
  }
- public sealed class ComAliasNameAttribute : Attribute {
-   public ComAliasNameAttribute(string alias);
-   public string Value { get; }
  }
- public sealed class ComCompatibleVersionAttribute : Attribute {
-   public ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
-   public int BuildNumber { get; }
-   public int MajorVersion { get; }
-   public int MinorVersion { get; }
-   public int RevisionNumber { get; }
  }
- public sealed class ComConversionLossAttribute : Attribute {
-   public ComConversionLossAttribute();
  }
- public sealed class ComDefaultInterfaceAttribute : Attribute {
-   public ComDefaultInterfaceAttribute(Type defaultInterface);
-   public Type Value { get; }
  }
- public sealed class ComEventInterfaceAttribute : Attribute {
-   public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
-   public Type EventProvider { get; }
-   public Type SourceInterface { get; }
  }
- public static class ComEventsHelper {
-   public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
-   public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
  }
- public class COMException : ExternalException {
-   public COMException();
-   protected COMException(SerializationInfo info, StreamingContext context);
-   public COMException(string message);
-   public COMException(string message, Exception inner);
-   public COMException(string message, int errorCode);
-   public override string ToString();
  }
- public sealed class ComImportAttribute : Attribute {
-   public ComImportAttribute();
  }
- public enum ComInterfaceType {
-   InterfaceIsDual = 0,
-   InterfaceIsIDispatch = 2,
-   InterfaceIsIInspectable = 3,
-   InterfaceIsIUnknown = 1,
  }
- public enum ComMemberType {
-   Method = 0,
-   PropGet = 1,
-   PropSet = 2,
  }
- public sealed class ComRegisterFunctionAttribute : Attribute {
-   public ComRegisterFunctionAttribute();
  }
- public sealed class ComSourceInterfacesAttribute : Attribute {
-   public ComSourceInterfacesAttribute(string sourceInterfaces);
-   public ComSourceInterfacesAttribute(Type sourceInterface);
-   public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
-   public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
-   public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
-   public string Value { get; }
  }
- public sealed class ComUnregisterFunctionAttribute : Attribute {
-   public ComUnregisterFunctionAttribute();
  }
  public sealed class ComVisibleAttribute : Attribute {
    public ComVisibleAttribute(bool visibility);
    public bool Value { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CONNECTDATA {
-   public int dwCookie;
-   public object pUnk;
  }
- public abstract class CriticalHandle : CriticalFinalizerObject, IDisposable {
-   protected IntPtr handle;
-   protected CriticalHandle(IntPtr invalidHandleValue);
-   public bool IsClosed { get; }
-   public abstract bool IsInvalid { get; }
-   public void Close();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~CriticalHandle();
-   protected abstract bool ReleaseHandle();
-   protected void SetHandle(IntPtr handle);
-   public void SetHandleAsInvalid();
  }
- public sealed class CurrencyWrapper {
-   public CurrencyWrapper(decimal obj);
-   public CurrencyWrapper(object obj);
-   public decimal WrappedObject { get; }
  }
- public enum CustomQueryInterfaceMode {
-   Allow = 1,
-   Ignore = 0,
  }
- public enum CustomQueryInterfaceResult {
-   Failed = 2,
-   Handled = 0,
-   NotHandled = 1,
  }
- public sealed class DefaultCharSetAttribute : Attribute {
-   public DefaultCharSetAttribute(CharSet charSet);
-   public CharSet CharSet { get; }
  }
- public sealed class DefaultDllImportSearchPathsAttribute : Attribute {
-   public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
-   public DllImportSearchPath Paths { get; }
  }
- public enum DESCKIND {
-   DESCKIND_FUNCDESC = 1,
-   DESCKIND_IMPLICITAPPOBJ = 4,
-   DESCKIND_MAX = 5,
-   DESCKIND_NONE = 0,
-   DESCKIND_TYPECOMP = 3,
-   DESCKIND_VARDESC = 2,
  }
- public sealed class DispatchWrapper {
-   public DispatchWrapper(object obj);
-   public object WrappedObject { get; }
  }
- public sealed class DispIdAttribute : Attribute {
-   public DispIdAttribute(int dispId);
-   public int Value { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct DISPPARAMS {
-   public int cArgs;
-   public int cNamedArgs;
-   public IntPtr rgdispidNamedArgs;
-   public IntPtr rgvarg;
  }
- public sealed class DllImportAttribute : Attribute {
-   public bool BestFitMapping;
-   public bool ExactSpelling;
-   public bool PreserveSig;
-   public bool SetLastError;
-   public bool ThrowOnUnmappableChar;
-   public CallingConvention CallingConvention;
-   public CharSet CharSet;
-   public string EntryPoint;
-   public DllImportAttribute(string dllName);
-   public string Value { get; }
  }
- public enum DllImportSearchPath {
-   ApplicationDirectory = 512,
-   AssemblyDirectory = 2,
-   LegacyBehavior = 0,
-   SafeDirectories = 4096,
-   System32 = 2048,
-   UseDllDirectoryForDependencies = 256,
-   UserDirectories = 1024,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ELEMDESC {
-   public ELEMDESC.DESCUNION desc;
-   public TYPEDESC tdesc;
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct DESCUNION {
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public IDLDESC idldesc;
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public PARAMDESC paramdesc;
    }
  }
- public sealed class ErrorWrapper {
-   public ErrorWrapper(Exception e);
-   public ErrorWrapper(int errorCode);
-   public ErrorWrapper(object errorCode);
-   public int ErrorCode { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct EXCEPINFO {
-   public short wCode;
-   public short wReserved;
-   public int dwHelpContext;
-   public IntPtr pfnDeferredFillIn;
-   public IntPtr pvReserved;
-   public string bstrDescription;
-   public string bstrHelpFile;
-   public string bstrSource;
  }
- public enum ExporterEventKind {
-   ERROR_REFTOINVALIDASSEMBLY = 2,
-   NOTIF_CONVERTWARNING = 1,
-   NOTIF_TYPECONVERTED = 0,
  }
- public sealed class ExtensibleClassFactory {
-   [MethodImpl(InternalCall)]public static void RegisterObjectCreationCallback(ObjectCreationDelegate callback);
  }
- public class ExternalException : SystemException {
-   public ExternalException();
-   protected ExternalException(SerializationInfo info, StreamingContext context);
-   public ExternalException(string message);
-   public ExternalException(string message, Exception inner);
-   public ExternalException(string message, int errorCode);
-   public virtual int ErrorCode { get; }
-   public override string ToString();
  }
  public sealed class FieldOffsetAttribute : Attribute {
    public FieldOffsetAttribute(int offset);
    public int Value { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct FILETIME {
-   public int dwHighDateTime;
-   public int dwLowDateTime;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct FUNCDESC {
-   public short cParams;
-   public short cParamsOpt;
-   public short cScodes;
-   public short oVft;
-   public short wFuncFlags;
-   public int memid;
-   public IntPtr lprgelemdescParam;
-   public IntPtr lprgscode;
-   public CALLCONV callconv;
-   public ELEMDESC elemdescFunc;
-   public FUNCKIND funckind;
-   public INVOKEKIND invkind;
  }
- public enum FUNCFLAGS : short {
-   FUNCFLAG_FBINDABLE = (short)4,
-   FUNCFLAG_FDEFAULTBIND = (short)32,
-   FUNCFLAG_FDEFAULTCOLLELEM = (short)256,
-   FUNCFLAG_FDISPLAYBIND = (short)16,
-   FUNCFLAG_FHIDDEN = (short)64,
-   FUNCFLAG_FIMMEDIATEBIND = (short)4096,
-   FUNCFLAG_FNONBROWSABLE = (short)1024,
-   FUNCFLAG_FREPLACEABLE = (short)2048,
-   FUNCFLAG_FREQUESTEDIT = (short)8,
-   FUNCFLAG_FRESTRICTED = (short)1,
-   FUNCFLAG_FSOURCE = (short)2,
-   FUNCFLAG_FUIDEFAULT = (short)512,
-   FUNCFLAG_FUSESGETLASTERROR = (short)128,
  }
- public enum FUNCKIND {
-   FUNC_DISPATCH = 4,
-   FUNC_NONVIRTUAL = 2,
-   FUNC_PUREVIRTUAL = 1,
-   FUNC_STATIC = 3,
-   FUNC_VIRTUAL = 0,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct GCHandle {
-   public bool IsAllocated { get; }
-   public object Target { get; set; }
-   public IntPtr AddrOfPinnedObject();
-   public static GCHandle Alloc(object value);
-   public static GCHandle Alloc(object value, GCHandleType type);
-   public override bool Equals(object o);
-   public void Free();
-   public static GCHandle FromIntPtr(IntPtr value);
-   public override int GetHashCode();
-   public static bool operator ==(GCHandle a, GCHandle b);
-   public static explicit operator GCHandle (IntPtr value);
-   public static explicit operator IntPtr (GCHandle value);
-   public static bool operator !=(GCHandle a, GCHandle b);
-   public static IntPtr ToIntPtr(GCHandle value);
  }
- public enum GCHandleType {
-   Normal = 2,
-   Pinned = 3,
-   Weak = 0,
-   WeakTrackResurrection = 1,
  }
- public sealed class GuidAttribute : Attribute {
-   public GuidAttribute(string guid);
-   public string Value { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct HandleRef {
-   public HandleRef(object wrapper, IntPtr handle);
-   public IntPtr Handle { get; }
-   public object Wrapper { get; }
-   public static explicit operator IntPtr (HandleRef value);
-   public static IntPtr ToIntPtr(HandleRef value);
  }
- public interface ICustomAdapter {
-   object GetUnderlyingObject();
  }
- public interface ICustomFactory {
-   MarshalByRefObject CreateInstance(Type serverType);
  }
- public interface ICustomMarshaler {
-   void CleanUpManagedData(object ManagedObj);
-   void CleanUpNativeData(IntPtr pNativeData);
-   int GetNativeDataSize();
-   IntPtr MarshalManagedToNative(object ManagedObj);
-   object MarshalNativeToManaged(IntPtr pNativeData);
  }
- public interface ICustomQueryInterface {
-   CustomQueryInterfaceResult GetInterface(ref Guid iid, out IntPtr ppv);
  }
- public sealed class IDispatchImplAttribute : Attribute {
-   public IDispatchImplAttribute(short implType);
-   public IDispatchImplAttribute(IDispatchImplType implType);
-   public IDispatchImplType Value { get; }
  }
- public enum IDispatchImplType {
-   CompatibleImpl = 2,
-   InternalImpl = 1,
-   SystemDefinedImpl = 0,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct IDLDESC {
-   public int dwReserved;
-   public IDLFLAG wIDLFlags;
  }
- public enum IDLFLAG : short {
-   IDLFLAG_FIN = (short)1,
-   IDLFLAG_FLCID = (short)4,
-   IDLFLAG_FOUT = (short)2,
-   IDLFLAG_FRETVAL = (short)8,
-   IDLFLAG_NONE = (short)0,
  }
- public enum IMPLTYPEFLAGS {
-   IMPLTYPEFLAG_FDEFAULT = 1,
-   IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
-   IMPLTYPEFLAG_FRESTRICTED = 4,
-   IMPLTYPEFLAG_FSOURCE = 2,
  }
- public sealed class ImportedFromTypeLibAttribute : Attribute {
-   public ImportedFromTypeLibAttribute(string tlbFile);
-   public string Value { get; }
  }
- public enum ImporterEventKind {
-   ERROR_REFTOINVALIDTYPELIB = 2,
-   NOTIF_CONVERTWARNING = 1,
-   NOTIF_TYPECONVERTED = 0,
  }
- public sealed class InAttribute : Attribute {
-   public InAttribute();
  }
- public sealed class InterfaceTypeAttribute : Attribute {
-   public InterfaceTypeAttribute(short interfaceType);
-   public InterfaceTypeAttribute(ComInterfaceType interfaceType);
-   public ComInterfaceType Value { get; }
  }
- public class InvalidComObjectException : SystemException {
-   public InvalidComObjectException();
-   protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
-   public InvalidComObjectException(string message);
-   public InvalidComObjectException(string message, Exception inner);
  }
- public class InvalidOleVariantTypeException : SystemException {
-   public InvalidOleVariantTypeException();
-   protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
-   public InvalidOleVariantTypeException(string message);
-   public InvalidOleVariantTypeException(string message, Exception inner);
  }
- public enum INVOKEKIND {
-   INVOKE_FUNC = 1,
-   INVOKE_PROPERTYGET = 2,
-   INVOKE_PROPERTYPUT = 4,
-   INVOKE_PROPERTYPUTREF = 8,
  }
- public interface IRegistrationServices {
-   Guid GetManagedCategoryGuid();
-   string GetProgIdForType(Type type);
-   Type[] GetRegistrableTypesInAssembly(Assembly assembly);
-   bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
-   void RegisterTypeForComClients(Type type, ref Guid g);
-   bool TypeRepresentsComType(Type type);
-   bool TypeRequiresRegistration(Type type);
-   bool UnregisterAssembly(Assembly assembly);
  }
- public interface ITypeLibConverter {
-   object ConvertAssemblyToTypeLib(Assembly assembly, string typeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
-   AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
-   AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
-   bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, out string asmName, out string asmCodeBase);
  }
- public interface ITypeLibExporterNameProvider {
-   string[] GetNames();
  }
- public interface ITypeLibExporterNotifySink {
-   void ReportEvent(ExporterEventKind eventKind, int eventCode, string eventMsg);
-   object ResolveRef(Assembly assembly);
  }
- public interface ITypeLibImporterNotifySink {
-   void ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg);
-   Assembly ResolveRef(object typeLib);
  }
  public enum LayoutKind {
    Auto = 3,
    Explicit = 2,
    Sequential = 0,
  }
- public sealed class LCIDConversionAttribute : Attribute {
-   public LCIDConversionAttribute(int lcid);
-   public int Value { get; }
  }
- public enum LIBFLAGS : short {
-   LIBFLAG_FCONTROL = (short)2,
-   LIBFLAG_FHASDISKIMAGE = (short)8,
-   LIBFLAG_FHIDDEN = (short)4,
-   LIBFLAG_FRESTRICTED = (short)1,
  }
- public sealed class ManagedToNativeComInteropStubAttribute : Attribute {
-   public ManagedToNativeComInteropStubAttribute(Type classType, string methodName);
-   public Type ClassType { get; }
-   public string MethodName { get; }
  }
- public static class Marshal {
-   public static readonly int SystemDefaultCharSize;
-   public static readonly int SystemMaxDBCSCharSize;
-   [MethodImpl(InternalCall)]public static int AddRef(IntPtr pUnk);
-   public static IntPtr AllocCoTaskMem(int cb);
-   public static IntPtr AllocHGlobal(int cb);
-   public static IntPtr AllocHGlobal(IntPtr cb);
-   [MethodImpl(InternalCall)]public static bool AreComObjectsAvailableForCleanup();
-   public static object BindToMoniker(string monikerName);
-   [MethodImpl(InternalCall)]public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
-   [MethodImpl(InternalCall)]public static void CleanupUnusedObjectsInCurrentContext();
-   public static void Copy(byte[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(char[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(double[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(short[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(int[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(long[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(IntPtr source, byte[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, char[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, double[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, short[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, int[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, long[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
-   public static void Copy(IntPtr source, float[] destination, int startIndex, int length);
-   public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
-   public static void Copy(float[] source, int startIndex, IntPtr destination, int length);
-   [MethodImpl(InternalCall)]public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
-   public static IntPtr CreateAggregatedObject<T>(IntPtr pOuter, T o);
-   public static object CreateWrapperOfType(object o, Type t);
-   public static TWrapper CreateWrapperOfType<T, TWrapper>(T o);
-   [MethodImpl(InternalCall)]public static void DestroyStructure(IntPtr ptr, Type structuretype);
-   public static void DestroyStructure<T>(IntPtr ptr);
-   public static int FinalReleaseComObject(object o);
-   public static void FreeBSTR(IntPtr ptr);
-   public static void FreeCoTaskMem(IntPtr ptr);
-   public static void FreeHGlobal(IntPtr hglobal);
-   public static Guid GenerateGuidForType(Type type);
-   public static string GenerateProgIdForType(Type type);
-   public static object GetActiveObject(string progID);
-   public static IntPtr GetComInterfaceForObject(object o, Type T);
-   public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
-   public static IntPtr GetComInterfaceForObject<T, TInterface>(T o);
-   public static IntPtr GetComInterfaceForObjectInContext(object o, Type t);
-   public static object GetComObjectData(object obj, object key);
-   public static int GetComSlotForMethodInfo(MemberInfo m);
-   public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
-   public static TDelegate GetDelegateForFunctionPointer<TDelegate>(IntPtr ptr);
-   [MethodImpl(InternalCall)]public static int GetEndComSlot(Type t);
-   [MethodImpl(InternalCall)]public static int GetExceptionCode();
-   public static Exception GetExceptionForHR(int errorCode);
-   public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
-   [MethodImpl(InternalCall)]public static IntPtr GetExceptionPointers();
-   public static IntPtr GetFunctionPointerForDelegate(Delegate d);
-   public static IntPtr GetFunctionPointerForDelegate<TDelegate>(TDelegate d);
-   public static IntPtr GetHINSTANCE(Module m);
-   [MethodImpl(InternalCall)]public static int GetHRForException(Exception e);
-   public static int GetHRForLastWin32Error();
-   public static IntPtr GetIDispatchForObject(object o);
-   public static IntPtr GetIDispatchForObjectInContext(object o);
-   [MethodImpl(InternalCall)]public static IntPtr GetITypeInfoForType(Type t);
-   public static IntPtr GetIUnknownForObject(object o);
-   public static IntPtr GetIUnknownForObjectInContext(object o);
-   [MethodImpl(InternalCall)]public static int GetLastWin32Error();
-   [MethodImpl(InternalCall)]public static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
-   [MethodImpl(InternalCall)]public static MemberInfo GetMethodInfoForComSlot(Type t, int slot, ref ComMemberType memberType);
-   [MethodImpl(InternalCall)]public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
-   public static void GetNativeVariantForObject<T>(T obj, IntPtr pDstNativeVariant);
-   [MethodImpl(InternalCall)]public static object GetObjectForIUnknown(IntPtr pUnk);
-   [MethodImpl(InternalCall)]public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
-   public static T GetObjectForNativeVariant<T>(IntPtr pSrcNativeVariant);
-   [MethodImpl(InternalCall)]public static object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
-   public static T[] GetObjectsForNativeVariants<T>(IntPtr aSrcNativeVariant, int cVars);
-   [MethodImpl(InternalCall)]public static int GetStartComSlot(Type t);
-   public static Thread GetThreadFromFiberCookie(int cookie);
-   [MethodImpl(InternalCall)]public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
-   public static Type GetTypeForITypeInfo(IntPtr piTypeInfo);
-   public static Type GetTypeFromCLSID(Guid clsid);
-   public static string GetTypeInfoName(ITypeInfo typeInfo);
-   public static string GetTypeInfoName(UCOMITypeInfo pTI);
-   public static Guid GetTypeLibGuid(ITypeLib typelib);
-   public static Guid GetTypeLibGuid(UCOMITypeLib pTLB);
-   public static Guid GetTypeLibGuidForAssembly(Assembly asm);
-   [MethodImpl(InternalCall)]public static int GetTypeLibLcid(ITypeLib typelib);
-   public static int GetTypeLibLcid(UCOMITypeLib pTLB);
-   public static string GetTypeLibName(ITypeLib typelib);
-   public static string GetTypeLibName(UCOMITypeLib pTLB);
-   public static void GetTypeLibVersionForAssembly(Assembly inputAssembly, out int majorVersion, out int minorVersion);
-   [MethodImpl(InternalCall)]public static object GetUniqueObjectForIUnknown(IntPtr unknown);
-   [MethodImpl(InternalCall)]public static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
-   [MethodImpl(InternalCall)]public static bool IsComObject(object o);
-   [MethodImpl(InternalCall)]public static bool IsTypeVisibleFromCom(Type t);
-   public static int NumParamBytes(MethodInfo m);
-   public static IntPtr OffsetOf(Type t, string fieldName);
-   public static IntPtr OffsetOf<T>(string fieldName);
-   public static void Prelink(MethodInfo m);
-   public static void PrelinkAll(Type c);
-   public static string PtrToStringAnsi(IntPtr ptr);
-   public static string PtrToStringAnsi(IntPtr ptr, int len);
-   public static string PtrToStringAuto(IntPtr ptr);
-   public static string PtrToStringAuto(IntPtr ptr, int len);
-   public static string PtrToStringBSTR(IntPtr ptr);
-   public static string PtrToStringUni(IntPtr ptr);
-   public static string PtrToStringUni(IntPtr ptr, int len);
-   public static void PtrToStructure(IntPtr ptr, object structure);
-   [MethodImpl(NoInlining)]public static object PtrToStructure(IntPtr ptr, Type structureType);
-   public static T PtrToStructure<T>(IntPtr ptr);
-   public static void PtrToStructure<T>(IntPtr ptr, T structure);
-   [MethodImpl(InternalCall)]public static int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr ppv);
-   public static byte ReadByte(IntPtr ptr);
-   public static byte ReadByte(IntPtr ptr, int ofs);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static byte ReadByte(object ptr, int ofs);
-   public static short ReadInt16(IntPtr ptr);
-   public static short ReadInt16(IntPtr ptr, int ofs);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static short ReadInt16(object ptr, int ofs);
-   public static int ReadInt32(IntPtr ptr);
-   public static int ReadInt32(IntPtr ptr, int ofs);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static int ReadInt32(object ptr, int ofs);
-   public static long ReadInt64(IntPtr ptr);
-   public static long ReadInt64(IntPtr ptr, int ofs);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static long ReadInt64(object ptr, int ofs);
-   public static IntPtr ReadIntPtr(IntPtr ptr);
-   public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
-   public static IntPtr ReadIntPtr(object ptr, int ofs);
-   public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
-   public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
-   [MethodImpl(InternalCall)]public static int Release(IntPtr pUnk);
-   public static int ReleaseComObject(object o);
-   public static void ReleaseThreadCache();
-   public static IntPtr SecureStringToBSTR(SecureString s);
-   public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
-   public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
-   public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
-   public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
-   public static bool SetComObjectData(object obj, object key, object data);
-   public static int SizeOf(object structure);
-   public static int SizeOf(Type t);
-   public static int SizeOf<T>();
-   public static int SizeOf<T>(T structure);
-   public static IntPtr StringToBSTR(string s);
-   public static IntPtr StringToCoTaskMemAnsi(string s);
-   public static IntPtr StringToCoTaskMemAuto(string s);
-   public static IntPtr StringToCoTaskMemUni(string s);
-   public static IntPtr StringToHGlobalAnsi(string s);
-   public static IntPtr StringToHGlobalAuto(string s);
-   public static IntPtr StringToHGlobalUni(string s);
-   [MethodImpl(InternalCall)]public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
-   public static void StructureToPtr<T>(T structure, IntPtr ptr, bool fDeleteOld);
-   public static void ThrowExceptionForHR(int errorCode);
-   public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
-   [MethodImpl(InternalCall)]public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
-   public static IntPtr UnsafeAddrOfPinnedArrayElement<T>(T[] arr, int index);
-   public static void WriteByte(IntPtr ptr, byte val);
-   public static void WriteByte(IntPtr ptr, int ofs, byte val);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static void WriteByte(object ptr, int ofs, byte val);
-   public static void WriteInt16(IntPtr ptr, char val);
-   public static void WriteInt16(IntPtr ptr, short val);
-   public static void WriteInt16(IntPtr ptr, int ofs, char val);
-   public static void WriteInt16(IntPtr ptr, int ofs, short val);
-   public static void WriteInt16(object ptr, int ofs, char val);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static void WriteInt16(object ptr, int ofs, short val);
-   public static void WriteInt32(IntPtr ptr, int val);
-   public static void WriteInt32(IntPtr ptr, int ofs, int val);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static void WriteInt32(object ptr, int ofs, int val);
-   public static void WriteInt64(IntPtr ptr, int ofs, long val);
-   public static void WriteInt64(IntPtr ptr, long val);
-   [DllImport("mscoree.dll")][MethodImpl(PreserveSig)]public static void WriteInt64(object ptr, int ofs, long val);
-   public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
-   public static void WriteIntPtr(IntPtr ptr, IntPtr val);
-   public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
-   public static void ZeroFreeBSTR(IntPtr s);
-   public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
-   public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
-   public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
-   public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
  }
- public sealed class MarshalAsAttribute : Attribute {
-   public short SizeParamIndex;
-   public int IidParameterIndex;
-   public int SizeConst;
-   public UnmanagedType ArraySubType;
-   public VarEnum SafeArraySubType;
-   public string MarshalCookie;
-   public string MarshalType;
-   public Type MarshalTypeRef;
-   public Type SafeArrayUserDefinedSubType;
-   public MarshalAsAttribute(short unmanagedType);
-   public MarshalAsAttribute(UnmanagedType unmanagedType);
-   public UnmanagedType Value { get; }
  }
- public class MarshalDirectiveException : SystemException {
-   public MarshalDirectiveException();
-   protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
-   public MarshalDirectiveException(string message);
-   public MarshalDirectiveException(string message, Exception inner);
  }
- public delegate IntPtr ObjectCreationDelegate(IntPtr aggregator);
- public sealed class OptionalAttribute : Attribute {
-   public OptionalAttribute();
  }
  public sealed class OutAttribute : Attribute {
    public OutAttribute();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct PARAMDESC {
-   public IntPtr lpVarValue;
-   public PARAMFLAG wParamFlags;
  }
- public enum PARAMFLAG : short {
-   PARAMFLAG_FHASCUSTDATA = (short)64,
-   PARAMFLAG_FHASDEFAULT = (short)32,
-   PARAMFLAG_FIN = (short)1,
-   PARAMFLAG_FLCID = (short)4,
-   PARAMFLAG_FOPT = (short)16,
-   PARAMFLAG_FOUT = (short)2,
-   PARAMFLAG_FRETVAL = (short)8,
-   PARAMFLAG_NONE = (short)0,
  }
- public sealed class PreserveSigAttribute : Attribute {
-   public PreserveSigAttribute();
  }
- public sealed class PrimaryInteropAssemblyAttribute : Attribute {
-   public PrimaryInteropAssemblyAttribute(int major, int minor);
-   public int MajorVersion { get; }
-   public int MinorVersion { get; }
  }
- public sealed class ProgIdAttribute : Attribute {
-   public ProgIdAttribute(string progId);
-   public string Value { get; }
  }
- public enum RegistrationClassContext {
-   DisableActivateAsActivator = 32768,
-   EnableActivateAsActivator = 65536,
-   EnableCodeDownload = 8192,
-   FromDefaultContext = 131072,
-   InProcessHandler = 2,
-   InProcessHandler16 = 32,
-   InProcessServer = 1,
-   InProcessServer16 = 8,
-   LocalServer = 4,
-   NoCodeDownload = 1024,
-   NoCustomMarshal = 4096,
-   NoFailureLog = 16384,
-   RemoteServer = 16,
-   Reserved1 = 64,
-   Reserved2 = 128,
-   Reserved3 = 256,
-   Reserved4 = 512,
-   Reserved5 = 2048,
  }
- public enum RegistrationConnectionType {
-   MultipleUse = 1,
-   MultiSeparate = 2,
-   SingleUse = 0,
-   Surrogate = 8,
-   Suspended = 4,
  }
- public class RegistrationServices : IRegistrationServices {
-   public RegistrationServices();
-   public virtual Guid GetManagedCategoryGuid();
-   public virtual string GetProgIdForType(Type type);
-   public virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly);
-   public virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
-   public virtual void RegisterTypeForComClients(Type type, ref Guid g);
-   public virtual int RegisterTypeForComClients(Type type, RegistrationClassContext classContext, RegistrationConnectionType flags);
-   public virtual bool TypeRepresentsComType(Type type);
-   public virtual bool TypeRequiresRegistration(Type type);
-   public virtual bool UnregisterAssembly(Assembly assembly);
-   public virtual void UnregisterTypeForComClients(int cookie);
  }
- public class RuntimeEnvironment {
-   public RuntimeEnvironment();
-   public static string SystemConfigurationFile { get; }
-   public static bool FromGlobalAccessCache(Assembly a);
-   public static string GetRuntimeDirectory();
-   public static IntPtr GetRuntimeInterfaceAsIntPtr(Guid clsid, Guid riid);
-   public static object GetRuntimeInterfaceAsObject(Guid clsid, Guid riid);
-   [MethodImpl(NoInlining)]public static string GetSystemVersion();
  }
- public class SafeArrayRankMismatchException : SystemException {
-   public SafeArrayRankMismatchException();
-   protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
-   public SafeArrayRankMismatchException(string message);
-   public SafeArrayRankMismatchException(string message, Exception inner);
  }
- public class SafeArrayTypeMismatchException : SystemException {
-   public SafeArrayTypeMismatchException();
-   protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
-   public SafeArrayTypeMismatchException(string message);
-   public SafeArrayTypeMismatchException(string message, Exception inner);
  }
- public abstract class SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
-   protected SafeBuffer(bool ownsHandle);
-   public ulong ByteLength { get; }
-   public unsafe void AcquirePointer(ref byte* pointer);
-   public void Initialize(uint numElements, uint sizeOfEachElement);
-   public void Initialize(ulong numBytes);
-   public void Initialize<T>(uint numElements) where T : struct;
-   public T Read<T>(ulong byteOffset) where T : struct;
-   public void ReadArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct;
-   public void ReleasePointer();
-   public void Write<T>(ulong byteOffset, T value) where T : struct;
-   public void WriteArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct;
  }
- public abstract class SafeHandle : CriticalFinalizerObject, IDisposable {
-   protected IntPtr handle;
-   protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
-   public bool IsClosed { get; }
-   public abstract bool IsInvalid { get; }
-   public void Close();
-   [MethodImpl(InternalCall)]public void DangerousAddRef(ref bool success);
-   public IntPtr DangerousGetHandle();
-   [MethodImpl(InternalCall)]public void DangerousRelease();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~SafeHandle();
-   protected abstract bool ReleaseHandle();
-   protected void SetHandle(IntPtr handle);
-   [MethodImpl(InternalCall)]public void SetHandleAsInvalid();
  }
- public class SEHException : ExternalException {
-   public SEHException();
-   protected SEHException(SerializationInfo info, StreamingContext context);
-   public SEHException(string message);
-   public SEHException(string message, Exception inner);
-   public virtual bool CanResume();
  }
- public sealed class SetWin32ContextInIDispatchAttribute : Attribute {
-   public SetWin32ContextInIDispatchAttribute();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct STATSTG {
-   public Guid clsid;
-   public int grfLocksSupported;
-   public int grfMode;
-   public int grfStateBits;
-   public int reserved;
-   public int type;
-   public long cbSize;
-   public FILETIME atime;
-   public FILETIME ctime;
-   public FILETIME mtime;
-   public string pwcsName;
  }
  public sealed class StructLayoutAttribute : Attribute {
    public int Pack;
    public int Size;
    public CharSet CharSet;
-   public StructLayoutAttribute(short layoutKind);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public LayoutKind Value { get; }
  }
- public enum SYSKIND {
-   SYS_MAC = 2,
-   SYS_WIN16 = 0,
-   SYS_WIN32 = 1,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPEATTR {
-   public Guid guid;
-   public short cbAlignment;
-   public short cbSizeVft;
-   public short cFuncs;
-   public short cImplTypes;
-   public short cVars;
-   public short wMajorVerNum;
-   public short wMinorVerNum;
-   public int cbSizeInstance;
-   public int dwReserved;
-   public int lcid;
-   public const int MEMBER_ID_NIL = -1;
-   public int memidConstructor;
-   public int memidDestructor;
-   public IntPtr lpstrSchema;
-   public IDLDESC idldescType;
-   public TYPEDESC tdescAlias;
-   public TYPEFLAGS wTypeFlags;
-   public TYPEKIND typekind;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPEDESC {
-   public short vt;
-   public IntPtr lpValue;
  }
- public enum TYPEFLAGS : short {
-   TYPEFLAG_FAGGREGATABLE = (short)1024,
-   TYPEFLAG_FAPPOBJECT = (short)1,
-   TYPEFLAG_FCANCREATE = (short)2,
-   TYPEFLAG_FCONTROL = (short)32,
-   TYPEFLAG_FDISPATCHABLE = (short)4096,
-   TYPEFLAG_FDUAL = (short)64,
-   TYPEFLAG_FHIDDEN = (short)16,
-   TYPEFLAG_FLICENSED = (short)4,
-   TYPEFLAG_FNONEXTENSIBLE = (short)128,
-   TYPEFLAG_FOLEAUTOMATION = (short)256,
-   TYPEFLAG_FPREDECLID = (short)8,
-   TYPEFLAG_FPROXY = (short)16384,
-   TYPEFLAG_FREPLACEABLE = (short)2048,
-   TYPEFLAG_FRESTRICTED = (short)512,
-   TYPEFLAG_FREVERSEBIND = (short)8192,
  }
- public sealed class TypeIdentifierAttribute : Attribute {
-   public TypeIdentifierAttribute();
-   public TypeIdentifierAttribute(string scope, string identifier);
-   public string Identifier { get; }
-   public string Scope { get; }
  }
- public enum TYPEKIND {
-   TKIND_ALIAS = 6,
-   TKIND_COCLASS = 5,
-   TKIND_DISPATCH = 4,
-   TKIND_ENUM = 0,
-   TKIND_INTERFACE = 3,
-   TKIND_MAX = 8,
-   TKIND_MODULE = 2,
-   TKIND_RECORD = 1,
-   TKIND_UNION = 7,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPELIBATTR {
-   public Guid guid;
-   public short wMajorVerNum;
-   public short wMinorVerNum;
-   public int lcid;
-   public LIBFLAGS wLibFlags;
-   public SYSKIND syskind;
  }
- public sealed class TypeLibConverter : ITypeLibConverter {
-   public TypeLibConverter();
-   public object ConvertAssemblyToTypeLib(Assembly assembly, string strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
-   public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
-   public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
-   public bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, out string asmName, out string asmCodeBase);
  }
- public enum TypeLibExporterFlags {
-   CallerResolvedReferences = 2,
-   ExportAs32Bit = 16,
-   ExportAs64Bit = 32,
-   None = 0,
-   OldNames = 4,
-   OnlyReferenceRegistered = 1,
  }
- public sealed class TypeLibFuncAttribute : Attribute {
-   public TypeLibFuncAttribute(short flags);
-   public TypeLibFuncAttribute(TypeLibFuncFlags flags);
-   public TypeLibFuncFlags Value { get; }
  }
- public enum TypeLibFuncFlags {
-   FBindable = 4,
-   FDefaultBind = 32,
-   FDefaultCollelem = 256,
-   FDisplayBind = 16,
-   FHidden = 64,
-   FImmediateBind = 4096,
-   FNonBrowsable = 1024,
-   FReplaceable = 2048,
-   FRequestEdit = 8,
-   FRestricted = 1,
-   FSource = 2,
-   FUiDefault = 512,
-   FUsesGetLastError = 128,
  }
- public sealed class TypeLibImportClassAttribute : Attribute {
-   public TypeLibImportClassAttribute(Type importClass);
-   public string Value { get; }
  }
- public enum TypeLibImporterFlags {
-   ImportAsAgnostic = 2048,
-   ImportAsArm = 16384,
-   ImportAsItanium = 1024,
-   ImportAsX64 = 512,
-   ImportAsX86 = 256,
-   NoDefineVersionResource = 8192,
-   None = 0,
-   PreventClassMembers = 16,
-   PrimaryInteropAssembly = 1,
-   ReflectionOnlyLoading = 4096,
-   SafeArrayAsSystemArray = 4,
-   SerializableValueClasses = 32,
-   TransformDispRetVals = 8,
-   UnsafeInterfaces = 2,
  }
- public sealed class TypeLibTypeAttribute : Attribute {
-   public TypeLibTypeAttribute(short flags);
-   public TypeLibTypeAttribute(TypeLibTypeFlags flags);
-   public TypeLibTypeFlags Value { get; }
  }
- public enum TypeLibTypeFlags {
-   FAggregatable = 1024,
-   FAppObject = 1,
-   FCanCreate = 2,
-   FControl = 32,
-   FDispatchable = 4096,
-   FDual = 64,
-   FHidden = 16,
-   FLicensed = 4,
-   FNonExtensible = 128,
-   FOleAutomation = 256,
-   FPreDeclId = 8,
-   FReplaceable = 2048,
-   FRestricted = 512,
-   FReverseBind = 8192,
  }
- public sealed class TypeLibVarAttribute : Attribute {
-   public TypeLibVarAttribute(short flags);
-   public TypeLibVarAttribute(TypeLibVarFlags flags);
-   public TypeLibVarFlags Value { get; }
  }
- public enum TypeLibVarFlags {
-   FBindable = 4,
-   FDefaultBind = 32,
-   FDefaultCollelem = 256,
-   FDisplayBind = 16,
-   FHidden = 64,
-   FImmediateBind = 4096,
-   FNonBrowsable = 1024,
-   FReadOnly = 1,
-   FReplaceable = 2048,
-   FRequestEdit = 8,
-   FRestricted = 128,
-   FSource = 2,
-   FUiDefault = 512,
  }
- public sealed class TypeLibVersionAttribute : Attribute {
-   public TypeLibVersionAttribute(int major, int minor);
-   public int MajorVersion { get; }
-   public int MinorVersion { get; }
  }
- public interface UCOMIBindCtx {
-   void EnumObjectParam(out UCOMIEnumString ppenum);
-   void GetBindOptions(ref BIND_OPTS pbindopts);
-   void GetObjectParam(string pszKey, out object ppunk);
-   void GetRunningObjectTable(out UCOMIRunningObjectTable pprot);
-   void RegisterObjectBound(object punk);
-   void RegisterObjectParam(string pszKey, object punk);
-   void ReleaseBoundObjects();
-   void RevokeObjectBound(object punk);
-   void RevokeObjectParam(string pszKey);
-   void SetBindOptions(ref BIND_OPTS pbindopts);
  }
- public interface UCOMIConnectionPoint {
-   void Advise(object pUnkSink, out int pdwCookie);
-   void EnumConnections(out UCOMIEnumConnections ppEnum);
-   void GetConnectionInterface(out Guid pIID);
-   void GetConnectionPointContainer(out UCOMIConnectionPointContainer ppCPC);
-   void Unadvise(int dwCookie);
  }
- public interface UCOMIConnectionPointContainer {
-   void EnumConnectionPoints(out UCOMIEnumConnectionPoints ppEnum);
-   void FindConnectionPoint(ref Guid riid, out UCOMIConnectionPoint ppCP);
  }
- public interface UCOMIEnumConnectionPoints {
-   void Clone(out UCOMIEnumConnectionPoints ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, UCOMIConnectionPoint[] rgelt, out int pceltFetched);
-   [MethodImpl(PreserveSig)]int Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface UCOMIEnumConnections {
-   void Clone(out UCOMIEnumConnections ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, CONNECTDATA[] rgelt, out int pceltFetched);
-   [MethodImpl(PreserveSig)]void Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface UCOMIEnumMoniker {
-   void Clone(out UCOMIEnumMoniker ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, UCOMIMoniker[] rgelt, out int pceltFetched);
-   [MethodImpl(PreserveSig)]int Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface UCOMIEnumString {
-   void Clone(out UCOMIEnumString ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, string[] rgelt, out int pceltFetched);
-   [MethodImpl(PreserveSig)]int Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface UCOMIEnumVARIANT {
-   void Clone(int ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, int rgvar, int pceltFetched);
-   [MethodImpl(PreserveSig)]int Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface UCOMIMoniker {
-   void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, ref Guid riidResult, out object ppvResult);
-   void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, ref Guid riid, out object ppvObj);
-   void CommonPrefixWith(UCOMIMoniker pmkOther, out UCOMIMoniker ppmkPrefix);
-   void ComposeWith(UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, out UCOMIMoniker ppmkComposite);
-   void Enum(bool fForward, out UCOMIEnumMoniker ppenumMoniker);
-   void GetClassID(out Guid pClassID);
-   void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, out string ppszDisplayName);
-   void GetSizeMax(out long pcbSize);
-   void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, out FILETIME pFileTime);
-   void Hash(out int pdwHash);
-   void Inverse(out UCOMIMoniker ppmk);
-   [MethodImpl(PreserveSig)]int IsDirty();
-   void IsEqual(UCOMIMoniker pmkOtherMoniker);
-   void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning);
-   void IsSystemMoniker(out int pdwMksys);
-   void Load(UCOMIStream pStm);
-   void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, string pszDisplayName, out int pchEaten, out UCOMIMoniker ppmkOut);
-   void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, ref UCOMIMoniker ppmkToLeft, out UCOMIMoniker ppmkReduced);
-   void RelativePathTo(UCOMIMoniker pmkOther, out UCOMIMoniker ppmkRelPath);
-   void Save(UCOMIStream pStm, bool fClearDirty);
  }
- public interface UCOMIPersistFile {
-   void GetClassID(out Guid pClassID);
-   void GetCurFile(out string ppszFileName);
-   [MethodImpl(PreserveSig)]int IsDirty();
-   void Load(string pszFileName, int dwMode);
-   void Save(string pszFileName, bool fRemember);
-   void SaveCompleted(string pszFileName);
  }
- public interface UCOMIRunningObjectTable {
-   void EnumRunning(out UCOMIEnumMoniker ppenumMoniker);
-   void GetObject(UCOMIMoniker pmkObjectName, out object ppunkObject);
-   void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, out FILETIME pfiletime);
-   void IsRunning(UCOMIMoniker pmkObjectName);
-   void NoteChangeTime(int dwRegister, ref FILETIME pfiletime);
-   void Register(int grfFlags, object punkObject, UCOMIMoniker pmkObjectName, out int pdwRegister);
-   void Revoke(int dwRegister);
  }
- public interface UCOMIStream {
-   void Clone(out UCOMIStream ppstm);
-   void Commit(int grfCommitFlags);
-   void CopyTo(UCOMIStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
-   void LockRegion(long libOffset, long cb, int dwLockType);
-   void Read(byte[] pv, int cb, IntPtr pcbRead);
-   void Revert();
-   void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
-   void SetSize(long libNewSize);
-   void Stat(out STATSTG pstatstg, int grfStatFlag);
-   void UnlockRegion(long libOffset, long cb, int dwLockType);
-   void Write(byte[] pv, int cb, IntPtr pcbWritten);
  }
- public interface UCOMITypeComp {
-   void Bind(string szName, int lHashVal, short wFlags, out UCOMITypeInfo ppTInfo, out DESCKIND pDescKind, out BINDPTR pBindPtr);
-   void BindType(string szName, int lHashVal, out UCOMITypeInfo ppTInfo, out UCOMITypeComp ppTComp);
  }
- public interface UCOMITypeInfo {
-   void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
-   void CreateInstance(object pUnkOuter, ref Guid riid, out object ppvObj);
-   void GetContainingTypeLib(out UCOMITypeLib ppTLB, out int pIndex);
-   void GetDllEntry(int memid, INVOKEKIND invKind, out string pBstrDllName, out string pBstrName, out short pwOrdinal);
-   void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetFuncDesc(int index, out IntPtr ppFuncDesc);
-   void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
-   void GetImplTypeFlags(int index, out int pImplTypeFlags);
-   void GetMops(int memid, out string pBstrMops);
-   void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
-   void GetRefTypeInfo(int hRef, out UCOMITypeInfo ppTI);
-   void GetRefTypeOfImplType(int index, out int href);
-   void GetTypeAttr(out IntPtr ppTypeAttr);
-   void GetTypeComp(out UCOMITypeComp ppTComp);
-   void GetVarDesc(int index, out IntPtr ppVarDesc);
-   void Invoke(object pvInstance, int memid, short wFlags, ref DISPPARAMS pDispParams, out object pVarResult, out EXCEPINFO pExcepInfo, out int puArgErr);
-   void ReleaseFuncDesc(IntPtr pFuncDesc);
-   void ReleaseTypeAttr(IntPtr pTypeAttr);
-   void ReleaseVarDesc(IntPtr pVarDesc);
  }
- public interface UCOMITypeLib {
-   void FindName(string szNameBuf, int lHashVal, UCOMITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
-   void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetLibAttr(out IntPtr ppTLibAttr);
-   void GetTypeComp(out UCOMITypeComp ppTComp);
-   void GetTypeInfo(int index, out UCOMITypeInfo ppTI);
-   [MethodImpl(PreserveSig)]int GetTypeInfoCount();
-   void GetTypeInfoOfGuid(ref Guid guid, out UCOMITypeInfo ppTInfo);
-   void GetTypeInfoType(int index, out TYPEKIND pTKind);
-   bool IsName(string szNameBuf, int lHashVal);
-   [MethodImpl(PreserveSig)]void ReleaseTLibAttr(IntPtr pTLibAttr);
  }
- public sealed class UnknownWrapper {
-   public UnknownWrapper(object obj);
-   public object WrappedObject { get; }
  }
- public sealed class UnmanagedFunctionPointerAttribute : Attribute {
-   public bool BestFitMapping;
-   public bool SetLastError;
-   public bool ThrowOnUnmappableChar;
-   public CharSet CharSet;
-   public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
-   public CallingConvention CallingConvention { get; }
  }
- public enum UnmanagedType {
-   AnsiBStr = 35,
-   AsAny = 40,
-   Bool = 2,
-   BStr = 19,
-   ByValArray = 30,
-   ByValTStr = 23,
-   Currency = 15,
-   CustomMarshaler = 44,
-   Error = 45,
-   FunctionPtr = 38,
-   HString = 47,
-   I1 = 3,
-   I2 = 5,
-   I4 = 7,
-   I8 = 9,
-   IDispatch = 26,
-   IInspectable = 46,
-   Interface = 28,
-   IUnknown = 25,
-   LPArray = 42,
-   LPStr = 20,
-   LPStruct = 43,
-   LPTStr = 22,
-   LPWStr = 21,
-   R4 = 11,
-   R8 = 12,
-   SafeArray = 29,
-   Struct = 27,
-   SysInt = 31,
-   SysUInt = 32,
-   TBStr = 36,
-   U1 = 4,
-   U2 = 6,
-   U4 = 8,
-   U8 = 10,
-   VariantBool = 37,
-   VBByRefStr = 34,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct VARDESC {
-   public short wVarFlags;
-   public int memid;
-   public ELEMDESC elemdescVar;
-   public VarEnum varkind;
-   public string lpstrSchema;
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct DESCUNION {
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public int oInst;
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public IntPtr lpvarValue;
    }
  }
- public enum VarEnum {
-   VT_ARRAY = 8192,
-   VT_BLOB = 65,
-   VT_BLOB_OBJECT = 70,
-   VT_BOOL = 11,
-   VT_BSTR = 8,
-   VT_BYREF = 16384,
-   VT_CARRAY = 28,
-   VT_CF = 71,
-   VT_CLSID = 72,
-   VT_CY = 6,
-   VT_DATE = 7,
-   VT_DECIMAL = 14,
-   VT_DISPATCH = 9,
-   VT_EMPTY = 0,
-   VT_ERROR = 10,
-   VT_FILETIME = 64,
-   VT_HRESULT = 25,
-   VT_I1 = 16,
-   VT_I2 = 2,
-   VT_I4 = 3,
-   VT_I8 = 20,
-   VT_INT = 22,
-   VT_LPSTR = 30,
-   VT_LPWSTR = 31,
-   VT_NULL = 1,
-   VT_PTR = 26,
-   VT_R4 = 4,
-   VT_R8 = 5,
-   VT_RECORD = 36,
-   VT_SAFEARRAY = 27,
-   VT_STORAGE = 67,
-   VT_STORED_OBJECT = 69,
-   VT_STREAM = 66,
-   VT_STREAMED_OBJECT = 68,
-   VT_UI1 = 17,
-   VT_UI2 = 18,
-   VT_UI4 = 19,
-   VT_UI8 = 21,
-   VT_UINT = 23,
-   VT_UNKNOWN = 13,
-   VT_USERDEFINED = 29,
-   VT_VARIANT = 12,
-   VT_VECTOR = 4096,
-   VT_VOID = 24,
  }
- public enum VARFLAGS : short {
-   VARFLAG_FBINDABLE = (short)4,
-   VARFLAG_FDEFAULTBIND = (short)32,
-   VARFLAG_FDEFAULTCOLLELEM = (short)256,
-   VARFLAG_FDISPLAYBIND = (short)16,
-   VARFLAG_FHIDDEN = (short)64,
-   VARFLAG_FIMMEDIATEBIND = (short)4096,
-   VARFLAG_FNONBROWSABLE = (short)1024,
-   VARFLAG_FREADONLY = (short)1,
-   VARFLAG_FREPLACEABLE = (short)2048,
-   VARFLAG_FREQUESTEDIT = (short)8,
-   VARFLAG_FRESTRICTED = (short)128,
-   VARFLAG_FSOURCE = (short)2,
-   VARFLAG_FUIDEFAULT = (short)512,
  }
- public sealed class VariantWrapper {
-   public VariantWrapper(object obj);
-   public object WrappedObject { get; }
  }
 }
-namespace System.Runtime.InteropServices.ComTypes {
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct BIND_OPTS {
-   public int cbStruct;
-   public int dwTickCountDeadline;
-   public int grfFlags;
-   public int grfMode;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
  public struct BINDPTR {
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lpfuncdesc;
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lptcomp;
-   [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
    public IntPtr lpvardesc;
  }
- public enum CALLCONV {
-   CC_CDECL = 1,
-   CC_MACPASCAL = 3,
-   CC_MAX = 9,
-   CC_MPWCDECL = 7,
-   CC_MPWPASCAL = 8,
-   CC_MSCPASCAL = 2,
-   CC_PASCAL = 2,
-   CC_RESERVED = 5,
-   CC_STDCALL = 4,
-   CC_SYSCALL = 6,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CONNECTDATA {
-   public int dwCookie;
-   public object pUnk;
  }
- public enum DESCKIND {
-   DESCKIND_FUNCDESC = 1,
-   DESCKIND_IMPLICITAPPOBJ = 4,
-   DESCKIND_MAX = 5,
-   DESCKIND_NONE = 0,
-   DESCKIND_TYPECOMP = 3,
-   DESCKIND_VARDESC = 2,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct DISPPARAMS {
-   public int cArgs;
-   public int cNamedArgs;
-   public IntPtr rgdispidNamedArgs;
-   public IntPtr rgvarg;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ELEMDESC {
-   public ELEMDESC.DESCUNION desc;
-   public TYPEDESC tdesc;
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct DESCUNION {
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public IDLDESC idldesc;
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public PARAMDESC paramdesc;
    }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct EXCEPINFO {
-   public short wCode;
-   public short wReserved;
-   public int dwHelpContext;
-   public int scode;
-   public IntPtr pfnDeferredFillIn;
-   public IntPtr pvReserved;
-   public string bstrDescription;
-   public string bstrHelpFile;
-   public string bstrSource;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct FILETIME {
-   public int dwHighDateTime;
-   public int dwLowDateTime;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct FUNCDESC {
-   public short cParams;
-   public short cParamsOpt;
-   public short cScodes;
-   public short oVft;
-   public short wFuncFlags;
-   public int memid;
-   public IntPtr lprgelemdescParam;
-   public IntPtr lprgscode;
-   public CALLCONV callconv;
-   public ELEMDESC elemdescFunc;
-   public FUNCKIND funckind;
-   public INVOKEKIND invkind;
  }
- public enum FUNCFLAGS : short {
-   FUNCFLAG_FBINDABLE = (short)4,
-   FUNCFLAG_FDEFAULTBIND = (short)32,
-   FUNCFLAG_FDEFAULTCOLLELEM = (short)256,
-   FUNCFLAG_FDISPLAYBIND = (short)16,
-   FUNCFLAG_FHIDDEN = (short)64,
-   FUNCFLAG_FIMMEDIATEBIND = (short)4096,
-   FUNCFLAG_FNONBROWSABLE = (short)1024,
-   FUNCFLAG_FREPLACEABLE = (short)2048,
-   FUNCFLAG_FREQUESTEDIT = (short)8,
-   FUNCFLAG_FRESTRICTED = (short)1,
-   FUNCFLAG_FSOURCE = (short)2,
-   FUNCFLAG_FUIDEFAULT = (short)512,
-   FUNCFLAG_FUSESGETLASTERROR = (short)128,
  }
- public enum FUNCKIND {
-   FUNC_DISPATCH = 4,
-   FUNC_NONVIRTUAL = 2,
-   FUNC_PUREVIRTUAL = 1,
-   FUNC_STATIC = 3,
-   FUNC_VIRTUAL = 0,
  }
- public interface IBindCtx {
-   void EnumObjectParam(out IEnumString ppenum);
-   void GetBindOptions(ref BIND_OPTS pbindopts);
-   void GetObjectParam(string pszKey, out object ppunk);
-   void GetRunningObjectTable(out IRunningObjectTable pprot);
-   void RegisterObjectBound(object punk);
-   void RegisterObjectParam(string pszKey, object punk);
-   void ReleaseBoundObjects();
-   void RevokeObjectBound(object punk);
-   [MethodImpl(PreserveSig)]int RevokeObjectParam(string pszKey);
-   void SetBindOptions(ref BIND_OPTS pbindopts);
  }
- public interface IConnectionPoint {
-   void Advise(object pUnkSink, out int pdwCookie);
-   void EnumConnections(out IEnumConnections ppEnum);
-   void GetConnectionInterface(out Guid pIID);
-   void GetConnectionPointContainer(out IConnectionPointContainer ppCPC);
-   void Unadvise(int dwCookie);
  }
- public interface IConnectionPointContainer {
-   void EnumConnectionPoints(out IEnumConnectionPoints ppEnum);
-   void FindConnectionPoint(ref Guid riid, out IConnectionPoint ppCP);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct IDLDESC {
-   public IntPtr dwReserved;
-   public IDLFLAG wIDLFlags;
  }
- public enum IDLFLAG : short {
-   IDLFLAG_FIN = (short)1,
-   IDLFLAG_FLCID = (short)4,
-   IDLFLAG_FOUT = (short)2,
-   IDLFLAG_FRETVAL = (short)8,
-   IDLFLAG_NONE = (short)0,
  }
- public interface IEnumConnectionPoints {
-   void Clone(out IEnumConnectionPoints ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
-   void Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface IEnumConnections {
-   void Clone(out IEnumConnections ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
-   void Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface IEnumMoniker {
-   void Clone(out IEnumMoniker ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
-   void Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface IEnumString {
-   void Clone(out IEnumString ppenum);
-   [MethodImpl(PreserveSig)]int Next(int celt, string[] rgelt, IntPtr pceltFetched);
-   void Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface IEnumVARIANT {
-   IEnumVARIANT Clone();
-   [MethodImpl(PreserveSig)]int Next(int celt, object[] rgVar, IntPtr pceltFetched);
-   [MethodImpl(PreserveSig)]int Reset();
-   [MethodImpl(PreserveSig)]int Skip(int celt);
  }
- public interface IMoniker {
-   void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, ref Guid riidResult, out object ppvResult);
-   void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, ref Guid riid, out object ppvObj);
-   void CommonPrefixWith(IMoniker pmkOther, out IMoniker ppmkPrefix);
-   void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, out IMoniker ppmkComposite);
-   void Enum(bool fForward, out IEnumMoniker ppenumMoniker);
-   void GetClassID(out Guid pClassID);
-   void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, out string ppszDisplayName);
-   void GetSizeMax(out long pcbSize);
-   void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, out FILETIME pFileTime);
-   void Hash(out int pdwHash);
-   void Inverse(out IMoniker ppmk);
-   [MethodImpl(PreserveSig)]int IsDirty();
-   [MethodImpl(PreserveSig)]int IsEqual(IMoniker pmkOtherMoniker);
-   [MethodImpl(PreserveSig)]int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
-   [MethodImpl(PreserveSig)]int IsSystemMoniker(out int pdwMksys);
-   void Load(IStream pStm);
-   void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, out int pchEaten, out IMoniker ppmkOut);
-   void Reduce(IBindCtx pbc, int dwReduceHowFar, ref IMoniker ppmkToLeft, out IMoniker ppmkReduced);
-   void RelativePathTo(IMoniker pmkOther, out IMoniker ppmkRelPath);
-   void Save(IStream pStm, bool fClearDirty);
  }
- public enum IMPLTYPEFLAGS {
-   IMPLTYPEFLAG_FDEFAULT = 1,
-   IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
-   IMPLTYPEFLAG_FRESTRICTED = 4,
-   IMPLTYPEFLAG_FSOURCE = 2,
  }
- public enum INVOKEKIND {
-   INVOKE_FUNC = 1,
-   INVOKE_PROPERTYGET = 2,
-   INVOKE_PROPERTYPUT = 4,
-   INVOKE_PROPERTYPUTREF = 8,
  }
- public interface IPersistFile {
-   void GetClassID(out Guid pClassID);
-   void GetCurFile(out string ppszFileName);
-   [MethodImpl(PreserveSig)]int IsDirty();
-   void Load(string pszFileName, int dwMode);
-   void Save(string pszFileName, bool fRemember);
-   void SaveCompleted(string pszFileName);
  }
- public interface IRunningObjectTable {
-   void EnumRunning(out IEnumMoniker ppenumMoniker);
-   [MethodImpl(PreserveSig)]int GetObject(IMoniker pmkObjectName, out object ppunkObject);
-   [MethodImpl(PreserveSig)]int GetTimeOfLastChange(IMoniker pmkObjectName, out FILETIME pfiletime);
-   [MethodImpl(PreserveSig)]int IsRunning(IMoniker pmkObjectName);
-   void NoteChangeTime(int dwRegister, ref FILETIME pfiletime);
-   int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
-   void Revoke(int dwRegister);
  }
- public interface IStream {
-   void Clone(out IStream ppstm);
-   void Commit(int grfCommitFlags);
-   void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
-   void LockRegion(long libOffset, long cb, int dwLockType);
-   void Read(byte[] pv, int cb, IntPtr pcbRead);
-   void Revert();
-   void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
-   void SetSize(long libNewSize);
-   void Stat(out STATSTG pstatstg, int grfStatFlag);
-   void UnlockRegion(long libOffset, long cb, int dwLockType);
-   void Write(byte[] pv, int cb, IntPtr pcbWritten);
  }
- public interface ITypeComp {
-   void Bind(string szName, int lHashVal, short wFlags, out ITypeInfo ppTInfo, out DESCKIND pDescKind, out BINDPTR pBindPtr);
-   void BindType(string szName, int lHashVal, out ITypeInfo ppTInfo, out ITypeComp ppTComp);
  }
- public interface ITypeInfo {
-   void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
-   void CreateInstance(object pUnkOuter, ref Guid riid, out object ppvObj);
-   void GetContainingTypeLib(out ITypeLib ppTLB, out int pIndex);
-   void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
-   void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetFuncDesc(int index, out IntPtr ppFuncDesc);
-   void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
-   void GetImplTypeFlags(int index, out IMPLTYPEFLAGS pImplTypeFlags);
-   void GetMops(int memid, out string pBstrMops);
-   void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
-   void GetRefTypeInfo(int hRef, out ITypeInfo ppTI);
-   void GetRefTypeOfImplType(int index, out int href);
-   void GetTypeAttr(out IntPtr ppTypeAttr);
-   void GetTypeComp(out ITypeComp ppTComp);
-   void GetVarDesc(int index, out IntPtr ppVarDesc);
-   void Invoke(object pvInstance, int memid, short wFlags, ref DISPPARAMS pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, out int puArgErr);
-   [MethodImpl(PreserveSig)]void ReleaseFuncDesc(IntPtr pFuncDesc);
-   [MethodImpl(PreserveSig)]void ReleaseTypeAttr(IntPtr pTypeAttr);
-   [MethodImpl(PreserveSig)]void ReleaseVarDesc(IntPtr pVarDesc);
  }
- public interface ITypeInfo2 : ITypeInfo {
-   new void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
-   new void CreateInstance(object pUnkOuter, ref Guid riid, out object ppvObj);
-   void GetAllCustData(IntPtr pCustData);
-   void GetAllFuncCustData(int index, IntPtr pCustData);
-   void GetAllImplTypeCustData(int index, IntPtr pCustData);
-   void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
-   void GetAllVarCustData(int index, IntPtr pCustData);
-   new void GetContainingTypeLib(out ITypeLib ppTLB, out int pIndex);
-   void GetCustData(ref Guid guid, out object pVarVal);
-   new void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
-   new void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetDocumentation2(int memid, out string pbstrHelpString, out int pdwHelpStringContext, out string pbstrHelpStringDll);
-   void GetFuncCustData(int index, ref Guid guid, out object pVarVal);
-   new void GetFuncDesc(int index, out IntPtr ppFuncDesc);
-   void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, out int pFuncIndex);
-   new void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
-   void GetImplTypeCustData(int index, ref Guid guid, out object pVarVal);
-   new void GetImplTypeFlags(int index, out IMPLTYPEFLAGS pImplTypeFlags);
-   new void GetMops(int memid, out string pBstrMops);
-   new void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
-   void GetParamCustData(int indexFunc, int indexParam, ref Guid guid, out object pVarVal);
-   new void GetRefTypeInfo(int hRef, out ITypeInfo ppTI);
-   new void GetRefTypeOfImplType(int index, out int href);
-   new void GetTypeAttr(out IntPtr ppTypeAttr);
-   new void GetTypeComp(out ITypeComp ppTComp);
-   void GetTypeFlags(out int pTypeFlags);
-   void GetTypeKind(out TYPEKIND pTypeKind);
-   void GetVarCustData(int index, ref Guid guid, out object pVarVal);
-   new void GetVarDesc(int index, out IntPtr ppVarDesc);
-   void GetVarIndexOfMemId(int memid, out int pVarIndex);
-   new void Invoke(object pvInstance, int memid, short wFlags, ref DISPPARAMS pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, out int puArgErr);
-   [MethodImpl(PreserveSig)]new void ReleaseFuncDesc(IntPtr pFuncDesc);
-   [MethodImpl(PreserveSig)]new void ReleaseTypeAttr(IntPtr pTypeAttr);
-   [MethodImpl(PreserveSig)]new void ReleaseVarDesc(IntPtr pVarDesc);
  }
- public interface ITypeLib {
-   void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
-   void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetLibAttr(out IntPtr ppTLibAttr);
-   void GetTypeComp(out ITypeComp ppTComp);
-   void GetTypeInfo(int index, out ITypeInfo ppTI);
-   [MethodImpl(PreserveSig)]int GetTypeInfoCount();
-   void GetTypeInfoOfGuid(ref Guid guid, out ITypeInfo ppTInfo);
-   void GetTypeInfoType(int index, out TYPEKIND pTKind);
-   bool IsName(string szNameBuf, int lHashVal);
-   [MethodImpl(PreserveSig)]void ReleaseTLibAttr(IntPtr pTLibAttr);
  }
- public interface ITypeLib2 : ITypeLib {
-   new void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
-   void GetAllCustData(IntPtr pCustData);
-   void GetCustData(ref Guid guid, out object pVarVal);
-   new void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-   void GetDocumentation2(int index, out string pbstrHelpString, out int pdwHelpStringContext, out string pbstrHelpStringDll);
-   new void GetLibAttr(out IntPtr ppTLibAttr);
-   void GetLibStatistics(IntPtr pcUniqueNames, out int pcchUniqueNames);
-   new void GetTypeComp(out ITypeComp ppTComp);
-   new void GetTypeInfo(int index, out ITypeInfo ppTI);
-   [MethodImpl(PreserveSig)]new int GetTypeInfoCount();
-   new void GetTypeInfoOfGuid(ref Guid guid, out ITypeInfo ppTInfo);
-   new void GetTypeInfoType(int index, out TYPEKIND pTKind);
-   new bool IsName(string szNameBuf, int lHashVal);
-   [MethodImpl(PreserveSig)]new void ReleaseTLibAttr(IntPtr pTLibAttr);
  }
- public enum LIBFLAGS : short {
-   LIBFLAG_FCONTROL = (short)2,
-   LIBFLAG_FHASDISKIMAGE = (short)8,
-   LIBFLAG_FHIDDEN = (short)4,
-   LIBFLAG_FRESTRICTED = (short)1,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct PARAMDESC {
-   public IntPtr lpVarValue;
-   public PARAMFLAG wParamFlags;
  }
- public enum PARAMFLAG : short {
-   PARAMFLAG_FHASCUSTDATA = (short)64,
-   PARAMFLAG_FHASDEFAULT = (short)32,
-   PARAMFLAG_FIN = (short)1,
-   PARAMFLAG_FLCID = (short)4,
-   PARAMFLAG_FOPT = (short)16,
-   PARAMFLAG_FOUT = (short)2,
-   PARAMFLAG_FRETVAL = (short)8,
-   PARAMFLAG_NONE = (short)0,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct STATSTG {
-   public Guid clsid;
-   public int grfLocksSupported;
-   public int grfMode;
-   public int grfStateBits;
-   public int reserved;
-   public int type;
-   public long cbSize;
-   public FILETIME atime;
-   public FILETIME ctime;
-   public FILETIME mtime;
-   public string pwcsName;
  }
- public enum SYSKIND {
-   SYS_MAC = 2,
-   SYS_WIN16 = 0,
-   SYS_WIN32 = 1,
-   SYS_WIN64 = 3,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPEATTR {
-   public Guid guid;
-   public short cbAlignment;
-   public short cbSizeVft;
-   public short cFuncs;
-   public short cImplTypes;
-   public short cVars;
-   public short wMajorVerNum;
-   public short wMinorVerNum;
-   public int cbSizeInstance;
-   public int dwReserved;
-   public int lcid;
-   public const int MEMBER_ID_NIL = -1;
-   public int memidConstructor;
-   public int memidDestructor;
-   public IntPtr lpstrSchema;
-   public IDLDESC idldescType;
-   public TYPEDESC tdescAlias;
-   public TYPEFLAGS wTypeFlags;
-   public TYPEKIND typekind;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPEDESC {
-   public short vt;
-   public IntPtr lpValue;
  }
- public enum TYPEFLAGS : short {
-   TYPEFLAG_FAGGREGATABLE = (short)1024,
-   TYPEFLAG_FAPPOBJECT = (short)1,
-   TYPEFLAG_FCANCREATE = (short)2,
-   TYPEFLAG_FCONTROL = (short)32,
-   TYPEFLAG_FDISPATCHABLE = (short)4096,
-   TYPEFLAG_FDUAL = (short)64,
-   TYPEFLAG_FHIDDEN = (short)16,
-   TYPEFLAG_FLICENSED = (short)4,
-   TYPEFLAG_FNONEXTENSIBLE = (short)128,
-   TYPEFLAG_FOLEAUTOMATION = (short)256,
-   TYPEFLAG_FPREDECLID = (short)8,
-   TYPEFLAG_FPROXY = (short)16384,
-   TYPEFLAG_FREPLACEABLE = (short)2048,
-   TYPEFLAG_FRESTRICTED = (short)512,
-   TYPEFLAG_FREVERSEBIND = (short)8192,
  }
- public enum TYPEKIND {
-   TKIND_ALIAS = 6,
-   TKIND_COCLASS = 5,
-   TKIND_DISPATCH = 4,
-   TKIND_ENUM = 0,
-   TKIND_INTERFACE = 3,
-   TKIND_MAX = 8,
-   TKIND_MODULE = 2,
-   TKIND_RECORD = 1,
-   TKIND_UNION = 7,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct TYPELIBATTR {
-   public Guid guid;
-   public short wMajorVerNum;
-   public short wMinorVerNum;
-   public int lcid;
-   public LIBFLAGS wLibFlags;
-   public SYSKIND syskind;
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct VARDESC {
-   public VARDESC.DESCUNION desc;
-   public short wVarFlags;
-   public int memid;
-   public ELEMDESC elemdescVar;
-   public VARKIND varkind;
-   public string lpstrSchema;
-   [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct DESCUNION {
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public int oInst;
-     [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
      public IntPtr lpvarValue;
    }
  }
- public enum VARFLAGS : short {
-   VARFLAG_FBINDABLE = (short)4,
-   VARFLAG_FDEFAULTBIND = (short)32,
-   VARFLAG_FDEFAULTCOLLELEM = (short)256,
-   VARFLAG_FDISPLAYBIND = (short)16,
-   VARFLAG_FHIDDEN = (short)64,
-   VARFLAG_FIMMEDIATEBIND = (short)4096,
-   VARFLAG_FNONBROWSABLE = (short)1024,
-   VARFLAG_FREADONLY = (short)1,
-   VARFLAG_FREPLACEABLE = (short)2048,
-   VARFLAG_FREQUESTEDIT = (short)8,
-   VARFLAG_FRESTRICTED = (short)128,
-   VARFLAG_FSOURCE = (short)2,
-   VARFLAG_FUIDEFAULT = (short)512,
  }
- public enum VARKIND {
-   VAR_CONST = 2,
-   VAR_DISPATCH = 3,
-   VAR_PERINSTANCE = 0,
-   VAR_STATIC = 1,
  }
 }
-namespace System.Runtime.InteropServices.Expando {
- public interface IExpando : IReflect {
-   FieldInfo AddField(string name);
-   MethodInfo AddMethod(string name, Delegate method);
-   PropertyInfo AddProperty(string name);
-   void RemoveMember(MemberInfo m);
  }
 }
-namespace System.Runtime.InteropServices.WindowsRuntime {
- public sealed class DefaultInterfaceAttribute : Attribute {
-   public DefaultInterfaceAttribute(Type defaultInterface);
-   public Type DefaultInterface { get; }
  }
- public class DesignerNamespaceResolveEventArgs : EventArgs {
-   public DesignerNamespaceResolveEventArgs(string namespaceName);
-   public string NamespaceName { get; }
-   public Collection<string> ResolvedAssemblyFiles { get; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct EventRegistrationToken {
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public static bool operator ==(EventRegistrationToken left, EventRegistrationToken right);
-   public static bool operator !=(EventRegistrationToken left, EventRegistrationToken right);
  }
- public sealed class EventRegistrationTokenTable<T> where T : class {
-   public EventRegistrationTokenTable();
-   public T InvocationList { get; set; }
-   public EventRegistrationToken AddEventHandler(T handler);
-   public static EventRegistrationTokenTable<T> GetOrCreateEventRegistrationTokenTable(ref EventRegistrationTokenTable<T> refEventTable);
-   public void RemoveEventHandler(EventRegistrationToken token);
-   public void RemoveEventHandler(T handler);
  }
- public interface IActivationFactory {
-   object ActivateInstance();
  }
- public sealed class InterfaceImplementedInVersionAttribute : Attribute {
-   public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
-   public byte BuildVersion { get; }
-   public Type InterfaceType { get; }
-   public byte MajorVersion { get; }
-   public byte MinorVersion { get; }
-   public byte RevisionVersion { get; }
  }
- public class NamespaceResolveEventArgs : EventArgs {
-   public NamespaceResolveEventArgs(string namespaceName, Assembly requestingAssembly);
-   public string NamespaceName { get; }
-   public Assembly RequestingAssembly { get; }
-   public Collection<Assembly> ResolvedAssemblies { get; }
  }
- public sealed class ReadOnlyArrayAttribute : Attribute {
-   public ReadOnlyArrayAttribute();
  }
- public sealed class ReturnValueNameAttribute : Attribute {
-   public ReturnValueNameAttribute(string name);
-   public string Name { get; }
  }
- public static class WindowsRuntimeMarshal {
-   public static void AddEventHandler<T>(Func<T, EventRegistrationToken> addMethod, Action<EventRegistrationToken> removeMethod, T handler);
-   public static void FreeHString(IntPtr ptr);
-   public static IActivationFactory GetActivationFactory(Type type);
-   public static string PtrToStringHString(IntPtr ptr);
-   public static void RemoveAllEventHandlers(Action<EventRegistrationToken> removeMethod);
-   public static void RemoveEventHandler<T>(Action<EventRegistrationToken> removeMethod, T handler);
-   public static IntPtr StringToHString(string s);
  }
- public static class WindowsRuntimeMetadata {
-   public static event EventHandler<DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve;
-   public static event EventHandler<NamespaceResolveEventArgs> ReflectionOnlyNamespaceResolve;
-   public static IEnumerable<string> ResolveNamespace(string namespaceName, IEnumerable<string> packageGraphFilePaths);
-   public static IEnumerable<string> ResolveNamespace(string namespaceName, string windowsSdkFilePath, IEnumerable<string> packageGraphFilePaths);
  }
- public sealed class WriteOnlyArrayAttribute : Attribute {
-   public WriteOnlyArrayAttribute();
  }
 }
-namespace System.Runtime.Remoting {
- public class ActivatedClientTypeEntry : TypeEntry {
-   public ActivatedClientTypeEntry(string typeName, string assemblyName, string appUrl);
-   public ActivatedClientTypeEntry(Type type, string appUrl);
-   public string ApplicationUrl { get; }
-   public IContextAttribute[] ContextAttributes { get; set; }
-   public Type ObjectType { [MethodImpl(NoInlining)]get; }
-   public override string ToString();
  }
- public class ActivatedServiceTypeEntry : TypeEntry {
-   public ActivatedServiceTypeEntry(string typeName, string assemblyName);
-   public ActivatedServiceTypeEntry(Type type);
-   public IContextAttribute[] ContextAttributes { get; set; }
-   public Type ObjectType { [MethodImpl(NoInlining)]get; }
-   public override string ToString();
  }
- public enum CustomErrorsModes {
-   Off = 1,
-   On = 0,
-   RemoteOnly = 2,
  }
- public interface IChannelInfo {
-   object[] ChannelData { get; set; }
  }
- public interface IEnvoyInfo {
-   IMessageSink EnvoySinks { get; set; }
  }
- public class InternalRemotingServices {
-   public InternalRemotingServices();
-   public static void DebugOutChnl(string s);
-   public static SoapAttribute GetCachedSoapAttribute(object reflectionObject);
-   public static void RemotingAssert(bool condition, string message);
-   public static void RemotingTrace(params object[] messages);
-   public static void SetServerIdentity(MethodCall m, object srvID);
  }
- public interface IObjectHandle {
-   object Unwrap();
  }
- public interface IRemotingTypeInfo {
-   string TypeName { get; set; }
-   bool CanCastTo(Type fromType, object o);
  }
- public class ObjectHandle : MarshalByRefObject, IObjectHandle {
-   public ObjectHandle(object o);
-   public override object InitializeLifetimeService();
-   public object Unwrap();
  }
- public class ObjRef : IObjectReference, ISerializable {
-   public ObjRef();
-   public ObjRef(MarshalByRefObject o, Type requestedType);
-   protected ObjRef(SerializationInfo info, StreamingContext context);
-   public virtual IChannelInfo ChannelInfo { get; set; }
-   public virtual IEnvoyInfo EnvoyInfo { get; set; }
-   public virtual IRemotingTypeInfo TypeInfo { get; set; }
-   public virtual string URI { get; set; }
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual object GetRealObject(StreamingContext context);
-   public bool IsFromThisAppDomain();
-   public bool IsFromThisProcess();
  }
- public static class RemotingConfiguration {
-   public static string ApplicationId { get; }
-   public static string ApplicationName { get; set; }
-   public static CustomErrorsModes CustomErrorsMode { get; set; }
-   public static string ProcessId { get; }
-   public static void Configure(string filename);
-   public static void Configure(string filename, bool ensureSecurity);
-   public static bool CustomErrorsEnabled(bool isLocalRequest);
-   public static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes();
-   public static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes();
-   public static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes();
-   public static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes();
-   public static bool IsActivationAllowed(Type svrType);
-   public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName);
-   public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType);
-   public static WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName);
-   public static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType);
-   public static void RegisterActivatedClientType(ActivatedClientTypeEntry entry);
-   public static void RegisterActivatedClientType(Type type, string appUrl);
-   public static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry);
-   public static void RegisterActivatedServiceType(Type type);
-   public static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry);
-   public static void RegisterWellKnownClientType(Type type, string objectUrl);
-   public static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry);
-   public static void RegisterWellKnownServiceType(Type type, string objectUri, WellKnownObjectMode mode);
  }
- public class RemotingException : SystemException {
-   public RemotingException();
-   protected RemotingException(SerializationInfo info, StreamingContext context);
-   public RemotingException(string message);
-   public RemotingException(string message, Exception InnerException);
  }
- public static class RemotingServices {
-   public static object Connect(Type classToProxy, string url);
-   public static object Connect(Type classToProxy, string url, object data);
-   public static bool Disconnect(MarshalByRefObject obj);
-   public static IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg);
-   public static IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj);
-   public static object GetLifetimeService(MarshalByRefObject obj);
-   public static MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg);
-   public static void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
-   public static string GetObjectUri(MarshalByRefObject obj);
-   public static ObjRef GetObjRefForProxy(MarshalByRefObject obj);
-   [MethodImpl(InternalCall)]public static RealProxy GetRealProxy(object proxy);
-   public static Type GetServerTypeForUri(string URI);
-   public static string GetSessionIdForMethodMessage(IMethodMessage msg);
-   public static bool IsMethodOverloaded(IMethodMessage msg);
-   public static bool IsObjectOutOfAppDomain(object tp);
-   public static bool IsObjectOutOfContext(object tp);
-   public static bool IsOneWay(MethodBase method);
-   [MethodImpl(InternalCall)]public static bool IsTransparentProxy(object proxy);
-   public static void LogRemotingStage(int stage);
-   public static ObjRef Marshal(MarshalByRefObject Obj);
-   public static ObjRef Marshal(MarshalByRefObject Obj, string URI);
-   public static ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType);
-   public static void SetObjectUriForMarshal(MarshalByRefObject obj, string uri);
-   public static object Unmarshal(ObjRef objectRef);
-   public static object Unmarshal(ObjRef objectRef, bool fRefine);
  }
- public class RemotingTimeoutException : RemotingException {
-   public RemotingTimeoutException();
-   public RemotingTimeoutException(string message);
-   public RemotingTimeoutException(string message, Exception InnerException);
  }
- public class ServerException : SystemException {
-   public ServerException();
-   public ServerException(string message);
-   public ServerException(string message, Exception InnerException);
  }
- public class SoapServices {
-   public static string XmlNsForClrType { get; }
-   public static string XmlNsForClrTypeWithAssembly { get; }
-   public static string XmlNsForClrTypeWithNs { get; }
-   public static string XmlNsForClrTypeWithNsAndAssembly { get; }
-   public static string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
-   public static bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, out string typeNamespace, out string assemblyName);
-   public static void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType, string xmlAttribute, string xmlNamespace, out Type type, out string name);
-   public static void GetInteropFieldTypeAndNameFromXmlElement(Type containingType, string xmlElement, string xmlNamespace, out Type type, out string name);
-   public static Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace);
-   public static Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace);
-   public static string GetSoapActionFromMethodBase(MethodBase mb);
-   public static bool GetTypeAndMethodNameFromSoapAction(string soapAction, out string typeName, out string methodName);
-   public static bool GetXmlElementForInteropType(Type type, out string xmlElement, out string xmlNamespace);
-   public static string GetXmlNamespaceForMethodCall(MethodBase mb);
-   public static string GetXmlNamespaceForMethodResponse(MethodBase mb);
-   public static bool GetXmlTypeForInteropType(Type type, out string xmlType, out string xmlTypeNamespace);
-   public static bool IsClrTypeNamespace(string namespaceString);
-   public static bool IsSoapActionValidForMethodBase(string soapAction, MethodBase mb);
-   public static void PreLoad(Assembly assembly);
-   public static void PreLoad(Type type);
-   public static void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type);
-   public static void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type);
-   public static void RegisterSoapActionForMethodBase(MethodBase mb);
-   public static void RegisterSoapActionForMethodBase(MethodBase mb, string soapAction);
  }
- public class TypeEntry {
-   protected TypeEntry();
-   public string AssemblyName { get; set; }
-   public string TypeName { get; set; }
  }
- public class WellKnownClientTypeEntry : TypeEntry {
-   public WellKnownClientTypeEntry(string typeName, string assemblyName, string objectUrl);
-   public WellKnownClientTypeEntry(Type type, string objectUrl);
-   public string ApplicationUrl { get; set; }
-   public Type ObjectType { [MethodImpl(NoInlining)]get; }
-   public string ObjectUrl { get; }
-   public override string ToString();
  }
- public enum WellKnownObjectMode {
-   SingleCall = 2,
-   Singleton = 1,
  }
- public class WellKnownServiceTypeEntry : TypeEntry {
-   public WellKnownServiceTypeEntry(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode);
-   public WellKnownServiceTypeEntry(Type type, string objectUri, WellKnownObjectMode mode);
-   public IContextAttribute[] ContextAttributes { get; set; }
-   public WellKnownObjectMode Mode { get; }
-   public Type ObjectType { [MethodImpl(NoInlining)]get; }
-   public string ObjectUri { get; }
-   public override string ToString();
  }
 }
-namespace System.Runtime.Remoting.Activation {
- public enum ActivatorLevel {
-   AppDomain = 12,
-   Construction = 4,
-   Context = 8,
-   Machine = 20,
-   Process = 16,
  }
- public interface IActivator {
-   ActivatorLevel Level { get; }
-   IActivator NextActivator { get; set; }
-   IConstructionReturnMessage Activate(IConstructionCallMessage msg);
  }
- public interface IConstructionCallMessage : IMessage, IMethodCallMessage, IMethodMessage {
-   Type ActivationType { get; }
-   string ActivationTypeName { get; }
-   IActivator Activator { get; set; }
-   object[] CallSiteActivationAttributes { get; }
-   IList ContextProperties { get; }
  }
- public interface IConstructionReturnMessage : IMessage, IMethodMessage, IMethodReturnMessage {
  }
- public sealed class UrlAttribute : ContextAttribute {
-   public UrlAttribute(string callsiteURL);
-   public string UrlValue { get; }
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
-   public override bool IsContextOK(Context ctx, IConstructionCallMessage msg);
  }
 }
-namespace System.Runtime.Remoting.Channels {
- public abstract class BaseChannelObjectWithProperties : ICollection, IDictionary, IEnumerable {
-   protected BaseChannelObjectWithProperties();
-   public virtual int Count { get; }
-   public virtual bool IsFixedSize { get; }
-   public virtual bool IsReadOnly { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual ICollection Keys { get; }
-   public virtual IDictionary Properties { get; }
-   public virtual object SyncRoot { get; }
-   public virtual object this[object key] { get; set; }
-   public virtual ICollection Values { get; }
-   public virtual void Add(object key, object value);
-   public virtual void Clear();
-   public virtual bool Contains(object key);
-   public virtual void CopyTo(Array array, int index);
-   public virtual IDictionaryEnumerator GetEnumerator();
-   public virtual void Remove(object key);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public abstract class BaseChannelSinkWithProperties : BaseChannelObjectWithProperties {
-   protected BaseChannelSinkWithProperties();
  }
- public abstract class BaseChannelWithProperties : BaseChannelObjectWithProperties {
-   protected IChannelSinkBase SinksWithProperties;
-   protected BaseChannelWithProperties();
-   public override IDictionary Properties { get; }
  }
- public class ChannelDataStore : IChannelDataStore {
-   public ChannelDataStore(string[] channelURIs);
-   public string[] ChannelUris { get; set; }
-   public object this[object key] { get; set; }
  }
- public sealed class ChannelServices {
-   public static IChannel[] RegisteredChannels { get; }
-   public static IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink);
-   public static IServerChannelSink CreateServerChannelSinkChain(IServerChannelSinkProvider provider, IChannelReceiver channel);
-   public static ServerProcessing DispatchMessage(IServerChannelSinkStack sinkStack, IMessage msg, out IMessage replyMsg);
-   public static IChannel GetChannel(string name);
-   public static IDictionary GetChannelSinkProperties(object obj);
-   public static string[] GetUrlsForObject(MarshalByRefObject obj);
-   public static void RegisterChannel(IChannel chnl);
-   public static void RegisterChannel(IChannel chnl, bool ensureSecurity);
-   public static IMessage SyncDispatchMessage(IMessage msg);
-   public static void UnregisterChannel(IChannel chnl);
  }
- public class ClientChannelSinkStack : IClientChannelSinkStack, IClientResponseChannelSinkStack {
-   public ClientChannelSinkStack();
-   public ClientChannelSinkStack(IMessageSink replySink);
-   public void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
-   public void DispatchException(Exception e);
-   public void DispatchReplyMessage(IMessage msg);
-   public object Pop(IClientChannelSink sink);
-   public void Push(IClientChannelSink sink, object state);
  }
- public interface IChannel {
-   string ChannelName { get; }
-   int ChannelPriority { get; }
-   string Parse(string url, out string objectURI);
  }
- public interface IChannelDataStore {
-   string[] ChannelUris { get; }
-   object this[object key] { get; set; }
  }
- public interface IChannelReceiver : IChannel {
-   object ChannelData { get; }
-   string[] GetUrlsForUri(string objectURI);
-   void StartListening(object data);
-   void StopListening(object data);
  }
- public interface IChannelReceiverHook {
-   string ChannelScheme { get; }
-   IServerChannelSink ChannelSinkChain { get; }
-   bool WantsToListen { get; }
-   void AddHookChannelUri(string channelUri);
  }
- public interface IChannelSender : IChannel {
-   IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI);
  }
- public interface IChannelSinkBase {
-   IDictionary Properties { get; }
  }
- public interface IClientChannelSink : IChannelSinkBase {
-   IClientChannelSink NextChannelSink { get; }
-   void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
-   void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
-   Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
-   void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, out ITransportHeaders responseHeaders, out Stream responseStream);
  }
- public interface IClientChannelSinkProvider {
-   IClientChannelSinkProvider Next { get; set; }
-   IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
  }
- public interface IClientChannelSinkStack : IClientResponseChannelSinkStack {
-   object Pop(IClientChannelSink sink);
-   void Push(IClientChannelSink sink, object state);
  }
- public interface IClientFormatterSink : IChannelSinkBase, IClientChannelSink, IMessageSink {
  }
- public interface IClientFormatterSinkProvider : IClientChannelSinkProvider {
  }
- public interface IClientResponseChannelSinkStack {
-   void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
-   void DispatchException(Exception e);
-   void DispatchReplyMessage(IMessage msg);
  }
- public interface ISecurableChannel {
-   bool IsSecured { get; set; }
  }
- public interface IServerChannelSink : IChannelSinkBase {
-   IServerChannelSink NextChannelSink { get; }
-   void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
-   Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
-   ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream);
  }
- public interface IServerChannelSinkProvider {
-   IServerChannelSinkProvider Next { get; set; }
-   IServerChannelSink CreateSink(IChannelReceiver channel);
-   void GetChannelData(IChannelDataStore channelData);
  }
- public interface IServerChannelSinkStack : IServerResponseChannelSinkStack {
-   object Pop(IServerChannelSink sink);
-   void Push(IServerChannelSink sink, object state);
-   void ServerCallback(IAsyncResult ar);
-   void Store(IServerChannelSink sink, object state);
-   void StoreAndDispatch(IServerChannelSink sink, object state);
  }
- public interface IServerFormatterSinkProvider : IServerChannelSinkProvider {
  }
- public interface IServerResponseChannelSinkStack {
-   void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
-   Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
  }
- public interface ITransportHeaders {
-   object this[object key] { get; set; }
-   IEnumerator GetEnumerator();
  }
- public class ServerChannelSinkStack : IServerChannelSinkStack, IServerResponseChannelSinkStack {
-   public ServerChannelSinkStack();
-   public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
-   public Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
-   public object Pop(IServerChannelSink sink);
-   public void Push(IServerChannelSink sink, object state);
-   public void ServerCallback(IAsyncResult ar);
-   public void Store(IServerChannelSink sink, object state);
-   public void StoreAndDispatch(IServerChannelSink sink, object state);
  }
- public enum ServerProcessing {
-   Async = 2,
-   Complete = 0,
-   OneWay = 1,
  }
- public class SinkProviderData {
-   public SinkProviderData(string name);
-   public IList Children { get; }
-   public string Name { get; }
-   public IDictionary Properties { get; }
  }
- public class TransportHeaders : ITransportHeaders {
-   public TransportHeaders();
-   public object this[object key] { get; set; }
-   public IEnumerator GetEnumerator();
  }
 }
-namespace System.Runtime.Remoting.Contexts {
- public class Context {
-   public Context();
-   public virtual int ContextID { get; }
-   public virtual IContextProperty[] ContextProperties { get; }
-   public static Context DefaultContext { get; }
-   public static LocalDataStoreSlot AllocateDataSlot();
-   public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
-   public void DoCallBack(CrossContextDelegate deleg);
-   ~Context();
-   public static void FreeNamedDataSlot(string name);
-   public virtual void Freeze();
-   public static object GetData(LocalDataStoreSlot slot);
-   public static LocalDataStoreSlot GetNamedDataSlot(string name);
-   public virtual IContextProperty GetProperty(string name);
-   public static bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx);
-   public static void SetData(LocalDataStoreSlot slot, object data);
-   public virtual void SetProperty(IContextProperty prop);
-   public override string ToString();
-   public static bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx);
  }
- public class ContextAttribute : Attribute, IContextAttribute, IContextProperty {
-   protected string AttributeName;
-   public ContextAttribute(string name);
-   public virtual string Name { get; }
-   public override bool Equals(object o);
-   public virtual void Freeze(Context newContext);
-   public override int GetHashCode();
-   public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
-   public virtual bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg);
-   public virtual bool IsNewContextOK(Context newCtx);
  }
- public class ContextProperty {
-   public virtual string Name { get; }
-   public virtual object Property { get; }
  }
- public delegate void CrossContextDelegate();
- public interface IContextAttribute {
-   void GetPropertiesForNewContext(IConstructionCallMessage msg);
-   bool IsContextOK(Context ctx, IConstructionCallMessage msg);
  }
- public interface IContextProperty {
-   string Name { get; }
-   void Freeze(Context newContext);
-   bool IsNewContextOK(Context newCtx);
  }
- public interface IContextPropertyActivator {
-   void CollectFromClientContext(IConstructionCallMessage msg);
-   void CollectFromServerContext(IConstructionReturnMessage msg);
-   bool DeliverClientContextToServerContext(IConstructionCallMessage msg);
-   bool DeliverServerContextToClientContext(IConstructionReturnMessage msg);
-   bool IsOKToActivate(IConstructionCallMessage msg);
  }
- public interface IContributeClientContextSink {
-   IMessageSink GetClientContextSink(IMessageSink nextSink);
  }
- public interface IContributeDynamicSink {
-   IDynamicMessageSink GetDynamicSink();
  }
- public interface IContributeEnvoySink {
-   IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink);
  }
- public interface IContributeObjectSink {
-   IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink);
  }
- public interface IContributeServerContextSink {
-   IMessageSink GetServerContextSink(IMessageSink nextSink);
  }
- public interface IDynamicMessageSink {
-   void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync);
-   void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync);
  }
- public interface IDynamicProperty {
-   string Name { get; }
  }
- public class SynchronizationAttribute : ContextAttribute, IContributeClientContextSink, IContributeServerContextSink {
-   public const int NOT_SUPPORTED = 1;
-   public const int REQUIRED = 4;
-   public const int REQUIRES_NEW = 8;
-   public const int SUPPORTED = 2;
-   public SynchronizationAttribute();
-   public SynchronizationAttribute(bool reEntrant);
-   public SynchronizationAttribute(int flag);
-   public SynchronizationAttribute(int flag, bool reEntrant);
-   public virtual bool IsReEntrant { get; }
-   public virtual bool Locked { get; set; }
-   public virtual IMessageSink GetClientContextSink(IMessageSink nextSink);
-   public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
-   public virtual IMessageSink GetServerContextSink(IMessageSink nextSink);
-   public override bool IsContextOK(Context ctx, IConstructionCallMessage msg);
  }
 }
-namespace System.Runtime.Remoting.Lifetime {
- public class ClientSponsor : MarshalByRefObject, ISponsor {
-   public ClientSponsor();
-   public ClientSponsor(TimeSpan renewalTime);
-   public TimeSpan RenewalTime { get; set; }
-   public void Close();
-   ~ClientSponsor();
-   public override object InitializeLifetimeService();
-   public bool Register(MarshalByRefObject obj);
-   public TimeSpan Renewal(ILease lease);
-   public void Unregister(MarshalByRefObject obj);
  }
- public interface ILease {
-   TimeSpan CurrentLeaseTime { get; }
-   LeaseState CurrentState { get; }
-   TimeSpan InitialLeaseTime { get; set; }
-   TimeSpan RenewOnCallTime { get; set; }
-   TimeSpan SponsorshipTimeout { get; set; }
-   void Register(ISponsor obj);
-   void Register(ISponsor obj, TimeSpan renewalTime);
-   TimeSpan Renew(TimeSpan renewalTime);
-   void Unregister(ISponsor obj);
  }
- public interface ISponsor {
-   TimeSpan Renewal(ILease lease);
  }
- public enum LeaseState {
-   Active = 2,
-   Expired = 4,
-   Initial = 1,
-   Null = 0,
-   Renewing = 3,
  }
- public sealed class LifetimeServices {
-   public LifetimeServices();
-   public static TimeSpan LeaseManagerPollTime { get; set; }
-   public static TimeSpan LeaseTime { get; set; }
-   public static TimeSpan RenewOnCallTime { get; set; }
-   public static TimeSpan SponsorshipTimeout { get; set; }
  }
 }
-namespace System.Runtime.Remoting.Messaging {
- public class AsyncResult : IAsyncResult, IMessageSink {
-   public virtual object AsyncDelegate { get; }
-   public virtual object AsyncState { get; }
-   public virtual WaitHandle AsyncWaitHandle { get; }
-   public virtual bool CompletedSynchronously { get; }
-   public bool EndInvokeCalled { get; set; }
-   public virtual bool IsCompleted { get; }
-   public IMessageSink NextSink { get; }
-   public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
-   public virtual IMessage GetReplyMessage();
-   public virtual void SetMessageCtrl(IMessageCtrl mc);
-   public virtual IMessage SyncProcessMessage(IMessage msg);
  }
- public sealed class CallContext {
-   public static object HostContext { get; set; }
-   public static void FreeNamedDataSlot(string name);
-   public static object GetData(string name);
-   public static Header[] GetHeaders();
-   public static object LogicalGetData(string name);
-   public static void LogicalSetData(string name, object data);
-   public static void SetData(string name, object data);
-   public static void SetHeaders(Header[] headers);
  }
- public class ConstructionCall : MethodCall, IConstructionCallMessage, IMessage, IMethodCallMessage, IMethodMessage {
-   public ConstructionCall(Header[] headers);
-   public ConstructionCall(IMessage m);
-   public Type ActivationType { get; }
-   public string ActivationTypeName { get; }
-   public IActivator Activator { get; set; }
-   public object[] CallSiteActivationAttributes { get; }
-   public IList ContextProperties { get; }
-   public override IDictionary Properties { get; }
  }
- public class ConstructionResponse : MethodResponse, IConstructionReturnMessage, IMessage, IMethodMessage, IMethodReturnMessage {
-   public ConstructionResponse(Header[] h, IMethodCallMessage mcm);
-   public override IDictionary Properties { get; }
  }
- public class Header {
-   public bool MustUnderstand;
-   public object Value;
-   public string HeaderNamespace;
-   public string Name;
-   public Header(string _Name, object _Value);
-   public Header(string _Name, object _Value, bool _MustUnderstand);
-   public Header(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace);
  }
- public delegate object HeaderHandler(Header[] headers);
- public interface ILogicalThreadAffinative {
  }
- public interface IMessage {
-   IDictionary Properties { get; }
  }
- public interface IMessageCtrl {
-   void Cancel(int msToCancel);
  }
- public interface IMessageSink {
-   IMessageSink NextSink { get; }
-   IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
-   IMessage SyncProcessMessage(IMessage msg);
  }
- public interface IMethodCallMessage : IMessage, IMethodMessage {
-   int InArgCount { get; }
-   object[] InArgs { get; }
-   object GetInArg(int argNum);
-   string GetInArgName(int index);
  }
- public interface IMethodMessage : IMessage {
-   int ArgCount { get; }
-   object[] Args { get; }
-   bool HasVarArgs { get; }
-   LogicalCallContext LogicalCallContext { get; }
-   MethodBase MethodBase { get; }
-   string MethodName { get; }
-   object MethodSignature { get; }
-   string TypeName { get; }
-   string Uri { get; }
-   object GetArg(int argNum);
-   string GetArgName(int index);
  }
- public interface IMethodReturnMessage : IMessage, IMethodMessage {
-   Exception Exception { get; }
-   int OutArgCount { get; }
-   object[] OutArgs { get; }
-   object ReturnValue { get; }
-   object GetOutArg(int argNum);
-   string GetOutArgName(int index);
  }
- public class InternalMessageWrapper {
-   protected IMessage WrappedMessage;
-   public InternalMessageWrapper(IMessage msg);
  }
- public interface IRemotingFormatter : IFormatter {
-   object Deserialize(Stream serializationStream, HeaderHandler handler);
-   void Serialize(Stream serializationStream, object graph, Header[] headers);
  }
- public sealed class LogicalCallContext : ICloneable, ISerializable {
-   public bool HasInfo { get; }
-   public object Clone();
-   public void FreeNamedDataSlot(string name);
-   public object GetData(string name);
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public void SetData(string name, object data);
  }
- public delegate bool MessageSurrogateFilter(string key, object value);
- public class MethodCall : IMessage, IMethodCallMessage, IMethodMessage, ISerializable {
-   protected IDictionary ExternalProperties;
-   protected IDictionary InternalProperties;
-   public MethodCall(Header[] h1);
-   public MethodCall(IMessage msg);
-   public int ArgCount { get; }
-   public object[] Args { get; }
-   public bool HasVarArgs { get; }
-   public int InArgCount { get; }
-   public object[] InArgs { get; }
-   public LogicalCallContext LogicalCallContext { get; }
-   public MethodBase MethodBase { get; }
-   public string MethodName { get; }
-   public object MethodSignature { get; }
-   public virtual IDictionary Properties { get; }
-   public string TypeName { get; }
-   public string Uri { get; set; }
-   public object GetArg(int argNum);
-   public string GetArgName(int index);
-   public object GetInArg(int argNum);
-   public string GetInArgName(int index);
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual object HeaderHandler(Header[] h);
-   public virtual void Init();
-   public void ResolveMethod();
-   public void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
  }
- public class MethodCallMessageWrapper : InternalMessageWrapper, IMessage, IMethodCallMessage, IMethodMessage {
-   public MethodCallMessageWrapper(IMethodCallMessage msg);
-   public virtual int ArgCount { get; }
-   public virtual object[] Args { get; set; }
-   public virtual bool HasVarArgs { get; }
-   public virtual int InArgCount { get; }
-   public virtual object[] InArgs { get; }
-   public virtual LogicalCallContext LogicalCallContext { get; }
-   public virtual MethodBase MethodBase { get; }
-   public virtual string MethodName { get; }
-   public virtual object MethodSignature { get; }
-   public virtual IDictionary Properties { get; }
-   public virtual string TypeName { get; }
-   public virtual string Uri { get; set; }
-   public virtual object GetArg(int argNum);
-   public virtual string GetArgName(int index);
-   public virtual object GetInArg(int argNum);
-   public virtual string GetInArgName(int index);
  }
- public class MethodResponse : IMessage, IMethodMessage, IMethodReturnMessage, ISerializable {
-   protected IDictionary ExternalProperties;
-   protected IDictionary InternalProperties;
-   public MethodResponse(Header[] h1, IMethodCallMessage mcm);
-   public int ArgCount { get; }
-   public object[] Args { get; }
-   public Exception Exception { get; }
-   public bool HasVarArgs { get; }
-   public LogicalCallContext LogicalCallContext { get; }
-   public MethodBase MethodBase { get; }
-   public string MethodName { get; }
-   public object MethodSignature { get; }
-   public int OutArgCount { get; }
-   public object[] OutArgs { get; }
-   public virtual IDictionary Properties { get; }
-   public object ReturnValue { get; }
-   public string TypeName { get; }
-   public string Uri { get; set; }
-   public object GetArg(int argNum);
-   public string GetArgName(int index);
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public object GetOutArg(int argNum);
-   public string GetOutArgName(int index);
-   public virtual object HeaderHandler(Header[] h);
-   public void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
  }
- public class MethodReturnMessageWrapper : InternalMessageWrapper, IMessage, IMethodMessage, IMethodReturnMessage {
-   public MethodReturnMessageWrapper(IMethodReturnMessage msg);
-   public virtual int ArgCount { get; }
-   public virtual object[] Args { get; set; }
-   public virtual Exception Exception { get; set; }
-   public virtual bool HasVarArgs { get; }
-   public virtual LogicalCallContext LogicalCallContext { get; }
-   public virtual MethodBase MethodBase { get; }
-   public virtual string MethodName { get; }
-   public virtual object MethodSignature { get; }
-   public virtual int OutArgCount { get; }
-   public virtual object[] OutArgs { get; }
-   public virtual IDictionary Properties { get; }
-   public virtual object ReturnValue { get; set; }
-   public virtual string TypeName { get; }
-   public string Uri { get; set; }
-   public virtual object GetArg(int argNum);
-   public virtual string GetArgName(int index);
-   public virtual object GetOutArg(int argNum);
-   public virtual string GetOutArgName(int index);
  }
- public class OneWayAttribute : Attribute {
-   public OneWayAttribute();
  }
- public class RemotingSurrogateSelector : ISurrogateSelector {
-   public RemotingSurrogateSelector();
-   public MessageSurrogateFilter Filter { get; set; }
-   public virtual void ChainSelector(ISurrogateSelector selector);
-   public virtual ISurrogateSelector GetNextSelector();
-   public object GetRootObject();
-   public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector ssout);
-   public void SetRootObject(object obj);
-   public virtual void UseSoapFormat();
  }
- public class ReturnMessage : IMessage, IMethodMessage, IMethodReturnMessage {
-   public ReturnMessage(Exception e, IMethodCallMessage mcm);
-   public ReturnMessage(object ret, object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm);
-   public int ArgCount { get; }
-   public object[] Args { get; }
-   public Exception Exception { get; }
-   public bool HasVarArgs { get; }
-   public LogicalCallContext LogicalCallContext { get; }
-   public MethodBase MethodBase { get; }
-   public string MethodName { get; }
-   public object MethodSignature { get; }
-   public int OutArgCount { get; }
-   public object[] OutArgs { get; }
-   public virtual IDictionary Properties { get; }
-   public virtual object ReturnValue { get; }
-   public string TypeName { get; }
-   public string Uri { get; set; }
-   public object GetArg(int argNum);
-   public string GetArgName(int index);
-   public object GetOutArg(int argNum);
-   public string GetOutArgName(int index);
  }
 }
-namespace System.Runtime.Remoting.Metadata {
- public class SoapAttribute : Attribute {
-   protected object ReflectInfo;
-   protected string ProtXmlNamespace;
-   public SoapAttribute();
-   public virtual bool Embedded { get; set; }
-   public virtual bool UseAttribute { get; set; }
-   public virtual string XmlNamespace { get; set; }
  }
- public sealed class SoapFieldAttribute : SoapAttribute {
-   public SoapFieldAttribute();
-   public int Order { get; set; }
-   public string XmlElementName { get; set; }
-   public bool IsInteropXmlElement();
  }
- public sealed class SoapMethodAttribute : SoapAttribute {
-   public SoapMethodAttribute();
-   public string ResponseXmlElementName { get; set; }
-   public string ResponseXmlNamespace { get; set; }
-   public string ReturnXmlElementName { get; set; }
-   public string SoapAction { get; set; }
-   public override bool UseAttribute { get; set; }
-   public override string XmlNamespace { get; set; }
  }
- public enum SoapOption {
-   AlwaysIncludeTypes = 1,
-   EmbedAll = 4,
-   None = 0,
-   Option1 = 8,
-   Option2 = 16,
-   XsdString = 2,
  }
- public sealed class SoapParameterAttribute : SoapAttribute {
-   public SoapParameterAttribute();
  }
- public sealed class SoapTypeAttribute : SoapAttribute {
-   public SoapTypeAttribute();
-   public SoapOption SoapOptions { get; set; }
-   public override bool UseAttribute { get; set; }
-   public string XmlElementName { get; set; }
-   public XmlFieldOrderOption XmlFieldOrder { get; set; }
-   public override string XmlNamespace { get; set; }
-   public string XmlTypeName { get; set; }
-   public string XmlTypeNamespace { get; set; }
  }
- public enum XmlFieldOrderOption {
-   All = 0,
-   Choice = 2,
-   Sequence = 1,
  }
 }
-namespace System.Runtime.Remoting.Metadata.W3cXsd2001 {
- public interface ISoapXsd {
-   string GetXsdType();
  }
- public sealed class SoapAnyUri : ISoapXsd {
-   public SoapAnyUri();
-   public SoapAnyUri(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapAnyUri Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapBase64Binary : ISoapXsd {
-   public SoapBase64Binary();
-   public SoapBase64Binary(byte[] value);
-   public byte[] Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapBase64Binary Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapDate : ISoapXsd {
-   public SoapDate();
-   public SoapDate(DateTime value);
-   public SoapDate(DateTime value, int sign);
-   public int Sign { get; set; }
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapDate Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapDateTime {
-   public SoapDateTime();
-   public static string XsdType { get; }
-   public static DateTime Parse(string value);
-   public static string ToString(DateTime value);
  }
- public sealed class SoapDay : ISoapXsd {
-   public SoapDay();
-   public SoapDay(DateTime value);
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapDay Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapDuration {
-   public SoapDuration();
-   public static string XsdType { get; }
-   public static TimeSpan Parse(string value);
-   public static string ToString(TimeSpan timeSpan);
  }
- public sealed class SoapEntities : ISoapXsd {
-   public SoapEntities();
-   public SoapEntities(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapEntities Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapEntity : ISoapXsd {
-   public SoapEntity();
-   public SoapEntity(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapEntity Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapHexBinary : ISoapXsd {
-   public SoapHexBinary();
-   public SoapHexBinary(byte[] value);
-   public byte[] Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapHexBinary Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapId : ISoapXsd {
-   public SoapId();
-   public SoapId(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapId Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapIdref : ISoapXsd {
-   public SoapIdref();
-   public SoapIdref(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapIdref Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapIdrefs : ISoapXsd {
-   public SoapIdrefs();
-   public SoapIdrefs(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapIdrefs Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapInteger : ISoapXsd {
-   public SoapInteger();
-   public SoapInteger(decimal value);
-   public decimal Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapInteger Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapLanguage : ISoapXsd {
-   public SoapLanguage();
-   public SoapLanguage(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapLanguage Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapMonth : ISoapXsd {
-   public SoapMonth();
-   public SoapMonth(DateTime value);
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapMonth Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapMonthDay : ISoapXsd {
-   public SoapMonthDay();
-   public SoapMonthDay(DateTime value);
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapMonthDay Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapName : ISoapXsd {
-   public SoapName();
-   public SoapName(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapName Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNcName : ISoapXsd {
-   public SoapNcName();
-   public SoapNcName(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNcName Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNegativeInteger : ISoapXsd {
-   public SoapNegativeInteger();
-   public SoapNegativeInteger(decimal value);
-   public decimal Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNegativeInteger Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNmtoken : ISoapXsd {
-   public SoapNmtoken();
-   public SoapNmtoken(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNmtoken Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNmtokens : ISoapXsd {
-   public SoapNmtokens();
-   public SoapNmtokens(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNmtokens Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNonNegativeInteger : ISoapXsd {
-   public SoapNonNegativeInteger();
-   public SoapNonNegativeInteger(decimal value);
-   public decimal Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNonNegativeInteger Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNonPositiveInteger : ISoapXsd {
-   public SoapNonPositiveInteger();
-   public SoapNonPositiveInteger(decimal value);
-   public decimal Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNonPositiveInteger Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNormalizedString : ISoapXsd {
-   public SoapNormalizedString();
-   public SoapNormalizedString(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNormalizedString Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapNotation : ISoapXsd {
-   public SoapNotation();
-   public SoapNotation(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapNotation Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapPositiveInteger : ISoapXsd {
-   public SoapPositiveInteger();
-   public SoapPositiveInteger(decimal value);
-   public decimal Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapPositiveInteger Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapQName : ISoapXsd {
-   public SoapQName();
-   public SoapQName(string value);
-   public SoapQName(string key, string name);
-   public SoapQName(string key, string name, string namespaceValue);
-   public string Key { get; set; }
-   public string Name { get; set; }
-   public string Namespace { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapQName Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapTime : ISoapXsd {
-   public SoapTime();
-   public SoapTime(DateTime value);
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapTime Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapToken : ISoapXsd {
-   public SoapToken();
-   public SoapToken(string value);
-   public string Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapToken Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapYear : ISoapXsd {
-   public SoapYear();
-   public SoapYear(DateTime value);
-   public SoapYear(DateTime value, int sign);
-   public int Sign { get; set; }
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapYear Parse(string value);
-   public override string ToString();
  }
- public sealed class SoapYearMonth : ISoapXsd {
-   public SoapYearMonth();
-   public SoapYearMonth(DateTime value);
-   public SoapYearMonth(DateTime value, int sign);
-   public int Sign { get; set; }
-   public DateTime Value { get; set; }
-   public static string XsdType { get; }
-   public string GetXsdType();
-   public static SoapYearMonth Parse(string value);
-   public override string ToString();
  }
 }
-namespace System.Runtime.Remoting.Proxies {
- public class ProxyAttribute : Attribute, IContextAttribute {
-   public ProxyAttribute();
-   public virtual MarshalByRefObject CreateInstance(Type serverType);
-   public virtual RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext);
-   public void GetPropertiesForNewContext(IConstructionCallMessage msg);
-   public bool IsContextOK(Context ctx, IConstructionCallMessage msg);
  }
- public abstract class RealProxy {
-   protected RealProxy();
-   protected RealProxy(Type classToProxy);
-   protected RealProxy(Type classToProxy, IntPtr stub, object stubData);
-   protected void AttachServer(MarshalByRefObject s);
-   public virtual ObjRef CreateObjRef(Type requestedType);
-   protected MarshalByRefObject DetachServer();
-   public virtual IntPtr GetCOMIUnknown(bool fIsMarshalled);
-   public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   [MethodImpl(InternalCall)]public Type GetProxiedType();
-   [MethodImpl(InternalCall)]public static object GetStubData(RealProxy rp);
-   public virtual object GetTransparentProxy();
-   protected MarshalByRefObject GetUnwrappedServer();
-   public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg);
-   public abstract IMessage Invoke(IMessage msg);
-   public virtual void SetCOMIUnknown(IntPtr i);
-   [MethodImpl(InternalCall)]public static void SetStubData(RealProxy rp, object stubData);
-   public virtual IntPtr SupportsInterface(ref Guid iid);
  }
 }
-namespace System.Runtime.Remoting.Services {
- public sealed class EnterpriseServicesHelper {
-   public EnterpriseServicesHelper();
-   public static IConstructionReturnMessage CreateConstructionReturnMessage(IConstructionCallMessage ctorMsg, MarshalByRefObject retObj);
-   public static void SwitchWrappers(RealProxy oldcp, RealProxy newcp);
-   public static object WrapIUnknownWithComObject(IntPtr punk);
  }
- public interface ITrackingHandler {
-   void DisconnectedObject(object obj);
-   void MarshaledObject(object obj, ObjRef or);
-   void UnmarshaledObject(object obj, ObjRef or);
  }
- public class TrackingServices {
-   public TrackingServices();
-   public static ITrackingHandler[] RegisteredHandlers { get; }
-   public static void RegisterTrackingHandler(ITrackingHandler handler);
-   public static void UnregisterTrackingHandler(ITrackingHandler handler);
  }
 }
-namespace System.Runtime.Serialization {
- public abstract class Formatter : IFormatter {
-   protected Queue m_objectQueue;
-   protected ObjectIDGenerator m_idGenerator;
-   protected Formatter();
-   public abstract SerializationBinder Binder { get; set; }
-   public abstract StreamingContext Context { get; set; }
-   public abstract ISurrogateSelector SurrogateSelector { get; set; }
-   public abstract object Deserialize(Stream serializationStream);
-   protected virtual object GetNext(out long objID);
-   protected virtual long Schedule(object obj);
-   public abstract void Serialize(Stream serializationStream, object graph);
-   protected abstract void WriteArray(object obj, string name, Type memberType);
-   protected abstract void WriteBoolean(bool val, string name);
-   protected abstract void WriteByte(byte val, string name);
-   protected abstract void WriteChar(char val, string name);
-   protected abstract void WriteDateTime(DateTime val, string name);
-   protected abstract void WriteDecimal(decimal val, string name);
-   protected abstract void WriteDouble(double val, string name);
-   protected abstract void WriteInt16(short val, string name);
-   protected abstract void WriteInt32(int val, string name);
-   protected abstract void WriteInt64(long val, string name);
-   protected virtual void WriteMember(string memberName, object data);
-   protected abstract void WriteObjectRef(object obj, string name, Type memberType);
-   protected abstract void WriteSByte(sbyte val, string name);
-   protected abstract void WriteSingle(float val, string name);
-   protected abstract void WriteTimeSpan(TimeSpan val, string name);
-   protected abstract void WriteUInt16(ushort val, string name);
-   protected abstract void WriteUInt32(uint val, string name);
-   protected abstract void WriteUInt64(ulong val, string name);
-   protected abstract void WriteValueType(object obj, string name, Type memberType);
  }
- public class FormatterConverter : IFormatterConverter {
-   public FormatterConverter();
-   public object Convert(object value, Type type);
-   public object Convert(object value, TypeCode typeCode);
-   public bool ToBoolean(object value);
-   public byte ToByte(object value);
-   public char ToChar(object value);
-   public DateTime ToDateTime(object value);
-   public decimal ToDecimal(object value);
-   public double ToDouble(object value);
-   public short ToInt16(object value);
-   public int ToInt32(object value);
-   public long ToInt64(object value);
-   public sbyte ToSByte(object value);
-   public float ToSingle(object value);
-   public string ToString(object value);
-   public ushort ToUInt16(object value);
-   public uint ToUInt32(object value);
-   public ulong ToUInt64(object value);
  }
- public static class FormatterServices {
-   public static void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel);
-   public static object[] GetObjectData(object obj, MemberInfo[] members);
-   public static object GetSafeUninitializedObject(Type type);
-   public static MemberInfo[] GetSerializableMembers(Type type);
-   public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);
-   public static ISerializationSurrogate GetSurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
-   public static Type GetTypeFromAssembly(Assembly assem, string name);
-   public static object GetUninitializedObject(Type type);
-   public static object PopulateObjectMembers(object obj, MemberInfo[] members, object[] data);
  }
- public interface IDeserializationCallback {
-   void OnDeserialization(object sender);
  }
- public interface IFormatter {
-   SerializationBinder Binder { get; set; }
-   StreamingContext Context { get; set; }
-   ISurrogateSelector SurrogateSelector { get; set; }
-   object Deserialize(Stream serializationStream);
-   void Serialize(Stream serializationStream, object graph);
  }
- public interface IFormatterConverter {
-   object Convert(object value, Type type);
-   object Convert(object value, TypeCode typeCode);
-   bool ToBoolean(object value);
-   byte ToByte(object value);
-   char ToChar(object value);
-   DateTime ToDateTime(object value);
-   decimal ToDecimal(object value);
-   double ToDouble(object value);
-   short ToInt16(object value);
-   int ToInt32(object value);
-   long ToInt64(object value);
-   sbyte ToSByte(object value);
-   float ToSingle(object value);
-   string ToString(object value);
-   ushort ToUInt16(object value);
-   uint ToUInt32(object value);
-   ulong ToUInt64(object value);
  }
- public interface IObjectReference {
-   object GetRealObject(StreamingContext context);
  }
- public interface ISafeSerializationData {
-   void CompleteDeserialization(object deserialized);
  }
- public interface ISerializable {
-   void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public interface ISerializationSurrogate {
-   void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
-   object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
  }
- public interface ISurrogateSelector {
-   void ChainSelector(ISurrogateSelector selector);
-   ISurrogateSelector GetNextSelector();
-   ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);
  }
- public class ObjectIDGenerator {
-   public ObjectIDGenerator();
-   public virtual long GetId(object obj, out bool firstTime);
-   public virtual long HasId(object obj, out bool firstTime);
  }
- public class ObjectManager {
-   public ObjectManager(ISurrogateSelector selector, StreamingContext context);
-   public virtual void DoFixups();
-   public virtual object GetObject(long objectID);
-   public virtual void RaiseDeserializationEvent();
-   public void RaiseOnDeserializingEvent(object obj);
-   public virtual void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired);
-   public virtual void RecordArrayElementFixup(long arrayToBeFixed, int[] indices, long objectRequired);
-   public virtual void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
-   public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired);
-   public virtual void RegisterObject(object obj, long objectID);
-   public void RegisterObject(object obj, long objectID, SerializationInfo info);
-   public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
-   public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, int[] arrayIndex);
  }
- public sealed class OnDeserializedAttribute : Attribute {
-   public OnDeserializedAttribute();
  }
- public sealed class OnDeserializingAttribute : Attribute {
-   public OnDeserializingAttribute();
  }
- public sealed class OnSerializedAttribute : Attribute {
-   public OnSerializedAttribute();
  }
- public sealed class OnSerializingAttribute : Attribute {
-   public OnSerializingAttribute();
  }
- public sealed class OptionalFieldAttribute : Attribute {
-   public OptionalFieldAttribute();
-   public int VersionAdded { get; set; }
  }
- public sealed class SafeSerializationEventArgs : EventArgs {
-   public StreamingContext StreamingContext { get; }
-   public void AddSerializedState(ISafeSerializationData serializedState);
  }
- public abstract class SerializationBinder {
-   protected SerializationBinder();
-   public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName);
-   public abstract Type BindToType(string assemblyName, string typeName);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SerializationEntry {
-   public string Name { get; }
-   public Type ObjectType { get; }
-   public object Value { get; }
  }
- public class SerializationException : SystemException {
-   public SerializationException();
-   protected SerializationException(SerializationInfo info, StreamingContext context);
-   public SerializationException(string message);
-   public SerializationException(string message, Exception innerException);
  }
- public sealed class SerializationInfo {
-   public SerializationInfo(Type type, IFormatterConverter converter);
-   public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
-   public string AssemblyName { get; set; }
-   public string FullTypeName { get; set; }
-   public bool IsAssemblyNameSetExplicit { get; }
-   public bool IsFullTypeNameSetExplicit { get; }
-   public int MemberCount { get; }
-   public Type ObjectType { get; }
-   public void AddValue(string name, bool value);
-   public void AddValue(string name, byte value);
-   public void AddValue(string name, char value);
-   public void AddValue(string name, DateTime value);
-   public void AddValue(string name, decimal value);
-   public void AddValue(string name, double value);
-   public void AddValue(string name, short value);
-   public void AddValue(string name, int value);
-   public void AddValue(string name, long value);
-   public void AddValue(string name, object value);
-   public void AddValue(string name, object value, Type type);
-   public void AddValue(string name, sbyte value);
-   public void AddValue(string name, float value);
-   public void AddValue(string name, ushort value);
-   public void AddValue(string name, uint value);
-   public void AddValue(string name, ulong value);
-   public bool GetBoolean(string name);
-   public byte GetByte(string name);
-   public char GetChar(string name);
-   public DateTime GetDateTime(string name);
-   public decimal GetDecimal(string name);
-   public double GetDouble(string name);
-   public SerializationInfoEnumerator GetEnumerator();
-   public short GetInt16(string name);
-   public int GetInt32(string name);
-   public long GetInt64(string name);
-   public sbyte GetSByte(string name);
-   public float GetSingle(string name);
-   public string GetString(string name);
-   public ushort GetUInt16(string name);
-   public uint GetUInt32(string name);
-   public ulong GetUInt64(string name);
-   public object GetValue(string name, Type type);
-   public void SetType(Type type);
  }
- public sealed class SerializationInfoEnumerator : IEnumerator {
-   public SerializationEntry Current { get; }
-   public string Name { get; }
-   public Type ObjectType { get; }
-   object System.Collections.IEnumerator.Current { get; }
-   public object Value { get; }
-   public bool MoveNext();
-   public void Reset();
  }
- public sealed class SerializationObjectManager {
-   public SerializationObjectManager(StreamingContext context);
-   public void RaiseOnSerializedEvent();
-   public void RegisterObject(object obj);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct StreamingContext {
-   public StreamingContext(StreamingContextStates state);
-   public StreamingContext(StreamingContextStates state, object additional);
-   public object Context { get; }
-   public StreamingContextStates State { get; }
-   public override bool Equals(object obj);
-   public override int GetHashCode();
  }
- public enum StreamingContextStates {
-   All = 255,
-   Clone = 64,
-   CrossAppDomain = 128,
-   CrossMachine = 2,
-   CrossProcess = 1,
-   File = 4,
-   Other = 32,
-   Persistence = 8,
-   Remoting = 16,
  }
- public class SurrogateSelector : ISurrogateSelector {
-   public SurrogateSelector();
-   public virtual void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate);
-   public virtual void ChainSelector(ISurrogateSelector selector);
-   public virtual ISurrogateSelector GetNextSelector();
-   public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);
-   public virtual void RemoveSurrogate(Type type, StreamingContext context);
  }
 }
-namespace System.Runtime.Serialization.Formatters {
- public enum FormatterAssemblyStyle {
-   Full = 1,
-   Simple = 0,
  }
- public enum FormatterTypeStyle {
-   TypesAlways = 1,
-   TypesWhenNeeded = 0,
-   XsdString = 2,
  }
- public interface IFieldInfo {
-   string[] FieldNames { get; set; }
-   Type[] FieldTypes { get; set; }
  }
- public sealed class InternalRM {
-   public InternalRM();
-   public static void InfoSoap(params object[] messages);
-   public static bool SoapCheckEnabled();
  }
- public sealed class InternalST {
-   public static void InfoSoap(params object[] messages);
-   public static Assembly LoadAssemblyFromString(string assemblyString);
-   public static void SerializationSetValue(FieldInfo fi, object target, object value);
-   public static void Soap(params object[] messages);
-   public static void SoapAssert(bool condition, string message);
-   public static bool SoapCheckEnabled();
  }
- public interface ISoapMessage {
-   Header[] Headers { get; set; }
-   string MethodName { get; set; }
-   string[] ParamNames { get; set; }
-   Type[] ParamTypes { get; set; }
-   object[] ParamValues { get; set; }
-   string XmlNameSpace { get; set; }
  }
- public sealed class ServerFault {
-   public ServerFault(string exceptionType, string message, string stackTrace);
-   public string ExceptionMessage { get; set; }
-   public string ExceptionType { get; set; }
-   public string StackTrace { get; set; }
  }
- public sealed class SoapFault : ISerializable {
-   public SoapFault();
-   public SoapFault(string faultCode, string faultString, string faultActor, ServerFault serverFault);
-   public object Detail { get; set; }
-   public string FaultActor { get; set; }
-   public string FaultCode { get; set; }
-   public string FaultString { get; set; }
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public class SoapMessage : ISoapMessage {
-   public SoapMessage();
-   public Header[] Headers { get; set; }
-   public string MethodName { get; set; }
-   public string[] ParamNames { get; set; }
-   public Type[] ParamTypes { get; set; }
-   public object[] ParamValues { get; set; }
-   public string XmlNameSpace { get; set; }
  }
- public enum TypeFilterLevel {
-   Full = 3,
-   Low = 2,
  }
 }
-namespace System.Runtime.Serialization.Formatters.Binary {
- public sealed class BinaryFormatter : IFormatter, IRemotingFormatter {
-   public BinaryFormatter();
-   public BinaryFormatter(ISurrogateSelector selector, StreamingContext context);
-   public FormatterAssemblyStyle AssemblyFormat { get; set; }
-   public SerializationBinder Binder { get; set; }
-   public StreamingContext Context { get; set; }
-   public TypeFilterLevel FilterLevel { get; set; }
-   public ISurrogateSelector SurrogateSelector { get; set; }
-   public FormatterTypeStyle TypeFormat { get; set; }
-   public object Deserialize(Stream serializationStream);
-   public object Deserialize(Stream serializationStream, HeaderHandler handler);
-   public object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
-   public void Serialize(Stream serializationStream, object graph);
-   public void Serialize(Stream serializationStream, object graph, Header[] headers);
-   public object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler);
-   public object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
  }
 }
 namespace System.Runtime.Versioning {
- public sealed class ComponentGuaranteesAttribute : Attribute {
-   public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
-   public ComponentGuaranteesOptions Guarantees { get; }
  }
- public enum ComponentGuaranteesOptions {
-   Exchange = 1,
-   None = 0,
-   SideBySide = 4,
-   Stable = 2,
  }
- public sealed class ResourceConsumptionAttribute : Attribute {
-   public ResourceConsumptionAttribute(ResourceScope resourceScope);
-   public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
-   public ResourceScope ConsumptionScope { get; }
-   public ResourceScope ResourceScope { get; }
  }
- public sealed class ResourceExposureAttribute : Attribute {
-   public ResourceExposureAttribute(ResourceScope exposureLevel);
-   public ResourceScope ResourceExposureLevel { get; }
  }
- public enum ResourceScope {
-   AppDomain = 4,
-   Assembly = 32,
-   Library = 8,
-   Machine = 1,
-   None = 0,
-   Private = 16,
-   Process = 2,
  }
  public sealed class TargetFrameworkAttribute : Attribute {
    public TargetFrameworkAttribute(string frameworkName);
    public string FrameworkDisplayName { get; set; }
    public string FrameworkName { get; }
  }
- public static class VersioningHelper {
-   public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
-   public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
  }
 }
 namespace System.Security {
  public sealed class AllowPartiallyTrustedCallersAttribute : Attribute {
    public AllowPartiallyTrustedCallersAttribute();
-   public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; set; }
  }
- public abstract class CodeAccessPermission : IPermission, ISecurityEncodable, IStackWalk {
-   protected CodeAccessPermission();
-   [MethodImpl(NoInlining)]public void Assert();
-   public abstract IPermission Copy();
-   [MethodImpl(NoInlining)]public void Demand();
-   [MethodImpl(NoInlining)]public void Deny();
-   public override bool Equals(object obj);
-   public abstract void FromXml(SecurityElement elem);
-   public override int GetHashCode();
-   public abstract IPermission Intersect(IPermission target);
-   public abstract bool IsSubsetOf(IPermission target);
-   [MethodImpl(NoInlining)]public void PermitOnly();
-   [MethodImpl(NoInlining)]public static void RevertAll();
-   [MethodImpl(NoInlining)]public static void RevertAssert();
-   [MethodImpl(NoInlining)]public static void RevertDeny();
-   [MethodImpl(NoInlining)]public static void RevertPermitOnly();
-   public override string ToString();
-   public abstract SecurityElement ToXml();
-   public virtual IPermission Union(IPermission other);
  }
- public class HostProtectionException : SystemException {
-   public HostProtectionException();
-   protected HostProtectionException(SerializationInfo info, StreamingContext context);
-   public HostProtectionException(string message);
-   public HostProtectionException(string message, Exception e);
-   public HostProtectionException(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources);
-   public HostProtectionResource DemandedResources { get; }
-   public HostProtectionResource ProtectedResources { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
  }
- public class HostSecurityManager {
-   public HostSecurityManager();
-   public virtual PolicyLevel DomainPolicy { get; }
-   public virtual HostSecurityManagerOptions Flags { get; }
-   public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
-   public virtual EvidenceBase GenerateAppDomainEvidence(Type evidenceType);
-   public virtual EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly);
-   public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes();
-   public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly);
-   public virtual Evidence ProvideAppDomainEvidence(Evidence inputEvidence);
-   public virtual Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence);
-   public virtual PermissionSet ResolvePolicy(Evidence evidence);
  }
- public enum HostSecurityManagerOptions {
-   AllFlags = 31,
-   HostAppDomainEvidence = 1,
-   HostAssemblyEvidence = 4,
-   HostDetermineApplicationTrust = 8,
-   HostPolicyLevel = 2,
-   HostResolvePolicy = 16,
-   None = 0,
  }
- public interface IEvidenceFactory {
-   Evidence Evidence { get; }
  }
- public interface IPermission : ISecurityEncodable {
-   IPermission Copy();
-   void Demand();
-   IPermission Intersect(IPermission target);
-   bool IsSubsetOf(IPermission target);
-   IPermission Union(IPermission target);
  }
- public interface ISecurityEncodable {
-   void FromXml(SecurityElement e);
-   SecurityElement ToXml();
  }
- public interface ISecurityPolicyEncodable {
-   void FromXml(SecurityElement e, PolicyLevel level);
-   SecurityElement ToXml(PolicyLevel level);
  }
- public interface IStackWalk {
-   void Assert();
-   void Demand();
-   void Deny();
-   void PermitOnly();
  }
- public sealed class NamedPermissionSet : PermissionSet {
-   public NamedPermissionSet(NamedPermissionSet permSet);
-   public NamedPermissionSet(string name);
-   public NamedPermissionSet(string name, PermissionState state);
-   public NamedPermissionSet(string name, PermissionSet permSet);
-   public string Description { get; set; }
-   public string Name { get; set; }
-   public override PermissionSet Copy();
-   public NamedPermissionSet Copy(string name);
-   public override bool Equals(object obj);
-   public override void FromXml(SecurityElement et);
-   public override int GetHashCode();
-   public override SecurityElement ToXml();
  }
- public enum PartialTrustVisibilityLevel {
-   NotVisibleByDefault = 1,
-   VisibleToAllHosts = 0,
  }
- public class PermissionSet : ICollection, IDeserializationCallback, IEnumerable, ISecurityEncodable, IStackWalk {
-   public PermissionSet(PermissionState state);
-   public PermissionSet(PermissionSet permSet);
-   public virtual int Count { get; }
-   public virtual bool IsReadOnly { get; }
-   public virtual bool IsSynchronized { get; }
-   public virtual object SyncRoot { get; }
-   public IPermission AddPermission(IPermission perm);
-   protected virtual IPermission AddPermissionImpl(IPermission perm);
-   [MethodImpl(NoInlining)]public void Assert();
-   public bool ContainsNonCodeAccessPermissions();
-   public static byte[] ConvertPermissionSet(string inFormat, byte[] inData, string outFormat);
-   public virtual PermissionSet Copy();
-   public virtual void CopyTo(Array array, int index);
-   [MethodImpl(NoInlining)]public void Demand();
-   [MethodImpl(NoInlining)]public void Deny();
-   public override bool Equals(object obj);
-   public virtual void FromXml(SecurityElement et);
-   public IEnumerator GetEnumerator();
-   protected virtual IEnumerator GetEnumeratorImpl();
-   public override int GetHashCode();
-   public IPermission GetPermission(Type permClass);
-   protected virtual IPermission GetPermissionImpl(Type permClass);
-   public PermissionSet Intersect(PermissionSet other);
-   public bool IsEmpty();
-   public bool IsSubsetOf(PermissionSet target);
-   public bool IsUnrestricted();
-   [MethodImpl(NoInlining)]public void PermitOnly();
-   public IPermission RemovePermission(Type permClass);
-   protected virtual IPermission RemovePermissionImpl(Type permClass);
-   [MethodImpl(NoInlining)]public static void RevertAssert();
-   public IPermission SetPermission(IPermission perm);
-   protected virtual IPermission SetPermissionImpl(IPermission perm);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   public override string ToString();
-   public virtual SecurityElement ToXml();
-   public PermissionSet Union(PermissionSet other);
  }
- public enum PolicyLevelType {
-   AppDomain = 3,
-   Enterprise = 2,
-   Machine = 1,
-   User = 0,
  }
- public sealed class ReadOnlyPermissionSet : PermissionSet {
-   public ReadOnlyPermissionSet(SecurityElement permissionSetXml);
-   public override bool IsReadOnly { get; }
-   protected override IPermission AddPermissionImpl(IPermission perm);
-   public override PermissionSet Copy();
-   public override void FromXml(SecurityElement et);
-   protected override IEnumerator GetEnumeratorImpl();
-   protected override IPermission GetPermissionImpl(Type permClass);
-   protected override IPermission RemovePermissionImpl(Type permClass);
-   protected override IPermission SetPermissionImpl(IPermission perm);
-   public override SecurityElement ToXml();
  }
- public sealed class SecureString : IDisposable {
-   public SecureString();
-   public unsafe SecureString(char* value, int length);
-   public int Length { [MethodImpl(Synchronized)]get; }
-   [MethodImpl(Synchronized)]public void AppendChar(char c);
-   [MethodImpl(Synchronized)]public void Clear();
-   [MethodImpl(Synchronized)]public SecureString Copy();
-   [MethodImpl(Synchronized)]public void Dispose();
-   [MethodImpl(Synchronized)]public void InsertAt(int index, char c);
-   [MethodImpl(Synchronized)]public bool IsReadOnly();
-   [MethodImpl(Synchronized)]public void MakeReadOnly();
-   [MethodImpl(Synchronized)]public void RemoveAt(int index);
-   [MethodImpl(Synchronized)]public void SetAt(int index, char c);
  }
- public sealed class SecurityContext : IDisposable {
-   [MethodImpl(NoInlining)]public static SecurityContext Capture();
-   public SecurityContext CreateCopy();
-   public void Dispose();
-   public static bool IsFlowSuppressed();
-   public static bool IsWindowsIdentityFlowSuppressed();
-   public static void RestoreFlow();
-   [MethodImpl(NoInlining)]public static void Run(SecurityContext securityContext, ContextCallback callback, object state);
-   public static AsyncFlowControl SuppressFlow();
-   public static AsyncFlowControl SuppressFlowWindowsIdentity();
  }
- public enum SecurityContextSource {
-   CurrentAppDomain = 0,
-   CurrentAssembly = 1,
  }
  public sealed class SecurityCriticalAttribute : Attribute {
    public SecurityCriticalAttribute();
-   public SecurityCriticalAttribute(SecurityCriticalScope scope);
-   public SecurityCriticalScope Scope { get; }
  }
- public enum SecurityCriticalScope {
-   Everything = 1,
-   Explicit = 0,
  }
- public sealed class SecurityElement {
-   public SecurityElement(string tag);
-   public SecurityElement(string tag, string text);
-   public Hashtable Attributes { get; set; }
-   public ArrayList Children { get; set; }
-   public string Tag { get; set; }
-   public string Text { get; set; }
-   public void AddAttribute(string name, string value);
-   public void AddChild(SecurityElement child);
-   public string Attribute(string name);
-   public SecurityElement Copy();
-   public bool Equal(SecurityElement other);
-   public static string Escape(string str);
-   public static SecurityElement FromString(string xml);
-   public static bool IsValidAttributeName(string name);
-   public static bool IsValidAttributeValue(string value);
-   public static bool IsValidTag(string tag);
-   public static bool IsValidText(string text);
-   public SecurityElement SearchForChildByTag(string tag);
-   public string SearchForTextOfTag(string tag);
-   public override string ToString();
  }
  public class SecurityException : SystemExceptionException {
    public SecurityException();
-   protected SecurityException(SerializationInfo info, StreamingContext context);
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
-   public SecurityException(string message, object deny, object permitOnly, MethodInfo method, object demanded, IPermission permThatFailed);
-   public SecurityException(string message, AssemblyName assemblyName, PermissionSet grant, PermissionSet refused, MethodInfo method, SecurityAction action, object demanded, IPermission permThatFailed, Evidence evidence);
-   public SecurityException(string message, Type type);
-   public SecurityException(string message, Type type, string state);
-   public SecurityAction Action { get; set; }
-   public object Demanded { get; set; }
-   public object DenySetInstance { get; set; }
-   public AssemblyName FailedAssemblyInfo { get; set; }
-   public IPermission FirstPermissionThatFailed { get; set; }
-   public string GrantedSet { get; set; }
-   public MethodInfo Method { get; set; }
-   public string PermissionState { get; set; }
-   public Type PermissionType { get; set; }
-   public object PermitOnlySetInstance { get; set; }
-   public string RefusedSet { get; set; }
-   public string Url { get; set; }
-   public SecurityZone Zone { get; set; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
    public override string ToString();
  }
- public static class SecurityManager {
-   public static bool CheckExecutionRights { get; set; }
-   public static bool SecurityEnabled { get; set; }
-   public static bool CurrentThreadRequiresSecurityContextCapture();
-   public static PermissionSet GetStandardSandbox(Evidence evidence);
-   [MethodImpl(NoInlining)]public static void GetZoneAndOrigin(out ArrayList zone, out ArrayList origin);
-   [MethodImpl(NoInlining)]public static bool IsGranted(IPermission perm);
-   public static PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type);
-   public static PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type);
-   public static IEnumerator PolicyHierarchy();
-   public static PermissionSet ResolvePolicy(Evidence evidence);
-   public static PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, out PermissionSet denied);
-   public static PermissionSet ResolvePolicy(Evidence[] evidences);
-   public static IEnumerator ResolvePolicyGroups(Evidence evidence);
-   public static PermissionSet ResolveSystemPolicy(Evidence evidence);
-   public static void SavePolicy();
-   public static void SavePolicyLevel(PolicyLevel level);
  }
- public sealed class SecurityRulesAttribute : Attribute {
-   public SecurityRulesAttribute(SecurityRuleSet ruleSet);
-   public SecurityRuleSet RuleSet { get; }
-   public bool SkipVerificationInFullTrust { get; set; }
  }
- public enum SecurityRuleSet : byte {
-   Level1 = (byte)1,
-   Level2 = (byte)2,
-   None = (byte)0,
  }
  public sealed class SecuritySafeCriticalAttribute : Attribute {
    public SecuritySafeCriticalAttribute();
  }
- public abstract class SecurityState {
-   protected SecurityState();
-   public abstract void EnsureState();
-   public bool IsStateAvailable();
  }
  public sealed class SecurityTransparentAttribute : Attribute {
    public SecurityTransparentAttribute();
  }
- public sealed class SecurityTreatAsSafeAttribute : Attribute {
-   public SecurityTreatAsSafeAttribute();
  }
- public enum SecurityZone {
-   Internet = 3,
-   Intranet = 1,
-   MyComputer = 0,
-   NoZone = -1,
-   Trusted = 2,
-   Untrusted = 4,
  }
- public sealed class SuppressUnmanagedCodeSecurityAttribute : Attribute {
-   public SuppressUnmanagedCodeSecurityAttribute();
  }
- public sealed class UnverifiableCodeAttribute : Attribute {
-   public UnverifiableCodeAttribute();
  }
  public class VerificationException : SystemExceptionException {
    public VerificationException();
-   protected VerificationException(SerializationInfo info, StreamingContext context);
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
  }
- public sealed class XmlSyntaxException : SystemException {
-   public XmlSyntaxException();
-   public XmlSyntaxException(int lineNumber);
-   public XmlSyntaxException(int lineNumber, string message);
-   public XmlSyntaxException(string message);
-   public XmlSyntaxException(string message, Exception inner);
  }
 }
-namespace System.Security.AccessControl {
- public enum AccessControlActions {
-   Change = 2,
-   None = 0,
-   View = 1,
  }
- public enum AccessControlModification {
-   Add = 0,
-   Remove = 3,
-   RemoveAll = 4,
-   RemoveSpecific = 5,
-   Reset = 2,
-   Set = 1,
  }
- public enum AccessControlSections {
-   Access = 2,
-   All = 15,
-   Audit = 1,
-   Group = 8,
-   None = 0,
-   Owner = 4,
  }
- public enum AccessControlType {
-   Allow = 0,
-   Deny = 1,
  }
- public abstract class AccessRule : AuthorizationRule {
-   protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public AccessControlType AccessControlType { get; }
  }
- public class AccessRule<T> : AccessRule where T : struct {
-   public AccessRule(IdentityReference identity, T rights, AccessControlType type);
-   public AccessRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public AccessRule(string identity, T rights, AccessControlType type);
-   public AccessRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public T Rights { get; }
  }
- public sealed class AceEnumerator : IEnumerator {
-   public GenericAce Current { get; }
-   object System.Collections.IEnumerator.Current { get; }
-   public bool MoveNext();
-   public void Reset();
  }
- public enum AceFlags : byte {
-   AuditFlags = (byte)192,
-   ContainerInherit = (byte)2,
-   FailedAccess = (byte)128,
-   InheritanceFlags = (byte)15,
-   Inherited = (byte)16,
-   InheritOnly = (byte)8,
-   None = (byte)0,
-   NoPropagateInherit = (byte)4,
-   ObjectInherit = (byte)1,
-   SuccessfulAccess = (byte)64,
  }
- public enum AceQualifier {
-   AccessAllowed = 0,
-   AccessDenied = 1,
-   SystemAlarm = 3,
-   SystemAudit = 2,
  }
- public enum AceType : byte {
-   AccessAllowed = (byte)0,
-   AccessAllowedCallback = (byte)9,
-   AccessAllowedCallbackObject = (byte)11,
-   AccessAllowedCompound = (byte)4,
-   AccessAllowedObject = (byte)5,
-   AccessDenied = (byte)1,
-   AccessDeniedCallback = (byte)10,
-   AccessDeniedCallbackObject = (byte)12,
-   AccessDeniedObject = (byte)6,
-   MaxDefinedAceType = (byte)16,
-   SystemAlarm = (byte)3,
-   SystemAlarmCallback = (byte)14,
-   SystemAlarmCallbackObject = (byte)16,
-   SystemAlarmObject = (byte)8,
-   SystemAudit = (byte)2,
-   SystemAuditCallback = (byte)13,
-   SystemAuditCallbackObject = (byte)15,
-   SystemAuditObject = (byte)7,
  }
- public enum AuditFlags {
-   Failure = 2,
-   None = 0,
-   Success = 1,
  }
- public abstract class AuditRule : AuthorizationRule {
-   protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
-   public AuditFlags AuditFlags { get; }
  }
- public class AuditRule<T> : AuditRule where T : struct {
-   public AuditRule(IdentityReference identity, T rights, AuditFlags flags);
-   public AuditRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public AuditRule(string identity, T rights, AuditFlags flags);
-   public AuditRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public T Rights { get; }
  }
- public abstract class AuthorizationRule {
-   protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   protected internal int AccessMask { get; }
-   public IdentityReference IdentityReference { get; }
-   public InheritanceFlags InheritanceFlags { get; }
-   public bool IsInherited { get; }
-   public PropagationFlags PropagationFlags { get; }
  }
- public sealed class AuthorizationRuleCollection : ReadOnlyCollectionBase {
-   public AuthorizationRuleCollection();
-   public AuthorizationRule this[int index] { get; }
-   public void AddRule(AuthorizationRule rule);
-   public void CopyTo(AuthorizationRule[] rules, int index);
  }
- public sealed class CommonAce : QualifiedAce {
-   public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, byte[] opaque);
-   public override int BinaryLength { get; }
-   public override void GetBinaryForm(byte[] binaryForm, int offset);
-   public static int MaxOpaqueLength(bool isCallback);
  }
- public abstract class CommonAcl : GenericAcl {
-   public sealed override int BinaryLength { get; }
-   public sealed override int Count { get; }
-   public bool IsCanonical { get; }
-   public bool IsContainer { get; }
-   public bool IsDS { get; }
-   public sealed override byte Revision { get; }
-   public sealed override GenericAce this[int index] { get; set; }
-   public sealed override void GetBinaryForm(byte[] binaryForm, int offset);
-   public void Purge(SecurityIdentifier sid);
-   public void RemoveInheritedAces();
  }
- public abstract class CommonObjectSecurity : ObjectSecurity {
-   protected CommonObjectSecurity(bool isContainer);
-   protected void AddAccessRule(AccessRule rule);
-   protected void AddAuditRule(AuditRule rule);
-   public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
-   public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
-   protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
-   protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
-   protected bool RemoveAccessRule(AccessRule rule);
-   protected void RemoveAccessRuleAll(AccessRule rule);
-   protected void RemoveAccessRuleSpecific(AccessRule rule);
-   protected bool RemoveAuditRule(AuditRule rule);
-   protected void RemoveAuditRuleAll(AuditRule rule);
-   protected void RemoveAuditRuleSpecific(AuditRule rule);
-   protected void ResetAccessRule(AccessRule rule);
-   protected void SetAccessRule(AccessRule rule);
-   protected void SetAuditRule(AuditRule rule);
  }
- public sealed class CommonSecurityDescriptor : GenericSecurityDescriptor {
-   public CommonSecurityDescriptor(bool isContainer, bool isDS, byte[] binaryForm, int offset);
-   public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
-   public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
-   public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
-   public override ControlFlags ControlFlags { get; }
-   public DiscretionaryAcl DiscretionaryAcl { get; set; }
-   public override SecurityIdentifier Group { get; set; }
-   public bool IsContainer { get; }
-   public bool IsDiscretionaryAclCanonical { get; }
-   public bool IsDS { get; }
-   public bool IsSystemAclCanonical { get; }
-   public override SecurityIdentifier Owner { get; set; }
-   public SystemAcl SystemAcl { get; set; }
-   public void AddDiscretionaryAcl(byte revision, int trusted);
-   public void AddSystemAcl(byte revision, int trusted);
-   public void PurgeAccessControl(SecurityIdentifier sid);
-   public void PurgeAudit(SecurityIdentifier sid);
-   public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
-   public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
  }
- public sealed class CompoundAce : KnownAce {
-   public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
-   public override int BinaryLength { get; }
-   public CompoundAceType CompoundAceType { get; set; }
-   public override void GetBinaryForm(byte[] binaryForm, int offset);
  }
- public enum CompoundAceType {
-   Impersonation = 1,
  }
- public enum ControlFlags {
-   DiscretionaryAclAutoInherited = 1024,
-   DiscretionaryAclAutoInheritRequired = 256,
-   DiscretionaryAclDefaulted = 8,
-   DiscretionaryAclPresent = 4,
-   DiscretionaryAclProtected = 4096,
-   DiscretionaryAclUntrusted = 64,
-   GroupDefaulted = 2,
-   None = 0,
-   OwnerDefaulted = 1,
-   RMControlValid = 16384,
-   SelfRelative = 32768,
-   ServerSecurity = 128,
-   SystemAclAutoInherited = 2048,
-   SystemAclAutoInheritRequired = 512,
-   SystemAclDefaulted = 32,
-   SystemAclPresent = 16,
-   SystemAclProtected = 8192,
  }
- public sealed class CryptoKeyAccessRule : AccessRule {
-   public CryptoKeyAccessRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
-   public CryptoKeyAccessRule(string identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
-   public CryptoKeyRights CryptoKeyRights { get; }
  }
- public sealed class CryptoKeyAuditRule : AuditRule {
-   public CryptoKeyAuditRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
-   public CryptoKeyAuditRule(string identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
-   public CryptoKeyRights CryptoKeyRights { get; }
  }
- public enum CryptoKeyRights {
-   ChangePermissions = 262144,
-   Delete = 65536,
-   FullControl = 2032027,
-   GenericAll = 268435456,
-   GenericExecute = 536870912,
-   GenericRead = -2147483648,
-   GenericWrite = 1073741824,
-   ReadAttributes = 128,
-   ReadData = 1,
-   ReadExtendedAttributes = 8,
-   ReadPermissions = 131072,
-   Synchronize = 1048576,
-   TakeOwnership = 524288,
-   WriteAttributes = 256,
-   WriteData = 2,
-   WriteExtendedAttributes = 16,
  }
- public sealed class CryptoKeySecurity : NativeObjectSecurity {
-   public CryptoKeySecurity();
-   public CryptoKeySecurity(CommonSecurityDescriptor securityDescriptor);
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public void AddAccessRule(CryptoKeyAccessRule rule);
-   public void AddAuditRule(CryptoKeyAuditRule rule);
-   public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public bool RemoveAccessRule(CryptoKeyAccessRule rule);
-   public void RemoveAccessRuleAll(CryptoKeyAccessRule rule);
-   public void RemoveAccessRuleSpecific(CryptoKeyAccessRule rule);
-   public bool RemoveAuditRule(CryptoKeyAuditRule rule);
-   public void RemoveAuditRuleAll(CryptoKeyAuditRule rule);
-   public void RemoveAuditRuleSpecific(CryptoKeyAuditRule rule);
-   public void ResetAccessRule(CryptoKeyAccessRule rule);
-   public void SetAccessRule(CryptoKeyAccessRule rule);
-   public void SetAuditRule(CryptoKeyAuditRule rule);
  }
- public sealed class CustomAce : GenericAce {
-   public static readonly int MaxOpaqueLength;
-   public CustomAce(AceType type, AceFlags flags, byte[] opaque);
-   public override int BinaryLength { get; }
-   public int OpaqueLength { get; }
-   public override void GetBinaryForm(byte[] binaryForm, int offset);
-   public byte[] GetOpaque();
-   public void SetOpaque(byte[] opaque);
  }
- public abstract class DirectoryObjectSecurity : ObjectSecurity {
-   protected DirectoryObjectSecurity();
-   protected DirectoryObjectSecurity(CommonSecurityDescriptor securityDescriptor);
-   public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType);
-   protected void AddAccessRule(ObjectAccessRule rule);
-   protected void AddAuditRule(ObjectAuditRule rule);
-   public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType);
-   public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
-   public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
-   protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
-   protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
-   protected bool RemoveAccessRule(ObjectAccessRule rule);
-   protected void RemoveAccessRuleAll(ObjectAccessRule rule);
-   protected void RemoveAccessRuleSpecific(ObjectAccessRule rule);
-   protected bool RemoveAuditRule(ObjectAuditRule rule);
-   protected void RemoveAuditRuleAll(ObjectAuditRule rule);
-   protected void RemoveAuditRuleSpecific(ObjectAuditRule rule);
-   protected void ResetAccessRule(ObjectAccessRule rule);
-   protected void SetAccessRule(ObjectAccessRule rule);
-   protected void SetAuditRule(ObjectAuditRule rule);
  }
- public sealed class DirectorySecurity : FileSystemSecurity {
-   public DirectorySecurity();
-   public DirectorySecurity(string name, AccessControlSections includeSections);
  }
- public sealed class DiscretionaryAcl : CommonAcl {
-   public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
-   public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
-   public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
-   public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
-   public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
-   public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
-   public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
  }
- public sealed class EventWaitHandleAccessRule : AccessRule {
-   public EventWaitHandleAccessRule(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type);
-   public EventWaitHandleAccessRule(string identity, EventWaitHandleRights eventRights, AccessControlType type);
-   public EventWaitHandleRights EventWaitHandleRights { get; }
  }
- public sealed class EventWaitHandleAuditRule : AuditRule {
-   public EventWaitHandleAuditRule(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags);
-   public EventWaitHandleRights EventWaitHandleRights { get; }
  }
- public enum EventWaitHandleRights {
-   ChangePermissions = 262144,
-   Delete = 65536,
-   FullControl = 2031619,
-   Modify = 2,
-   ReadPermissions = 131072,
-   Synchronize = 1048576,
-   TakeOwnership = 524288,
  }
- public sealed class EventWaitHandleSecurity : NativeObjectSecurity {
-   public EventWaitHandleSecurity();
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public void AddAccessRule(EventWaitHandleAccessRule rule);
-   public void AddAuditRule(EventWaitHandleAuditRule rule);
-   public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public bool RemoveAccessRule(EventWaitHandleAccessRule rule);
-   public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule);
-   public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule);
-   public bool RemoveAuditRule(EventWaitHandleAuditRule rule);
-   public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule);
-   public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule);
-   public void ResetAccessRule(EventWaitHandleAccessRule rule);
-   public void SetAccessRule(EventWaitHandleAccessRule rule);
-   public void SetAuditRule(EventWaitHandleAuditRule rule);
  }
- public sealed class FileSecurity : FileSystemSecurity {
-   public FileSecurity();
-   public FileSecurity(string fileName, AccessControlSections includeSections);
  }
- public sealed class FileSystemAccessRule : AccessRule {
-   public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type);
-   public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, AccessControlType type);
-   public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public FileSystemRights FileSystemRights { get; }
  }
- public sealed class FileSystemAuditRule : AuditRule {
-   public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags);
-   public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, AuditFlags flags);
-   public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public FileSystemRights FileSystemRights { get; }
  }
- public enum FileSystemRights {
-   AppendData = 4,
-   ChangePermissions = 262144,
-   CreateDirectories = 4,
-   CreateFiles = 2,
-   Delete = 65536,
-   DeleteSubdirectoriesAndFiles = 64,
-   ExecuteFile = 32,
-   FullControl = 2032127,
-   ListDirectory = 1,
-   Modify = 197055,
-   Read = 131209,
-   ReadAndExecute = 131241,
-   ReadAttributes = 128,
-   ReadData = 1,
-   ReadExtendedAttributes = 8,
-   ReadPermissions = 131072,
-   Synchronize = 1048576,
-   TakeOwnership = 524288,
-   Traverse = 32,
-   Write = 278,
-   WriteAttributes = 256,
-   WriteData = 2,
-   WriteExtendedAttributes = 16,
  }
- public abstract class FileSystemSecurity : NativeObjectSecurity {
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public void AddAccessRule(FileSystemAccessRule rule);
-   public void AddAuditRule(FileSystemAuditRule rule);
-   public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public bool RemoveAccessRule(FileSystemAccessRule rule);
-   public void RemoveAccessRuleAll(FileSystemAccessRule rule);
-   public void RemoveAccessRuleSpecific(FileSystemAccessRule rule);
-   public bool RemoveAuditRule(FileSystemAuditRule rule);
-   public void RemoveAuditRuleAll(FileSystemAuditRule rule);
-   public void RemoveAuditRuleSpecific(FileSystemAuditRule rule);
-   public void ResetAccessRule(FileSystemAccessRule rule);
-   public void SetAccessRule(FileSystemAccessRule rule);
-   public void SetAuditRule(FileSystemAuditRule rule);
  }
- public abstract class GenericAce {
-   public AceFlags AceFlags { get; set; }
-   public AceType AceType { get; }
-   public AuditFlags AuditFlags { get; }
-   public abstract int BinaryLength { get; }
-   public InheritanceFlags InheritanceFlags { get; }
-   public bool IsInherited { get; }
-   public PropagationFlags PropagationFlags { get; }
-   public GenericAce Copy();
-   public static GenericAce CreateFromBinaryForm(byte[] binaryForm, int offset);
-   public sealed override bool Equals(object o);
-   public abstract void GetBinaryForm(byte[] binaryForm, int offset);
-   public sealed override int GetHashCode();
-   public static bool operator ==(GenericAce left, GenericAce right);
-   public static bool operator !=(GenericAce left, GenericAce right);
  }
- public abstract class GenericAcl : ICollection, IEnumerable {
-   public static readonly byte AclRevision;
-   public static readonly byte AclRevisionDS;
-   public static readonly int MaxBinaryLength;
-   protected GenericAcl();
-   public abstract int BinaryLength { get; }
-   public abstract int Count { get; }
-   public bool IsSynchronized { get; }
-   public abstract byte Revision { get; }
-   public virtual object SyncRoot { get; }
-   public abstract GenericAce this[int index] { get; set; }
-   public void CopyTo(GenericAce[] array, int index);
-   public abstract void GetBinaryForm(byte[] binaryForm, int offset);
-   public AceEnumerator GetEnumerator();
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public abstract class GenericSecurityDescriptor {
-   protected GenericSecurityDescriptor();
-   public int BinaryLength { get; }
-   public abstract ControlFlags ControlFlags { get; }
-   public abstract SecurityIdentifier Group { get; set; }
-   public abstract SecurityIdentifier Owner { get; set; }
-   public static byte Revision { get; }
-   public void GetBinaryForm(byte[] binaryForm, int offset);
-   public string GetSddlForm(AccessControlSections includeSections);
-   public static bool IsSddlConversionSupported();
  }
- public enum InheritanceFlags {
-   ContainerInherit = 1,
-   None = 0,
-   ObjectInherit = 2,
  }
- public abstract class KnownAce : GenericAce {
-   public int AccessMask { get; set; }
-   public SecurityIdentifier SecurityIdentifier { get; set; }
  }
- public sealed class MutexAccessRule : AccessRule {
-   public MutexAccessRule(IdentityReference identity, MutexRights eventRights, AccessControlType type);
-   public MutexAccessRule(string identity, MutexRights eventRights, AccessControlType type);
-   public MutexRights MutexRights { get; }
  }
- public sealed class MutexAuditRule : AuditRule {
-   public MutexAuditRule(IdentityReference identity, MutexRights eventRights, AuditFlags flags);
-   public MutexRights MutexRights { get; }
  }
- public enum MutexRights {
-   ChangePermissions = 262144,
-   Delete = 65536,
-   FullControl = 2031617,
-   Modify = 1,
-   ReadPermissions = 131072,
-   Synchronize = 1048576,
-   TakeOwnership = 524288,
  }
- public sealed class MutexSecurity : NativeObjectSecurity {
-   public MutexSecurity();
-   public MutexSecurity(string name, AccessControlSections includeSections);
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public void AddAccessRule(MutexAccessRule rule);
-   public void AddAuditRule(MutexAuditRule rule);
-   public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public bool RemoveAccessRule(MutexAccessRule rule);
-   public void RemoveAccessRuleAll(MutexAccessRule rule);
-   public void RemoveAccessRuleSpecific(MutexAccessRule rule);
-   public bool RemoveAuditRule(MutexAuditRule rule);
-   public void RemoveAuditRuleAll(MutexAuditRule rule);
-   public void RemoveAuditRuleSpecific(MutexAuditRule rule);
-   public void ResetAccessRule(MutexAccessRule rule);
-   public void SetAccessRule(MutexAccessRule rule);
-   public void SetAuditRule(MutexAuditRule rule);
  }
- public abstract class NativeObjectSecurity : CommonObjectSecurity {
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
-   protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
-   protected sealed override void Persist(SafeHandle handle, AccessControlSections includeSections);
-   protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
-   protected sealed override void Persist(string name, AccessControlSections includeSections);
-   protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
-   protected internal delegate Exception ExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context);
  }
- public abstract class ObjectAccessRule : AccessRule {
-   protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
-   public Guid InheritedObjectType { get; }
-   public ObjectAceFlags ObjectFlags { get; }
-   public Guid ObjectType { get; }
  }
- public sealed class ObjectAce : QualifiedAce {
-   public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, byte[] opaque);
-   public override int BinaryLength { get; }
-   public Guid InheritedObjectAceType { get; set; }
-   public ObjectAceFlags ObjectAceFlags { get; set; }
-   public Guid ObjectAceType { get; set; }
-   public override void GetBinaryForm(byte[] binaryForm, int offset);
-   public static int MaxOpaqueLength(bool isCallback);
  }
- public enum ObjectAceFlags {
-   InheritedObjectAceTypePresent = 2,
-   None = 0,
-   ObjectAceTypePresent = 1,
  }
- public abstract class ObjectAuditRule : AuditRule {
-   protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
-   public Guid InheritedObjectType { get; }
-   public ObjectAceFlags ObjectFlags { get; }
-   public Guid ObjectType { get; }
  }
- public abstract class ObjectSecurity {
-   protected ObjectSecurity();
-   protected ObjectSecurity(bool isContainer, bool isDS);
-   protected ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
-   public abstract Type AccessRightType { get; }
-   protected bool AccessRulesModified { get; set; }
-   public abstract Type AccessRuleType { get; }
-   public bool AreAccessRulesCanonical { get; }
-   public bool AreAccessRulesProtected { get; }
-   public bool AreAuditRulesCanonical { get; }
-   public bool AreAuditRulesProtected { get; }
-   protected bool AuditRulesModified { get; set; }
-   public abstract Type AuditRuleType { get; }
-   protected bool GroupModified { get; set; }
-   protected bool IsContainer { get; }
-   protected bool IsDS { get; }
-   protected bool OwnerModified { get; set; }
-   public abstract AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public abstract AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public IdentityReference GetGroup(Type targetType);
-   public IdentityReference GetOwner(Type targetType);
-   public byte[] GetSecurityDescriptorBinaryForm();
-   public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
-   public static bool IsSddlConversionSupported();
-   protected abstract bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
-   public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, out bool modified);
-   protected abstract bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
-   public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, out bool modified);
-   protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
-   protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
-   protected virtual void Persist(string name, AccessControlSections includeSections);
-   public virtual void PurgeAccessRules(IdentityReference identity);
-   public virtual void PurgeAuditRules(IdentityReference identity);
-   protected void ReadLock();
-   protected void ReadUnlock();
-   public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
-   public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
-   public void SetGroup(IdentityReference identity);
-   public void SetOwner(IdentityReference identity);
-   public void SetSecurityDescriptorBinaryForm(byte[] binaryForm);
-   public void SetSecurityDescriptorBinaryForm(byte[] binaryForm, AccessControlSections includeSections);
-   public void SetSecurityDescriptorSddlForm(string sddlForm);
-   public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
-   protected void WriteLock();
-   protected void WriteUnlock();
  }
- public abstract class ObjectSecurity<T> : NativeObjectSecurity where T : struct {
-   protected ObjectSecurity(bool isContainer, ResourceType resourceType);
-   protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
-   protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
-   protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
-   protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public virtual void AddAccessRule(AccessRule<T> rule);
-   public virtual void AddAuditRule(AuditRule<T> rule);
-   public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   protected internal void Persist(SafeHandle handle);
-   protected internal void Persist(string name);
-   public virtual bool RemoveAccessRule(AccessRule<T> rule);
-   public virtual void RemoveAccessRuleAll(AccessRule<T> rule);
-   public virtual void RemoveAccessRuleSpecific(AccessRule<T> rule);
-   public virtual bool RemoveAuditRule(AuditRule<T> rule);
-   public virtual void RemoveAuditRuleAll(AuditRule<T> rule);
-   public virtual void RemoveAuditRuleSpecific(AuditRule<T> rule);
-   public virtual void ResetAccessRule(AccessRule<T> rule);
-   public virtual void SetAccessRule(AccessRule<T> rule);
-   public virtual void SetAuditRule(AuditRule<T> rule);
  }
- public sealed class PrivilegeNotHeldException : UnauthorizedAccessException, ISerializable {
-   public PrivilegeNotHeldException();
-   public PrivilegeNotHeldException(string privilege);
-   public PrivilegeNotHeldException(string privilege, Exception inner);
-   public string PrivilegeName { get; }
-   public override void GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public enum PropagationFlags {
-   InheritOnly = 2,
-   None = 0,
-   NoPropagateInherit = 1,
  }
- public abstract class QualifiedAce : KnownAce {
-   public AceQualifier AceQualifier { get; }
-   public bool IsCallback { get; }
-   public int OpaqueLength { get; }
-   public byte[] GetOpaque();
-   public void SetOpaque(byte[] opaque);
  }
- public sealed class RawAcl : GenericAcl {
-   public RawAcl(byte revision, int capacity);
-   public RawAcl(byte[] binaryForm, int offset);
-   public override int BinaryLength { get; }
-   public override int Count { get; }
-   public override byte Revision { get; }
-   public override GenericAce this[int index] { get; set; }
-   public override void GetBinaryForm(byte[] binaryForm, int offset);
-   public void InsertAce(int index, GenericAce ace);
-   public void RemoveAce(int index);
  }
- public sealed class RawSecurityDescriptor : GenericSecurityDescriptor {
-   public RawSecurityDescriptor(byte[] binaryForm, int offset);
-   public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
-   public RawSecurityDescriptor(string sddlForm);
-   public override ControlFlags ControlFlags { get; }
-   public RawAcl DiscretionaryAcl { get; set; }
-   public override SecurityIdentifier Group { get; set; }
-   public override SecurityIdentifier Owner { get; set; }
-   public byte ResourceManagerControl { get; set; }
-   public RawAcl SystemAcl { get; set; }
-   public void SetFlags(ControlFlags flags);
  }
- public sealed class RegistryAccessRule : AccessRule {
-   public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, AccessControlType type);
-   public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public RegistryAccessRule(string identity, RegistryRights registryRights, AccessControlType type);
-   public RegistryAccessRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public RegistryRights RegistryRights { get; }
  }
- public sealed class RegistryAuditRule : AuditRule {
-   public RegistryAuditRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public RegistryAuditRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public RegistryRights RegistryRights { get; }
  }
- public enum RegistryRights {
-   ChangePermissions = 262144,
-   CreateLink = 32,
-   CreateSubKey = 4,
-   Delete = 65536,
-   EnumerateSubKeys = 8,
-   ExecuteKey = 131097,
-   FullControl = 983103,
-   Notify = 16,
-   QueryValues = 1,
-   ReadKey = 131097,
-   ReadPermissions = 131072,
-   SetValue = 2,
-   TakeOwnership = 524288,
-   WriteKey = 131078,
  }
- public sealed class RegistrySecurity : NativeObjectSecurity {
-   public RegistrySecurity();
-   public override Type AccessRightType { get; }
-   public override Type AccessRuleType { get; }
-   public override Type AuditRuleType { get; }
-   public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
-   public void AddAccessRule(RegistryAccessRule rule);
-   public void AddAuditRule(RegistryAuditRule rule);
-   public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
-   public bool RemoveAccessRule(RegistryAccessRule rule);
-   public void RemoveAccessRuleAll(RegistryAccessRule rule);
-   public void RemoveAccessRuleSpecific(RegistryAccessRule rule);
-   public bool RemoveAuditRule(RegistryAuditRule rule);
-   public void RemoveAuditRuleAll(RegistryAuditRule rule);
-   public void RemoveAuditRuleSpecific(RegistryAuditRule rule);
-   public void ResetAccessRule(RegistryAccessRule rule);
-   public void SetAccessRule(RegistryAccessRule rule);
-   public void SetAuditRule(RegistryAuditRule rule);
  }
- public enum ResourceType {
-   DSObject = 8,
-   DSObjectAll = 9,
-   FileObject = 1,
-   KernelObject = 6,
-   LMShare = 5,
-   Printer = 3,
-   ProviderDefined = 10,
-   RegistryKey = 4,
-   RegistryWow6432Key = 12,
-   Service = 2,
-   Unknown = 0,
-   WindowObject = 7,
-   WmiGuidObject = 11,
  }
- public enum SecurityInfos {
-   DiscretionaryAcl = 4,
-   Group = 2,
-   Owner = 1,
-   SystemAcl = 8,
  }
- public sealed class SystemAcl : CommonAcl {
-   public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
-   public SystemAcl(bool isContainer, bool isDS, int capacity);
-   public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
-   public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule);
-   public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule);
-   public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule);
-   public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
-   public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
-   public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule);
  }
 }
-namespace System.Security.Claims {
- public class Claim {
-   public Claim(BinaryReader reader);
-   public Claim(BinaryReader reader, ClaimsIdentity subject);
-   protected Claim(Claim other);
-   protected Claim(Claim other, ClaimsIdentity subject);
-   public Claim(string type, string value);
-   public Claim(string type, string value, string valueType);
-   public Claim(string type, string value, string valueType, string issuer);
-   public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
-   public Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject);
-   protected virtual byte[] CustomSerializationData { get; }
-   public string Issuer { get; }
-   public string OriginalIssuer { get; }
-   public IDictionary<string, string> Properties { get; }
-   public ClaimsIdentity Subject { get; }
-   public string Type { get; }
-   public string Value { get; }
-   public string ValueType { get; }
-   public virtual Claim Clone();
-   public virtual Claim Clone(ClaimsIdentity identity);
-   public override string ToString();
-   public virtual void WriteTo(BinaryWriter writer);
-   protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
  }
- public class ClaimsIdentity : IIdentity {
-   public const string DefaultIssuer = "LOCAL AUTHORITY";
-   public const string DefaultNameClaimType = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
-   public const string DefaultRoleClaimType = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
-   public ClaimsIdentity();
-   public ClaimsIdentity(IEnumerable<Claim> claims);
-   public ClaimsIdentity(IEnumerable<Claim> claims, string authenticationType);
-   public ClaimsIdentity(IEnumerable<Claim> claims, string authenticationType, string nameType, string roleType);
-   public ClaimsIdentity(BinaryReader reader);
-   protected ClaimsIdentity(SerializationInfo info);
-   protected ClaimsIdentity(SerializationInfo info, StreamingContext context);
-   protected ClaimsIdentity(ClaimsIdentity other);
-   public ClaimsIdentity(IIdentity identity);
-   public ClaimsIdentity(IIdentity identity, IEnumerable<Claim> claims);
-   public ClaimsIdentity(IIdentity identity, IEnumerable<Claim> claims, string authenticationType, string nameType, string roleType);
-   public ClaimsIdentity(string authenticationType);
-   public ClaimsIdentity(string authenticationType, string nameType, string roleType);
-   public ClaimsIdentity Actor { get; set; }
-   public virtual string AuthenticationType { get; }
-   public object BootstrapContext { get; set; }
-   public virtual IEnumerable<Claim> Claims { get; }
-   protected virtual byte[] CustomSerializationData { get; }
-   public virtual bool IsAuthenticated { get; }
-   public string Label { get; set; }
-   public virtual string Name { get; }
-   public string NameClaimType { get; }
-   public string RoleClaimType { get; }
-   public virtual void AddClaim(Claim claim);
-   public virtual void AddClaims(IEnumerable<Claim> claims);
-   public virtual ClaimsIdentity Clone();
-   protected virtual Claim CreateClaim(BinaryReader reader);
-   public virtual IEnumerable<Claim> FindAll(Predicate<Claim> match);
-   public virtual IEnumerable<Claim> FindAll(string type);
-   public virtual Claim FindFirst(Predicate<Claim> match);
-   public virtual Claim FindFirst(string type);
-   protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual bool HasClaim(Predicate<Claim> match);
-   public virtual bool HasClaim(string type, string value);
-   public virtual void RemoveClaim(Claim claim);
-   public virtual bool TryRemoveClaim(Claim claim);
-   public virtual void WriteTo(BinaryWriter writer);
-   protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
  }
- public class ClaimsPrincipal : IPrincipal {
-   public ClaimsPrincipal();
-   public ClaimsPrincipal(IEnumerable<ClaimsIdentity> identities);
-   public ClaimsPrincipal(BinaryReader reader);
-   protected ClaimsPrincipal(SerializationInfo info, StreamingContext context);
-   public ClaimsPrincipal(IIdentity identity);
-   public ClaimsPrincipal(IPrincipal principal);
-   public virtual IEnumerable<Claim> Claims { get; }
-   public static Func<ClaimsPrincipal> ClaimsPrincipalSelector { get; set; }
-   public static ClaimsPrincipal Current { get; }
-   protected virtual byte[] CustomSerializationData { get; }
-   public virtual IEnumerable<ClaimsIdentity> Identities { get; }
-   public virtual IIdentity Identity { get; }
-   public static Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector { get; set; }
-   public virtual void AddIdentities(IEnumerable<ClaimsIdentity> identities);
-   public virtual void AddIdentity(ClaimsIdentity identity);
-   public virtual ClaimsPrincipal Clone();
-   protected virtual ClaimsIdentity CreateClaimsIdentity(BinaryReader reader);
-   public virtual IEnumerable<Claim> FindAll(Predicate<Claim> match);
-   public virtual IEnumerable<Claim> FindAll(string type);
-   public virtual Claim FindFirst(Predicate<Claim> match);
-   public virtual Claim FindFirst(string type);
-   protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
-   public virtual bool HasClaim(Predicate<Claim> match);
-   public virtual bool HasClaim(string type, string value);
-   public virtual bool IsInRole(string role);
-   public virtual void WriteTo(BinaryWriter writer);
-   protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
  }
- public static class ClaimTypes {
-   public const string Actor = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims/actor";
-   public const string Anonymous = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/anonymous";
-   public const string Authentication = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authentication";
-   public const string AuthenticationInstant = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationinstant";
-   public const string AuthenticationMethod = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod";
-   public const string AuthorizationDecision = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authorizationdecision";
-   public const string CookiePath = "http://schemas.microsoft.com/ws/2008/06/identity/claims/cookiepath";
-   public const string Country = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country";
-   public const string DateOfBirth = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dateofbirth";
-   public const string DenyOnlyPrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid";
-   public const string DenyOnlyPrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid";
-   public const string DenyOnlySid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/denyonlysid";
-   public const string DenyOnlyWindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlywindowsdevicegroup";
-   public const string Dns = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dns";
-   public const string Dsa = "http://schemas.microsoft.com/ws/2008/06/identity/claims/dsa";
-   public const string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
-   public const string Expiration = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expiration";
-   public const string Expired = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expired";
-   public const string Gender = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/gender";
-   public const string GivenName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname";
-   public const string GroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid";
-   public const string Hash = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/hash";
-   public const string HomePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/homephone";
-   public const string IsPersistent = "http://schemas.microsoft.com/ws/2008/06/identity/claims/ispersistent";
-   public const string Locality = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/locality";
-   public const string MobilePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/mobilephone";
-   public const string Name = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
-   public const string NameIdentifier = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier";
-   public const string OtherPhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/otherphone";
-   public const string PostalCode = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/postalcode";
-   public const string PrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid";
-   public const string PrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid";
-   public const string Role = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
-   public const string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
-   public const string SerialNumber = "http://schemas.microsoft.com/ws/2008/06/identity/claims/serialnumber";
-   public const string Sid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/sid";
-   public const string Spn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/spn";
-   public const string StateOrProvince = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/stateorprovince";
-   public const string StreetAddress = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/streetaddress";
-   public const string Surname = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname";
-   public const string System = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/system";
-   public const string Thumbprint = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/thumbprint";
-   public const string Upn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn";
-   public const string Uri = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/uri";
-   public const string UserData = "http://schemas.microsoft.com/ws/2008/06/identity/claims/userdata";
-   public const string Version = "http://schemas.microsoft.com/ws/2008/06/identity/claims/version";
-   public const string Webpage = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/webpage";
-   public const string WindowsAccountName = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname";
-   public const string WindowsDeviceClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdeviceclaim";
-   public const string WindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdevicegroup";
-   public const string WindowsFqbnVersion = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsfqbnversion";
-   public const string WindowsSubAuthority = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowssubauthority";
-   public const string WindowsUserClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsuserclaim";
-   public const string X500DistinguishedName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/x500distinguishedname";
  }
- public static class ClaimValueTypes {
-   public const string Base64Binary = "http://www.w3.org/2001/XMLSchema#base64Binary";
-   public const string Base64Octet = "http://www.w3.org/2001/XMLSchema#base64Octet";
-   public const string Boolean = "http://www.w3.org/2001/XMLSchema#boolean";
-   public const string Date = "http://www.w3.org/2001/XMLSchema#date";
-   public const string DateTime = "http://www.w3.org/2001/XMLSchema#dateTime";
-   public const string DaytimeDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#dayTimeDuration";
-   public const string DnsName = "http://schemas.xmlsoap.org/claims/dns";
-   public const string Double = "http://www.w3.org/2001/XMLSchema#double";
-   public const string DsaKeyValue = "http://www.w3.org/2000/09/xmldsig#DSAKeyValue";
-   public const string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
-   public const string Fqbn = "http://www.w3.org/2001/XMLSchema#fqbn";
-   public const string HexBinary = "http://www.w3.org/2001/XMLSchema#hexBinary";
-   public const string Integer = "http://www.w3.org/2001/XMLSchema#integer";
-   public const string Integer32 = "http://www.w3.org/2001/XMLSchema#integer32";
-   public const string Integer64 = "http://www.w3.org/2001/XMLSchema#integer64";
-   public const string KeyInfo = "http://www.w3.org/2000/09/xmldsig#KeyInfo";
-   public const string Rfc822Name = "urn:oasis:names:tc:xacml:1.0:data-type:rfc822Name";
-   public const string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
-   public const string RsaKeyValue = "http://www.w3.org/2000/09/xmldsig#RSAKeyValue";
-   public const string Sid = "http://www.w3.org/2001/XMLSchema#sid";
-   public const string String = "http://www.w3.org/2001/XMLSchema#string";
-   public const string Time = "http://www.w3.org/2001/XMLSchema#time";
-   public const string UInteger32 = "http://www.w3.org/2001/XMLSchema#uinteger32";
-   public const string UInteger64 = "http://www.w3.org/2001/XMLSchema#uinteger64";
-   public const string UpnName = "http://schemas.xmlsoap.org/claims/UPN";
-   public const string X500Name = "urn:oasis:names:tc:xacml:1.0:data-type:x500Name";
-   public const string YearMonthDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#yearMonthDuration";
  }
 }
-namespace System.Security.Cryptography {
- public abstract class Aes : SymmetricAlgorithm {
-   protected Aes();
-   public static new Aes Create();
-   public static new Aes Create(string algorithmName);
  }
- public abstract class AsymmetricAlgorithm : IDisposable {
-   protected int KeySizeValue;
-   protected KeySizes[] LegalKeySizesValue;
-   protected AsymmetricAlgorithm();
-   public virtual string KeyExchangeAlgorithm { get; }
-   public virtual int KeySize { get; set; }
-   public virtual KeySizes[] LegalKeySizes { get; }
-   public virtual string SignatureAlgorithm { get; }
-   public void Clear();
-   public static AsymmetricAlgorithm Create();
-   public static AsymmetricAlgorithm Create(string algName);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public virtual void FromXmlString(string xmlString);
-   public virtual string ToXmlString(bool includePrivateParameters);
  }
- public abstract class AsymmetricKeyExchangeDeformatter {
-   protected AsymmetricKeyExchangeDeformatter();
-   public abstract string Parameters { get; set; }
-   public abstract byte[] DecryptKeyExchange(byte[] rgb);
-   public abstract void SetKey(AsymmetricAlgorithm key);
  }
- public abstract class AsymmetricKeyExchangeFormatter {
-   protected AsymmetricKeyExchangeFormatter();
-   public abstract string Parameters { get; }
-   public abstract byte[] CreateKeyExchange(byte[] data);
-   public abstract byte[] CreateKeyExchange(byte[] data, Type symAlgType);
-   public abstract void SetKey(AsymmetricAlgorithm key);
  }
- public abstract class AsymmetricSignatureDeformatter {
-   protected AsymmetricSignatureDeformatter();
-   public abstract void SetHashAlgorithm(string strName);
-   public abstract void SetKey(AsymmetricAlgorithm key);
-   public abstract bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
-   public virtual bool VerifySignature(HashAlgorithm hash, byte[] rgbSignature);
  }
- public abstract class AsymmetricSignatureFormatter {
-   protected AsymmetricSignatureFormatter();
-   public abstract byte[] CreateSignature(byte[] rgbHash);
-   public virtual byte[] CreateSignature(HashAlgorithm hash);
-   public abstract void SetHashAlgorithm(string strName);
-   public abstract void SetKey(AsymmetricAlgorithm key);
  }
- public enum CipherMode {
-   CBC = 1,
-   CFB = 4,
-   CTS = 5,
-   ECB = 2,
-   OFB = 3,
  }
- public sealed class CryptoAPITransform : ICryptoTransform, IDisposable {
-   public bool CanReuseTransform { get; }
-   public bool CanTransformMultipleBlocks { get; }
-   public int InputBlockSize { get; }
-   public IntPtr KeyHandle { get; }
-   public int OutputBlockSize { get; }
-   public void Clear();
-   public void Dispose();
-   public void Reset();
-   public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- public class CryptoConfig {
-   public CryptoConfig();
-   public static bool AllowOnlyFipsAlgorithms { get; }
-   public static void AddAlgorithm(Type algorithm, params string[] names);
-   public static void AddOID(string oid, params string[] names);
-   public static object CreateFromName(string name);
-   public static object CreateFromName(string name, params object[] args);
-   public static byte[] EncodeOID(string str);
-   public static string MapNameToOID(string name);
  }
- public class CryptographicException : SystemException {
-   public CryptographicException();
-   public CryptographicException(int hr);
-   protected CryptographicException(SerializationInfo info, StreamingContext context);
-   public CryptographicException(string message);
-   public CryptographicException(string message, Exception inner);
-   public CryptographicException(string format, string insert);
  }
- public class CryptographicUnexpectedOperationException : CryptographicException {
-   public CryptographicUnexpectedOperationException();
-   protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
-   public CryptographicUnexpectedOperationException(string message);
-   public CryptographicUnexpectedOperationException(string message, Exception inner);
-   public CryptographicUnexpectedOperationException(string format, string insert);
  }
- public class CryptoStream : Stream, IDisposable {
-   public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
-   public override bool CanRead { get; }
-   public override bool CanSeek { get; }
-   public override bool CanWrite { get; }
-   public bool HasFlushedFinalBlock { get; }
-   public override long Length { get; }
-   public override long Position { get; set; }
-   public void Clear();
-   protected override void Dispose(bool disposing);
-   public override void Flush();
-   public override Task FlushAsync(CancellationToken cancellationToken);
-   public void FlushFinalBlock();
-   public override int Read(byte[] buffer, int offset, int count);
-   public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
-   public override long Seek(long offset, SeekOrigin origin);
-   public override void SetLength(long value);
-   public override void Write(byte[] buffer, int offset, int count);
-   public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
  }
- public enum CryptoStreamMode {
-   Read = 0,
-   Write = 1,
  }
- public sealed class CspKeyContainerInfo {
-   public CspKeyContainerInfo(CspParameters parameters);
-   public bool Accessible { get; }
-   public CryptoKeySecurity CryptoKeySecurity { get; }
-   public bool Exportable { get; }
-   public bool HardwareDevice { get; }
-   public string KeyContainerName { get; }
-   public KeyNumber KeyNumber { get; }
-   public bool MachineKeyStore { get; }
-   public bool Protected { get; }
-   public string ProviderName { get; }
-   public int ProviderType { get; }
-   public bool RandomlyGenerated { get; }
-   public bool Removable { get; }
-   public string UniqueKeyContainerName { get; }
  }
- public sealed class CspParameters {
-   public int KeyNumber;
-   public int ProviderType;
-   public string KeyContainerName;
-   public string ProviderName;
-   public CspParameters();
-   public CspParameters(int dwTypeIn);
-   public CspParameters(int dwTypeIn, string strProviderNameIn);
-   public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
-   public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, IntPtr parentWindowHandle);
-   public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, SecureString keyPassword);
-   public CryptoKeySecurity CryptoKeySecurity { get; set; }
-   public CspProviderFlags Flags { get; set; }
-   public SecureString KeyPassword { get; set; }
-   public IntPtr ParentWindowHandle { get; set; }
  }
- public enum CspProviderFlags {
-   CreateEphemeralKey = 128,
-   NoFlags = 0,
-   NoPrompt = 64,
-   UseArchivableKey = 16,
-   UseDefaultKeyContainer = 2,
-   UseExistingKey = 8,
-   UseMachineKeyStore = 1,
-   UseNonExportableKey = 4,
-   UseUserProtectedKey = 32,
  }
- public abstract class DeriveBytes : IDisposable {
-   protected DeriveBytes();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public abstract byte[] GetBytes(int cb);
-   public abstract void Reset();
  }
- public abstract class DES : SymmetricAlgorithm {
-   protected DES();
-   public override byte[] Key { get; set; }
-   public static new DES Create();
-   public static new DES Create(string algName);
-   public static bool IsSemiWeakKey(byte[] rgbKey);
-   public static bool IsWeakKey(byte[] rgbKey);
  }
- public sealed class DESCryptoServiceProvider : DES {
-   public DESCryptoServiceProvider();
-   public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
-   public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
-   public override void GenerateIV();
-   public override void GenerateKey();
  }
- public abstract class DSA : AsymmetricAlgorithm {
-   protected DSA();
-   public static new DSA Create();
-   public static new DSA Create(string algName);
-   public abstract byte[] CreateSignature(byte[] rgbHash);
-   public abstract DSAParameters ExportParameters(bool includePrivateParameters);
-   public override void FromXmlString(string xmlString);
-   protected virtual byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
-   protected virtual byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
-   public abstract void ImportParameters(DSAParameters parameters);
-   public virtual byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
-   public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm);
-   public virtual byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
-   public override string ToXmlString(bool includePrivateParameters);
-   public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm);
-   public virtual bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm);
-   public virtual bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm);
-   public abstract bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
  }
- public sealed class DSACryptoServiceProvider : DSA, ICspAsymmetricAlgorithm {
-   public DSACryptoServiceProvider();
-   public DSACryptoServiceProvider(int dwKeySize);
-   public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
-   public DSACryptoServiceProvider(CspParameters parameters);
-   public CspKeyContainerInfo CspKeyContainerInfo { get; }
-   public override string KeyExchangeAlgorithm { get; }
-   public override int KeySize { get; }
-   public bool PersistKeyInCsp { get; set; }
-   public bool PublicOnly { get; }
-   public override string SignatureAlgorithm { get; }
-   public static bool UseMachineKeyStore { get; set; }
-   public override byte[] CreateSignature(byte[] rgbHash);
-   protected override void Dispose(bool disposing);
-   public byte[] ExportCspBlob(bool includePrivateParameters);
-   public override DSAParameters ExportParameters(bool includePrivateParameters);
-   protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
-   protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
-   public void ImportCspBlob(byte[] keyBlob);
-   public override void ImportParameters(DSAParameters parameters);
-   public byte[] SignData(byte[] buffer);
-   public byte[] SignData(byte[] buffer, int offset, int count);
-   public byte[] SignData(Stream inputStream);
-   public byte[] SignHash(byte[] rgbHash, string str);
-   public bool VerifyData(byte[] rgbData, byte[] rgbSignature);
-   public bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
-   public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct DSAParameters {
-   public byte[] G;
-   public byte[] J;
-   public byte[] P;
-   public byte[] Q;
-   public byte[] Seed;
-   public byte[] X;
-   public byte[] Y;
-   public int Counter;
  }
- public class DSASignatureDeformatter : AsymmetricSignatureDeformatter {
-   public DSASignatureDeformatter();
-   public DSASignatureDeformatter(AsymmetricAlgorithm key);
-   public override void SetHashAlgorithm(string strName);
-   public override void SetKey(AsymmetricAlgorithm key);
-   public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
  }
- public class DSASignatureFormatter : AsymmetricSignatureFormatter {
-   public DSASignatureFormatter();
-   public DSASignatureFormatter(AsymmetricAlgorithm key);
-   public override byte[] CreateSignature(byte[] rgbHash);
-   public override void SetHashAlgorithm(string strName);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- public class FromBase64Transform : ICryptoTransform, IDisposable {
-   public FromBase64Transform();
-   public FromBase64Transform(FromBase64TransformMode whitespaces);
-   public virtual bool CanReuseTransform { get; }
-   public bool CanTransformMultipleBlocks { get; }
-   public int InputBlockSize { get; }
-   public int OutputBlockSize { get; }
-   public void Clear();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~FromBase64Transform();
-   public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- public enum FromBase64TransformMode {
-   DoNotIgnoreWhiteSpaces = 1,
-   IgnoreWhiteSpaces = 0,
  }
- public abstract class HashAlgorithm : ICryptoTransform, IDisposable {
-   protected internal byte[] HashValue;
-   protected int HashSizeValue;
-   protected int State;
-   protected HashAlgorithm();
-   public virtual bool CanReuseTransform { get; }
-   public virtual bool CanTransformMultipleBlocks { get; }
-   public virtual byte[] Hash { get; }
-   public virtual int HashSize { get; }
-   public virtual int InputBlockSize { get; }
-   public virtual int OutputBlockSize { get; }
-   public void Clear();
-   public byte[] ComputeHash(byte[] buffer);
-   public byte[] ComputeHash(byte[] buffer, int offset, int count);
-   public byte[] ComputeHash(Stream inputStream);
-   public static HashAlgorithm Create();
-   public static HashAlgorithm Create(string hashName);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   protected abstract void HashCore(byte[] array, int ibStart, int cbSize);
-   protected abstract byte[] HashFinal();
-   public abstract void Initialize();
-   public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct HashAlgorithmName : IEquatable<HashAlgorithmName> {
-   public HashAlgorithmName(string name);
-   public static HashAlgorithmName MD5 { get; }
-   public string Name { get; }
-   public static HashAlgorithmName SHA1 { get; }
-   public static HashAlgorithmName SHA256 { get; }
-   public static HashAlgorithmName SHA384 { get; }
-   public static HashAlgorithmName SHA512 { get; }
-   public override bool Equals(object obj);
-   public bool Equals(HashAlgorithmName other);
-   public override int GetHashCode();
-   public static bool operator ==(HashAlgorithmName left, HashAlgorithmName right);
-   public static bool operator !=(HashAlgorithmName left, HashAlgorithmName right);
-   public override string ToString();
  }
- public abstract class HMAC : KeyedHashAlgorithm {
-   protected HMAC();
-   protected int BlockSizeValue { get; set; }
-   public string HashName { get; set; }
-   public override byte[] Key { get; set; }
-   public static new HMAC Create();
-   public static new HMAC Create(string algorithmName);
-   protected override void Dispose(bool disposing);
-   protected override void HashCore(byte[] rgb, int ib, int cb);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public class HMACMD5 : HMAC {
-   public HMACMD5();
-   public HMACMD5(byte[] key);
  }
- public class HMACRIPEMD160 : HMAC {
-   public HMACRIPEMD160();
-   public HMACRIPEMD160(byte[] key);
  }
- public class HMACSHA1 : HMAC {
-   public HMACSHA1();
-   public HMACSHA1(byte[] key);
-   public HMACSHA1(byte[] key, bool useManagedSha1);
  }
- public class HMACSHA256 : HMAC {
-   public HMACSHA256();
-   public HMACSHA256(byte[] key);
  }
- public class HMACSHA384 : HMAC {
-   public HMACSHA384();
-   public HMACSHA384(byte[] key);
-   public bool ProduceLegacyHmacValues { get; set; }
  }
- public class HMACSHA512 : HMAC {
-   public HMACSHA512();
-   public HMACSHA512(byte[] key);
-   public bool ProduceLegacyHmacValues { get; set; }
  }
- public interface ICryptoTransform : IDisposable {
-   bool CanReuseTransform { get; }
-   bool CanTransformMultipleBlocks { get; }
-   int InputBlockSize { get; }
-   int OutputBlockSize { get; }
-   int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- public interface ICspAsymmetricAlgorithm {
-   CspKeyContainerInfo CspKeyContainerInfo { get; }
-   byte[] ExportCspBlob(bool includePrivateParameters);
-   void ImportCspBlob(byte[] rawData);
  }
- public abstract class KeyedHashAlgorithm : HashAlgorithm {
-   protected byte[] KeyValue;
-   protected KeyedHashAlgorithm();
-   public virtual byte[] Key { get; set; }
-   public static new KeyedHashAlgorithm Create();
-   public static new KeyedHashAlgorithm Create(string algName);
-   protected override void Dispose(bool disposing);
  }
- public enum KeyNumber {
-   Exchange = 1,
-   Signature = 2,
  }
- public sealed class KeySizes {
-   public KeySizes(int minSize, int maxSize, int skipSize);
-   public int MaxSize { get; }
-   public int MinSize { get; }
-   public int SkipSize { get; }
  }
- public class MACTripleDES : KeyedHashAlgorithm {
-   public MACTripleDES();
-   public MACTripleDES(byte[] rgbKey);
-   public MACTripleDES(string strTripleDES, byte[] rgbKey);
-   public PaddingMode Padding { get; set; }
-   protected override void Dispose(bool disposing);
-   protected override void HashCore(byte[] rgbData, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public abstract class MaskGenerationMethod {
-   protected MaskGenerationMethod();
-   public abstract byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
  }
- public abstract class MD5 : HashAlgorithm {
-   protected MD5();
-   public static new MD5 Create();
-   public static new MD5 Create(string algName);
  }
- public sealed class MD5CryptoServiceProvider : MD5 {
-   public MD5CryptoServiceProvider();
-   protected override void Dispose(bool disposing);
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public enum PaddingMode {
-   ANSIX923 = 4,
-   ISO10126 = 5,
-   None = 1,
-   PKCS7 = 2,
-   Zeros = 3,
  }
- public class PasswordDeriveBytes : DeriveBytes {
-   public PasswordDeriveBytes(byte[] password, byte[] salt);
-   public PasswordDeriveBytes(byte[] password, byte[] salt, CspParameters cspParams);
-   public PasswordDeriveBytes(byte[] password, byte[] salt, string hashName, int iterations);
-   public PasswordDeriveBytes(byte[] password, byte[] salt, string hashName, int iterations, CspParameters cspParams);
-   public PasswordDeriveBytes(string strPassword, byte[] rgbSalt);
-   public PasswordDeriveBytes(string strPassword, byte[] rgbSalt, CspParameters cspParams);
-   public PasswordDeriveBytes(string strPassword, byte[] rgbSalt, string strHashName, int iterations);
-   public PasswordDeriveBytes(string strPassword, byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
-   public string HashName { get; set; }
-   public int IterationCount { get; set; }
-   public byte[] Salt { get; set; }
-   public byte[] CryptDeriveKey(string algname, string alghashname, int keySize, byte[] rgbIV);
-   protected override void Dispose(bool disposing);
-   public override byte[] GetBytes(int cb);
-   public override void Reset();
  }
- public class PKCS1MaskGenerationMethod : MaskGenerationMethod {
-   public PKCS1MaskGenerationMethod();
-   public string HashName { get; set; }
-   public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
  }
- public abstract class RandomNumberGenerator : IDisposable {
-   protected RandomNumberGenerator();
-   public static RandomNumberGenerator Create();
-   public static RandomNumberGenerator Create(string rngName);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public abstract void GetBytes(byte[] data);
-   public virtual void GetBytes(byte[] data, int offset, int count);
-   public virtual void GetNonZeroBytes(byte[] data);
  }
- public abstract class RC2 : SymmetricAlgorithm {
-   protected int EffectiveKeySizeValue;
-   protected RC2();
-   public virtual int EffectiveKeySize { get; set; }
-   public override int KeySize { get; set; }
-   public static new RC2 Create();
-   public static new RC2 Create(string AlgName);
  }
- public sealed class RC2CryptoServiceProvider : RC2 {
-   public RC2CryptoServiceProvider();
-   public override int EffectiveKeySize { get; set; }
-   public bool UseSalt { get; set; }
-   public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
-   public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
-   public override void GenerateIV();
-   public override void GenerateKey();
  }
- public class Rfc2898DeriveBytes : DeriveBytes {
-   public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations);
-   public Rfc2898DeriveBytes(string password, byte[] salt);
-   public Rfc2898DeriveBytes(string password, byte[] salt, int iterations);
-   public Rfc2898DeriveBytes(string password, int saltSize);
-   public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
-   public int IterationCount { get; set; }
-   public byte[] Salt { get; set; }
-   public byte[] CryptDeriveKey(string algname, string alghashname, int keySize, byte[] rgbIV);
-   protected override void Dispose(bool disposing);
-   public override byte[] GetBytes(int cb);
-   public override void Reset();
  }
- public abstract class Rijndael : SymmetricAlgorithm {
-   protected Rijndael();
-   public static new Rijndael Create();
-   public static new Rijndael Create(string algName);
  }
- public sealed class RijndaelManaged : Rijndael {
-   public RijndaelManaged();
-   public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
-   public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
-   public override void GenerateIV();
-   public override void GenerateKey();
  }
- public sealed class RijndaelManagedTransform : ICryptoTransform, IDisposable {
-   public int BlockSizeValue { get; }
-   public bool CanReuseTransform { get; }
-   public bool CanTransformMultipleBlocks { get; }
-   public int InputBlockSize { get; }
-   public int OutputBlockSize { get; }
-   public void Clear();
-   public void Dispose();
-   public void Reset();
-   public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- public abstract class RIPEMD160 : HashAlgorithm {
-   protected RIPEMD160();
-   public static new RIPEMD160 Create();
-   public static new RIPEMD160 Create(string hashName);
  }
- public class RIPEMD160Managed : RIPEMD160 {
-   public RIPEMD160Managed();
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public sealed class RNGCryptoServiceProvider : RandomNumberGenerator {
-   public RNGCryptoServiceProvider();
-   public RNGCryptoServiceProvider(byte[] rgb);
-   public RNGCryptoServiceProvider(CspParameters cspParams);
-   public RNGCryptoServiceProvider(string str);
-   protected override void Dispose(bool disposing);
-   public override void GetBytes(byte[] data);
-   public override void GetNonZeroBytes(byte[] data);
  }
- public abstract class RSA : AsymmetricAlgorithm {
-   protected RSA();
-   public override string KeyExchangeAlgorithm { get; }
-   public override string SignatureAlgorithm { get; }
-   public static new RSA Create();
-   public static new RSA Create(string algName);
-   public virtual byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
-   public virtual byte[] DecryptValue(byte[] rgb);
-   public virtual byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
-   public virtual byte[] EncryptValue(byte[] rgb);
-   public abstract RSAParameters ExportParameters(bool includePrivateParameters);
-   public override void FromXmlString(string xmlString);
-   protected virtual byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
-   protected virtual byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
-   public abstract void ImportParameters(RSAParameters parameters);
-   public virtual byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public virtual byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public virtual byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public override string ToXmlString(bool includePrivateParameters);
-   public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public virtual bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public virtual bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
  }
- public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm {
-   public RSACryptoServiceProvider();
-   public RSACryptoServiceProvider(int dwKeySize);
-   public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
-   public RSACryptoServiceProvider(CspParameters parameters);
-   public CspKeyContainerInfo CspKeyContainerInfo { get; }
-   public override string KeyExchangeAlgorithm { get; }
-   public override int KeySize { get; }
-   public bool PersistKeyInCsp { get; set; }
-   public bool PublicOnly { get; }
-   public override string SignatureAlgorithm { get; }
-   public static bool UseMachineKeyStore { get; set; }
-   public byte[] Decrypt(byte[] rgb, bool fOAEP);
-   public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
-   public override byte[] DecryptValue(byte[] rgb);
-   protected override void Dispose(bool disposing);
-   public byte[] Encrypt(byte[] rgb, bool fOAEP);
-   public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
-   public override byte[] EncryptValue(byte[] rgb);
-   public byte[] ExportCspBlob(bool includePrivateParameters);
-   public override RSAParameters ExportParameters(bool includePrivateParameters);
-   protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
-   protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
-   public void ImportCspBlob(byte[] keyBlob);
-   public override void ImportParameters(RSAParameters parameters);
-   public byte[] SignData(byte[] buffer, int offset, int count, object halg);
-   public byte[] SignData(byte[] buffer, object halg);
-   public byte[] SignData(Stream inputStream, object halg);
-   public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public byte[] SignHash(byte[] rgbHash, string str);
-   public bool VerifyData(byte[] buffer, object halg, byte[] signature);
-   public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
-   public bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
  }
- public sealed class RSAEncryptionPadding : IEquatable<RSAEncryptionPadding> {
-   public RSAEncryptionPaddingMode Mode { get; }
-   public HashAlgorithmName OaepHashAlgorithm { get; }
-   public static RSAEncryptionPadding OaepSHA1 { get; }
-   public static RSAEncryptionPadding OaepSHA256 { get; }
-   public static RSAEncryptionPadding OaepSHA384 { get; }
-   public static RSAEncryptionPadding OaepSHA512 { get; }
-   public static RSAEncryptionPadding Pkcs1 { get; }
-   public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
-   public override bool Equals(object obj);
-   public bool Equals(RSAEncryptionPadding other);
-   public override int GetHashCode();
-   public static bool operator ==(RSAEncryptionPadding left, RSAEncryptionPadding right);
-   public static bool operator !=(RSAEncryptionPadding left, RSAEncryptionPadding right);
-   public override string ToString();
  }
- public enum RSAEncryptionPaddingMode {
-   Oaep = 1,
-   Pkcs1 = 0,
  }
- public class RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
-   public RSAOAEPKeyExchangeDeformatter();
-   public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
-   public override string Parameters { get; set; }
-   public override byte[] DecryptKeyExchange(byte[] rgbData);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- public class RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
-   public RSAOAEPKeyExchangeFormatter();
-   public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
-   public byte[] Parameter { get; set; }
-   public override string Parameters { get; }
-   public RandomNumberGenerator Rng { get; set; }
-   public override byte[] CreateKeyExchange(byte[] rgbData);
-   public override byte[] CreateKeyExchange(byte[] rgbData, Type symAlgType);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct RSAParameters {
-   public byte[] D;
-   public byte[] DP;
-   public byte[] DQ;
-   public byte[] Exponent;
-   public byte[] InverseQ;
-   public byte[] Modulus;
-   public byte[] P;
-   public byte[] Q;
  }
- public class RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
-   public RSAPKCS1KeyExchangeDeformatter();
-   public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
-   public override string Parameters { get; set; }
-   public RandomNumberGenerator RNG { get; set; }
-   public override byte[] DecryptKeyExchange(byte[] rgbIn);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- public class RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
-   public RSAPKCS1KeyExchangeFormatter();
-   public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
-   public override string Parameters { get; }
-   public RandomNumberGenerator Rng { get; set; }
-   public override byte[] CreateKeyExchange(byte[] rgbData);
-   public override byte[] CreateKeyExchange(byte[] rgbData, Type symAlgType);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- public class RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
-   public RSAPKCS1SignatureDeformatter();
-   public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
-   public override void SetHashAlgorithm(string strName);
-   public override void SetKey(AsymmetricAlgorithm key);
-   public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
  }
- public class RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
-   public RSAPKCS1SignatureFormatter();
-   public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
-   public override byte[] CreateSignature(byte[] rgbHash);
-   public override void SetHashAlgorithm(string strName);
-   public override void SetKey(AsymmetricAlgorithm key);
  }
- public sealed class RSASignaturePadding : IEquatable<RSASignaturePadding> {
-   public RSASignaturePaddingMode Mode { get; }
-   public static RSASignaturePadding Pkcs1 { get; }
-   public static RSASignaturePadding Pss { get; }
-   public override bool Equals(object obj);
-   public bool Equals(RSASignaturePadding other);
-   public override int GetHashCode();
-   public static bool operator ==(RSASignaturePadding left, RSASignaturePadding right);
-   public static bool operator !=(RSASignaturePadding left, RSASignaturePadding right);
-   public override string ToString();
  }
- public enum RSASignaturePaddingMode {
-   Pkcs1 = 0,
-   Pss = 1,
  }
- public abstract class SHA1 : HashAlgorithm {
-   protected SHA1();
-   public static new SHA1 Create();
-   public static new SHA1 Create(string hashName);
  }
- public sealed class SHA1CryptoServiceProvider : SHA1 {
-   public SHA1CryptoServiceProvider();
-   protected override void Dispose(bool disposing);
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public class SHA1Managed : SHA1 {
-   public SHA1Managed();
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public abstract class SHA256 : HashAlgorithm {
-   protected SHA256();
-   public static new SHA256 Create();
-   public static new SHA256 Create(string hashName);
  }
- public class SHA256Managed : SHA256 {
-   public SHA256Managed();
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public abstract class SHA384 : HashAlgorithm {
-   protected SHA384();
-   public static new SHA384 Create();
-   public static new SHA384 Create(string hashName);
  }
- public class SHA384Managed : SHA384 {
-   public SHA384Managed();
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public abstract class SHA512 : HashAlgorithm {
-   protected SHA512();
-   public static new SHA512 Create();
-   public static new SHA512 Create(string hashName);
  }
- public class SHA512Managed : SHA512 {
-   public SHA512Managed();
-   protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
-   protected override byte[] HashFinal();
-   public override void Initialize();
  }
- public class SignatureDescription {
-   public SignatureDescription();
-   public SignatureDescription(SecurityElement el);
-   public string DeformatterAlgorithm { get; set; }
-   public string DigestAlgorithm { get; set; }
-   public string FormatterAlgorithm { get; set; }
-   public string KeyAlgorithm { get; set; }
-   public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
-   public virtual HashAlgorithm CreateDigest();
-   public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
  }
- public abstract class SymmetricAlgorithm : IDisposable {
-   protected byte[] IVValue;
-   protected byte[] KeyValue;
-   protected int BlockSizeValue;
-   protected int FeedbackSizeValue;
-   protected int KeySizeValue;
-   protected CipherMode ModeValue;
-   protected KeySizes[] LegalBlockSizesValue;
-   protected KeySizes[] LegalKeySizesValue;
-   protected PaddingMode PaddingValue;
-   protected SymmetricAlgorithm();
-   public virtual int BlockSize { get; set; }
-   public virtual int FeedbackSize { get; set; }
-   public virtual byte[] IV { get; set; }
-   public virtual byte[] Key { get; set; }
-   public virtual int KeySize { get; set; }
-   public virtual KeySizes[] LegalBlockSizes { get; }
-   public virtual KeySizes[] LegalKeySizes { get; }
-   public virtual CipherMode Mode { get; set; }
-   public virtual PaddingMode Padding { get; set; }
-   public void Clear();
-   public static SymmetricAlgorithm Create();
-   public static SymmetricAlgorithm Create(string algName);
-   public virtual ICryptoTransform CreateDecryptor();
-   public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
-   public virtual ICryptoTransform CreateEncryptor();
-   public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public abstract void GenerateIV();
-   public abstract void GenerateKey();
-   public bool ValidKeySize(int bitLength);
  }
- public class ToBase64Transform : ICryptoTransform, IDisposable {
-   public ToBase64Transform();
-   public virtual bool CanReuseTransform { get; }
-   public bool CanTransformMultipleBlocks { get; }
-   public int InputBlockSize { get; }
-   public int OutputBlockSize { get; }
-   public void Clear();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~ToBase64Transform();
-   public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
-   public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
  }
- public abstract class TripleDES : SymmetricAlgorithm {
-   protected TripleDES();
-   public override byte[] Key { get; set; }
-   public static new TripleDES Create();
-   public static new TripleDES Create(string str);
-   public static bool IsWeakKey(byte[] rgbKey);
  }
- public sealed class TripleDESCryptoServiceProvider : TripleDES {
-   public TripleDESCryptoServiceProvider();
-   public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
-   public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
-   public override void GenerateIV();
-   public override void GenerateKey();
  }
 }
-namespace System.Security.Cryptography.X509Certificates {
- public class X509Certificate : IDeserializationCallback, IDisposable, ISerializable {
-   public X509Certificate();
-   public X509Certificate(byte[] data);
-   public X509Certificate(byte[] rawData, SecureString password);
-   public X509Certificate(byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
-   public X509Certificate(byte[] rawData, string password);
-   public X509Certificate(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
-   public X509Certificate(IntPtr handle);
-   public X509Certificate(SerializationInfo info, StreamingContext context);
-   public X509Certificate(X509Certificate cert);
-   public X509Certificate(string fileName);
-   public X509Certificate(string fileName, SecureString password);
-   public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
-   public X509Certificate(string fileName, string password);
-   public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
-   public IntPtr Handle { get; }
-   public string Issuer { get; }
-   public string Subject { get; }
-   public static X509Certificate CreateFromCertFile(string filename);
-   public static X509Certificate CreateFromSignedFile(string filename);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public override bool Equals(object obj);
-   public virtual bool Equals(X509Certificate other);
-   public virtual byte[] Export(X509ContentType contentType);
-   public virtual byte[] Export(X509ContentType contentType, SecureString password);
-   public virtual byte[] Export(X509ContentType contentType, string password);
-   protected static string FormatDate(DateTime date);
-   public virtual byte[] GetCertHash();
-   public virtual string GetCertHashString();
-   public virtual string GetEffectiveDateString();
-   public virtual string GetExpirationDateString();
-   public virtual string GetFormat();
-   public override int GetHashCode();
-   public virtual string GetIssuerName();
-   public virtual string GetKeyAlgorithm();
-   public virtual byte[] GetKeyAlgorithmParameters();
-   public virtual string GetKeyAlgorithmParametersString();
-   public virtual string GetName();
-   public virtual byte[] GetPublicKey();
-   public virtual string GetPublicKeyString();
-   public virtual byte[] GetRawCertData();
-   public virtual string GetRawCertDataString();
-   public virtual byte[] GetSerialNumber();
-   public virtual string GetSerialNumberString();
-   public virtual void Import(byte[] rawData);
-   public virtual void Import(byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
-   public virtual void Import(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
-   public virtual void Import(string fileName);
-   public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
-   public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
-   public virtual void Reset();
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
-   public virtual string ToString(bool fVerbose);
  }
- public enum X509ContentType {
-   Authenticode = 6,
-   Cert = 1,
-   Pfx = 3,
-   Pkcs12 = 3,
-   Pkcs7 = 5,
-   SerializedCert = 2,
-   SerializedStore = 4,
-   Unknown = 0,
  }
- public enum X509KeyStorageFlags {
-   DefaultKeySet = 0,
-   Exportable = 4,
-   MachineKeySet = 2,
-   PersistKeySet = 16,
-   UserKeySet = 1,
-   UserProtected = 8,
  }
 }
-namespace System.Security.Permissions {
- public abstract class CodeAccessSecurityAttribute : SecurityAttribute {
-   protected CodeAccessSecurityAttribute(SecurityAction action);
  }
- public sealed class EnvironmentPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public EnvironmentPermission(EnvironmentPermissionAccess flag, string pathList);
-   public EnvironmentPermission(PermissionState state);
-   public void AddPathList(EnvironmentPermissionAccess flag, string pathList);
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public string GetPathList(EnvironmentPermissionAccess flag);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public void SetPathList(EnvironmentPermissionAccess flag, string pathList);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission other);
  }
- public enum EnvironmentPermissionAccess {
-   AllAccess = 3,
-   NoAccess = 0,
-   Read = 1,
-   Write = 2,
  }
- public sealed class EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
-   public EnvironmentPermissionAttribute(SecurityAction action);
-   public string All { get; set; }
-   public string Read { get; set; }
-   public string Write { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class FileDialogPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public FileDialogPermission(FileDialogPermissionAccess access);
-   public FileDialogPermission(PermissionState state);
-   public FileDialogPermissionAccess Access { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public enum FileDialogPermissionAccess {
-   None = 0,
-   Open = 1,
-   OpenSave = 3,
-   Save = 2,
  }
- public sealed class FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
-   public FileDialogPermissionAttribute(SecurityAction action);
-   public bool Open { get; set; }
-   public bool Save { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class FileIOPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, string path);
-   public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, string[] pathList);
-   public FileIOPermission(FileIOPermissionAccess access, string path);
-   public FileIOPermission(FileIOPermissionAccess access, string[] pathList);
-   public FileIOPermission(PermissionState state);
-   public FileIOPermissionAccess AllFiles { get; set; }
-   public FileIOPermissionAccess AllLocalFiles { get; set; }
-   public void AddPathList(FileIOPermissionAccess access, string path);
-   public void AddPathList(FileIOPermissionAccess access, string[] pathList);
-   public override IPermission Copy();
-   public override bool Equals(object obj);
-   public override void FromXml(SecurityElement esd);
-   public override int GetHashCode();
-   public string[] GetPathList(FileIOPermissionAccess access);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public void SetPathList(FileIOPermissionAccess access, string path);
-   public void SetPathList(FileIOPermissionAccess access, string[] pathList);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission other);
  }
- public enum FileIOPermissionAccess {
-   AllAccess = 15,
-   Append = 4,
-   NoAccess = 0,
-   PathDiscovery = 8,
-   Read = 1,
-   Write = 2,
  }
- public sealed class FileIOPermissionAttribute : CodeAccessSecurityAttribute {
-   public FileIOPermissionAttribute(SecurityAction action);
-   public string All { get; set; }
-   public FileIOPermissionAccess AllFiles { get; set; }
-   public FileIOPermissionAccess AllLocalFiles { get; set; }
-   public string Append { get; set; }
-   public string ChangeAccessControl { get; set; }
-   public string PathDiscovery { get; set; }
-   public string Read { get; set; }
-   public string ViewAccessControl { get; set; }
-   public string ViewAndModify { get; set; }
-   public string Write { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class GacIdentityPermission : CodeAccessPermission {
-   public GacIdentityPermission();
-   public GacIdentityPermission(PermissionState state);
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement securityElement);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public GacIdentityPermissionAttribute(SecurityAction action);
-   public override IPermission CreatePermission();
  }
- public sealed class HostProtectionAttribute : CodeAccessSecurityAttribute {
-   public HostProtectionAttribute();
-   public HostProtectionAttribute(SecurityAction action);
-   public bool ExternalProcessMgmt { get; set; }
-   public bool ExternalThreading { get; set; }
-   public bool MayLeakOnAbort { get; set; }
-   public HostProtectionResource Resources { get; set; }
-   public bool SecurityInfrastructure { get; set; }
-   public bool SelfAffectingProcessMgmt { get; set; }
-   public bool SelfAffectingThreading { get; set; }
-   public bool SharedState { get; set; }
-   public bool Synchronization { get; set; }
-   public bool UI { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum HostProtectionResource {
-   All = 511,
-   ExternalProcessMgmt = 4,
-   ExternalThreading = 16,
-   MayLeakOnAbort = 256,
-   None = 0,
-   SecurityInfrastructure = 64,
-   SelfAffectingProcessMgmt = 8,
-   SelfAffectingThreading = 32,
-   SharedState = 2,
-   Synchronization = 1,
-   UI = 128,
  }
- public enum IsolatedStorageContainment {
-   AdministerIsolatedStorageByUser = 112,
-   ApplicationIsolationByMachine = 69,
-   ApplicationIsolationByRoamingUser = 101,
-   ApplicationIsolationByUser = 21,
-   AssemblyIsolationByMachine = 64,
-   AssemblyIsolationByRoamingUser = 96,
-   AssemblyIsolationByUser = 32,
-   DomainIsolationByMachine = 48,
-   DomainIsolationByRoamingUser = 80,
-   DomainIsolationByUser = 16,
-   None = 0,
-   UnrestrictedIsolatedStorage = 240,
  }
- public sealed class IsolatedStorageFilePermission : IsolatedStoragePermission {
-   public IsolatedStorageFilePermission(PermissionState state);
-   public override IPermission Copy();
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
-   public IsolatedStorageFilePermissionAttribute(SecurityAction action);
-   public override IPermission CreatePermission();
  }
- public abstract class IsolatedStoragePermission : CodeAccessPermission, IUnrestrictedPermission {
-   protected IsolatedStoragePermission(PermissionState state);
-   public IsolatedStorageContainment UsageAllowed { get; set; }
-   public long UserQuota { get; set; }
-   public override void FromXml(SecurityElement esd);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
  }
- public abstract class IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
-   protected IsolatedStoragePermissionAttribute(SecurityAction action);
-   public IsolatedStorageContainment UsageAllowed { get; set; }
-   public long UserQuota { get; set; }
  }
- public interface IUnrestrictedPermission {
-   bool IsUnrestricted();
  }
- public sealed class KeyContainerPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public KeyContainerPermission(KeyContainerPermissionFlags flags);
-   public KeyContainerPermission(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList);
-   public KeyContainerPermission(PermissionState state);
-   public KeyContainerPermissionAccessEntryCollection AccessEntries { get; }
-   public KeyContainerPermissionFlags Flags { get; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement securityElement);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class KeyContainerPermissionAccessEntry {
-   public KeyContainerPermissionAccessEntry(CspParameters parameters, KeyContainerPermissionFlags flags);
-   public KeyContainerPermissionAccessEntry(string keyContainerName, KeyContainerPermissionFlags flags);
-   public KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags);
-   public KeyContainerPermissionFlags Flags { get; set; }
-   public string KeyContainerName { get; set; }
-   public int KeySpec { get; set; }
-   public string KeyStore { get; set; }
-   public string ProviderName { get; set; }
-   public int ProviderType { get; set; }
-   public override bool Equals(object o);
-   public override int GetHashCode();
  }
- public sealed class KeyContainerPermissionAccessEntryCollection : ICollection, IEnumerable {
-   public int Count { get; }
-   public bool IsSynchronized { get; }
-   public object SyncRoot { get; }
-   public KeyContainerPermissionAccessEntry this[int index] { get; }
-   public int Add(KeyContainerPermissionAccessEntry accessEntry);
-   public void Clear();
-   public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index);
-   public KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
-   public int IndexOf(KeyContainerPermissionAccessEntry accessEntry);
-   public void Remove(KeyContainerPermissionAccessEntry accessEntry);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public sealed class KeyContainerPermissionAccessEntryEnumerator : IEnumerator {
-   public KeyContainerPermissionAccessEntry Current { get; }
-   object System.Collections.IEnumerator.Current { get; }
-   public bool MoveNext();
-   public void Reset();
  }
- public sealed class KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
-   public KeyContainerPermissionAttribute(SecurityAction action);
-   public KeyContainerPermissionFlags Flags { get; set; }
-   public string KeyContainerName { get; set; }
-   public int KeySpec { get; set; }
-   public string KeyStore { get; set; }
-   public string ProviderName { get; set; }
-   public int ProviderType { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum KeyContainerPermissionFlags {
-   AllFlags = 13111,
-   ChangeAcl = 8192,
-   Create = 1,
-   Decrypt = 512,
-   Delete = 4,
-   Export = 32,
-   Import = 16,
-   NoFlags = 0,
-   Open = 2,
-   Sign = 256,
-   ViewAcl = 4096,
  }
- public sealed class PermissionSetAttribute : CodeAccessSecurityAttribute {
-   public PermissionSetAttribute(SecurityAction action);
-   public string File { get; set; }
-   public string Hex { get; set; }
-   public string Name { get; set; }
-   public bool UnicodeEncoded { get; set; }
-   public string XML { get; set; }
-   public override IPermission CreatePermission();
-   public PermissionSet CreatePermissionSet();
  }
- public enum PermissionState {
-   None = 0,
-   Unrestricted = 1,
  }
- public sealed class PrincipalPermission : IPermission, ISecurityEncodable, IUnrestrictedPermission {
-   public PrincipalPermission(PermissionState state);
-   public PrincipalPermission(string name, string role);
-   public PrincipalPermission(string name, string role, bool isAuthenticated);
-   public IPermission Copy();
-   public void Demand();
-   public override bool Equals(object obj);
-   public void FromXml(SecurityElement elem);
-   public override int GetHashCode();
-   public IPermission Intersect(IPermission target);
-   public bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public IPermission Union(IPermission other);
  }
- public sealed class PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
-   public PrincipalPermissionAttribute(SecurityAction action);
-   public bool Authenticated { get; set; }
-   public string Name { get; set; }
-   public string Role { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class PublisherIdentityPermission : CodeAccessPermission {
-   public PublisherIdentityPermission(X509Certificate certificate);
-   public PublisherIdentityPermission(PermissionState state);
-   public X509Certificate Certificate { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public PublisherIdentityPermissionAttribute(SecurityAction action);
-   public string CertFile { get; set; }
-   public string SignedFile { get; set; }
-   public string X509Certificate { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class ReflectionPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public ReflectionPermission(PermissionState state);
-   public ReflectionPermission(ReflectionPermissionFlag flag);
-   public ReflectionPermissionFlag Flags { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission other);
  }
- public sealed class ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
-   public ReflectionPermissionAttribute(SecurityAction action);
-   public ReflectionPermissionFlag Flags { get; set; }
-   public bool MemberAccess { get; set; }
-   public bool ReflectionEmit { get; set; }
-   public bool RestrictedMemberAccess { get; set; }
-   public bool TypeInformation { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum ReflectionPermissionFlag {
-   AllFlags = 7,
-   MemberAccess = 2,
-   NoFlags = 0,
-   ReflectionEmit = 4,
-   RestrictedMemberAccess = 8,
-   TypeInformation = 1,
  }
- public sealed class RegistryPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public RegistryPermission(PermissionState state);
-   public RegistryPermission(RegistryPermissionAccess access, AccessControlActions control, string pathList);
-   public RegistryPermission(RegistryPermissionAccess access, string pathList);
-   public void AddPathList(RegistryPermissionAccess access, AccessControlActions control, string pathList);
-   public void AddPathList(RegistryPermissionAccess access, string pathList);
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public string GetPathList(RegistryPermissionAccess access);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public void SetPathList(RegistryPermissionAccess access, string pathList);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission other);
  }
- public enum RegistryPermissionAccess {
-   AllAccess = 7,
-   Create = 4,
-   NoAccess = 0,
-   Read = 1,
-   Write = 2,
  }
- public sealed class RegistryPermissionAttribute : CodeAccessSecurityAttribute {
-   public RegistryPermissionAttribute(SecurityAction action);
-   public string All { get; set; }
-   public string ChangeAccessControl { get; set; }
-   public string Create { get; set; }
-   public string Read { get; set; }
-   public string ViewAccessControl { get; set; }
-   public string ViewAndModify { get; set; }
-   public string Write { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum SecurityAction {
-   Assert = 3,
-   Demand = 2,
-   Deny = 4,
-   InheritanceDemand = 7,
-   LinkDemand = 6,
-   PermitOnly = 5,
-   RequestMinimum = 8,
-   RequestOptional = 9,
-   RequestRefuse = 10,
  }
- public abstract class SecurityAttribute : Attribute {
-   protected SecurityAttribute(SecurityAction action);
-   public SecurityAction Action { get; set; }
-   public bool Unrestricted { get; set; }
-   public abstract IPermission CreatePermission();
  }
- public sealed class SecurityPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public SecurityPermission(PermissionState state);
-   public SecurityPermission(SecurityPermissionFlag flag);
-   public SecurityPermissionFlag Flags { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class SecurityPermissionAttribute : CodeAccessSecurityAttribute {
-   public SecurityPermissionAttribute(SecurityAction action);
-   public bool Assertion { get; set; }
-   public bool BindingRedirects { get; set; }
-   public bool ControlAppDomain { get; set; }
-   public bool ControlDomainPolicy { get; set; }
-   public bool ControlEvidence { get; set; }
-   public bool ControlPolicy { get; set; }
-   public bool ControlPrincipal { get; set; }
-   public bool ControlThread { get; set; }
-   public bool Execution { get; set; }
-   public SecurityPermissionFlag Flags { get; set; }
-   public bool Infrastructure { get; set; }
-   public bool RemotingConfiguration { get; set; }
-   public bool SerializationFormatter { get; set; }
-   public bool SkipVerification { get; set; }
-   public bool UnmanagedCode { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum SecurityPermissionFlag {
-   AllFlags = 16383,
-   Assertion = 1,
-   BindingRedirects = 8192,
-   ControlAppDomain = 1024,
-   ControlDomainPolicy = 256,
-   ControlEvidence = 32,
-   ControlPolicy = 64,
-   ControlPrincipal = 512,
-   ControlThread = 16,
-   Execution = 8,
-   Infrastructure = 4096,
-   NoFlags = 0,
-   RemotingConfiguration = 2048,
-   SerializationFormatter = 128,
-   SkipVerification = 4,
-   UnmanagedCode = 2,
  }
- public sealed class SiteIdentityPermission : CodeAccessPermission {
-   public SiteIdentityPermission(PermissionState state);
-   public SiteIdentityPermission(string site);
-   public string Site { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public SiteIdentityPermissionAttribute(SecurityAction action);
-   public string Site { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class StrongNameIdentityPermission : CodeAccessPermission {
-   public StrongNameIdentityPermission(PermissionState state);
-   public StrongNameIdentityPermission(StrongNamePublicKeyBlob blob, string name, Version version);
-   public string Name { get; set; }
-   public StrongNamePublicKeyBlob PublicKey { get; set; }
-   public Version Version { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement e);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public StrongNameIdentityPermissionAttribute(SecurityAction action);
-   public string Name { get; set; }
-   public string PublicKey { get; set; }
-   public string Version { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class StrongNamePublicKeyBlob {
-   public StrongNamePublicKeyBlob(byte[] publicKey);
-   public override bool Equals(object obj);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class UIPermission : CodeAccessPermission, IUnrestrictedPermission {
-   public UIPermission(PermissionState state);
-   public UIPermission(UIPermissionClipboard clipboardFlag);
-   public UIPermission(UIPermissionWindow windowFlag);
-   public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag);
-   public UIPermissionClipboard Clipboard { get; set; }
-   public UIPermissionWindow Window { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public bool IsUnrestricted();
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class UIPermissionAttribute : CodeAccessSecurityAttribute {
-   public UIPermissionAttribute(SecurityAction action);
-   public UIPermissionClipboard Clipboard { get; set; }
-   public UIPermissionWindow Window { get; set; }
-   public override IPermission CreatePermission();
  }
- public enum UIPermissionClipboard {
-   AllClipboard = 2,
-   NoClipboard = 0,
-   OwnClipboard = 1,
  }
- public enum UIPermissionWindow {
-   AllWindows = 3,
-   NoWindows = 0,
-   SafeSubWindows = 1,
-   SafeTopLevelWindows = 2,
  }
- public sealed class UrlIdentityPermission : CodeAccessPermission {
-   public UrlIdentityPermission(PermissionState state);
-   public UrlIdentityPermission(string site);
-   public string Url { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public UrlIdentityPermissionAttribute(SecurityAction action);
-   public string Url { get; set; }
-   public override IPermission CreatePermission();
  }
- public sealed class ZoneIdentityPermission : CodeAccessPermission {
-   public ZoneIdentityPermission(PermissionState state);
-   public ZoneIdentityPermission(SecurityZone zone);
-   public SecurityZone SecurityZone { get; set; }
-   public override IPermission Copy();
-   public override void FromXml(SecurityElement esd);
-   public override IPermission Intersect(IPermission target);
-   public override bool IsSubsetOf(IPermission target);
-   public override SecurityElement ToXml();
-   public override IPermission Union(IPermission target);
  }
- public sealed class ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
-   public ZoneIdentityPermissionAttribute(SecurityAction action);
-   public SecurityZone Zone { get; set; }
-   public override IPermission CreatePermission();
  }
 }
-namespace System.Security.Policy {
- public sealed class AllMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public AllMembershipCondition();
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class ApplicationDirectory : EvidenceBase {
-   public ApplicationDirectory(string name);
-   public string Directory { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class ApplicationDirectoryMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public ApplicationDirectoryMembershipCondition();
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class ApplicationSecurityInfo {
-   public ApplicationSecurityInfo(ActivationContext activationContext);
-   public Evidence ApplicationEvidence { get; set; }
-   public ApplicationId ApplicationId { get; set; }
-   public PermissionSet DefaultRequestSet { get; set; }
-   public ApplicationId DeploymentId { get; set; }
  }
- public static class ApplicationSecurityManager {
-   public static IApplicationTrustManager ApplicationTrustManager { get; }
-   public static ApplicationTrustCollection UserApplicationTrusts { get; }
-   public static bool DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
  }
- public sealed class ApplicationTrust : EvidenceBase, ISecurityEncodable {
-   public ApplicationTrust();
-   public ApplicationTrust(ApplicationIdentity applicationIdentity);
-   public ApplicationTrust(PermissionSet defaultGrantSet, IEnumerable<StrongName> fullTrustAssemblies);
-   public ApplicationIdentity ApplicationIdentity { get; set; }
-   public PolicyStatement DefaultGrantSet { get; set; }
-   public object ExtraInfo { get; set; }
-   public IList<StrongName> FullTrustAssemblies { get; }
-   public bool IsApplicationTrustedToRun { get; set; }
-   public bool Persist { get; set; }
-   public override EvidenceBase Clone();
-   public void FromXml(SecurityElement element);
-   public SecurityElement ToXml();
  }
- public sealed class ApplicationTrustCollection : ICollection, IEnumerable {
-   public int Count { get; }
-   public bool IsSynchronized { get; }
-   public object SyncRoot { get; }
-   public ApplicationTrust this[int index] { get; }
-   public ApplicationTrust this[string appFullName] { get; }
-   public int Add(ApplicationTrust trust);
-   public void AddRange(ApplicationTrust[] trusts);
-   public void AddRange(ApplicationTrustCollection trusts);
-   public void Clear();
-   public void CopyTo(ApplicationTrust[] array, int index);
-   public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
-   public ApplicationTrustEnumerator GetEnumerator();
-   public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
-   public void Remove(ApplicationTrust trust);
-   public void RemoveRange(ApplicationTrust[] trusts);
-   public void RemoveRange(ApplicationTrustCollection trusts);
-   void System.Collections.ICollection.CopyTo(Array array, int index);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
  }
- public sealed class ApplicationTrustEnumerator : IEnumerator {
-   public ApplicationTrust Current { get; }
-   object System.Collections.IEnumerator.Current { get; }
-   public bool MoveNext();
-   public void Reset();
  }
- public enum ApplicationVersionMatch {
-   MatchAllVersions = 1,
-   MatchExactVersion = 0,
  }
- public class CodeConnectAccess {
-   public static readonly int DefaultPort;
-   public static readonly int OriginPort;
-   public static readonly string AnyScheme;
-   public static readonly string OriginScheme;
-   public CodeConnectAccess(string allowScheme, int allowPort);
-   public int Port { get; }
-   public string Scheme { get; }
-   public static CodeConnectAccess CreateAnySchemeAccess(int allowPort);
-   public static CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
-   public override bool Equals(object o);
-   public override int GetHashCode();
  }
- public abstract class CodeGroup {
-   protected CodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
-   public virtual string AttributeString { get; }
-   public IList Children { get; set; }
-   public string Description { get; set; }
-   public IMembershipCondition MembershipCondition { get; set; }
-   public abstract string MergeLogic { get; }
-   public string Name { get; set; }
-   public virtual string PermissionSetName { get; }
-   public PolicyStatement PolicyStatement { get; set; }
-   public void AddChild(CodeGroup group);
-   public abstract CodeGroup Copy();
-   protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
-   public override bool Equals(object o);
-   public bool Equals(CodeGroup cg, bool compareChildren);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
-   public void RemoveChild(CodeGroup group);
-   public abstract PolicyStatement Resolve(Evidence evidence);
-   public abstract CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class Evidence : ICollection, IEnumerable {
-   public Evidence();
-   public Evidence(object[] hostEvidence, object[] assemblyEvidence);
-   public Evidence(Evidence evidence);
-   public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
-   public int Count { get; }
-   public bool IsReadOnly { get; }
-   public bool IsSynchronized { get; }
-   public bool Locked { get; set; }
-   public object SyncRoot { get; }
-   public void AddAssembly(object id);
-   public void AddAssemblyEvidence<T>(T evidence) where T : EvidenceBase;
-   public void AddHost(object id);
-   public void AddHostEvidence<T>(T evidence) where T : EvidenceBase;
-   public void Clear();
-   public Evidence Clone();
-   public void CopyTo(Array array, int index);
-   public IEnumerator GetAssemblyEnumerator();
-   public T GetAssemblyEvidence<T>() where T : EvidenceBase;
-   public IEnumerator GetEnumerator();
-   public IEnumerator GetHostEnumerator();
-   public T GetHostEvidence<T>() where T : EvidenceBase;
-   public void Merge(Evidence evidence);
-   public void RemoveType(Type t);
  }
- public abstract class EvidenceBase {
-   protected EvidenceBase();
-   public virtual EvidenceBase Clone();
  }
- public sealed class FileCodeGroup : CodeGroup {
-   public FileCodeGroup(IMembershipCondition membershipCondition, FileIOPermissionAccess access);
-   public override string AttributeString { get; }
-   public override string MergeLogic { get; }
-   public override string PermissionSetName { get; }
-   public override CodeGroup Copy();
-   protected override void CreateXml(SecurityElement element, PolicyLevel level);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   protected override void ParseXml(SecurityElement e, PolicyLevel level);
-   public override PolicyStatement Resolve(Evidence evidence);
-   public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
  }
- public sealed class FirstMatchCodeGroup : CodeGroup {
-   public FirstMatchCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
-   public override string MergeLogic { get; }
-   public override CodeGroup Copy();
-   public override PolicyStatement Resolve(Evidence evidence);
-   public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
  }
- public sealed class GacInstalled : EvidenceBase, IIdentityPermissionFactory {
-   public GacInstalled();
-   public override EvidenceBase Clone();
-   public object Copy();
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class GacMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public GacMembershipCondition();
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class Hash : EvidenceBase, ISerializable {
-   public Hash(Assembly assembly);
-   public byte[] MD5 { get; }
-   public byte[] SHA1 { get; }
-   public byte[] SHA256 { get; }
-   public override EvidenceBase Clone();
-   public static Hash CreateMD5(byte[] md5);
-   public static Hash CreateSHA1(byte[] sha1);
-   public static Hash CreateSHA256(byte[] sha256);
-   public byte[] GenerateHash(HashAlgorithm hashAlg);
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
  }
- public sealed class HashMembershipCondition : IDeserializationCallback, IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable, ISerializable {
-   public HashMembershipCondition(HashAlgorithm hashAlg, byte[] value);
-   public HashAlgorithm HashAlgorithm { get; set; }
-   public byte[] HashValue { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public interface IApplicationTrustManager : ISecurityEncodable {
-   ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
  }
- public interface IIdentityPermissionFactory {
-   IPermission CreateIdentityPermission(Evidence evidence);
  }
- public interface IMembershipCondition : ISecurityEncodable, ISecurityPolicyEncodable {
-   bool Check(Evidence evidence);
-   IMembershipCondition Copy();
-   bool Equals(object obj);
-   string ToString();
  }
- public sealed class NetCodeGroup : CodeGroup {
-   public static readonly string AbsentOriginScheme;
-   public static readonly string AnyOtherOriginScheme;
-   public NetCodeGroup(IMembershipCondition membershipCondition);
-   public override string AttributeString { get; }
-   public override string MergeLogic { get; }
-   public override string PermissionSetName { get; }
-   public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess);
-   public override CodeGroup Copy();
-   protected override void CreateXml(SecurityElement element, PolicyLevel level);
-   public override bool Equals(object o);
-   public DictionaryEntry[] GetConnectAccessRules();
-   public override int GetHashCode();
-   protected override void ParseXml(SecurityElement e, PolicyLevel level);
-   public void ResetConnectAccess();
-   public override PolicyStatement Resolve(Evidence evidence);
-   public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
  }
- public sealed class PermissionRequestEvidence : EvidenceBase {
-   public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied);
-   public PermissionSet DeniedPermissions { get; }
-   public PermissionSet OptionalPermissions { get; }
-   public PermissionSet RequestedPermissions { get; }
-   public override EvidenceBase Clone();
-   public PermissionRequestEvidence Copy();
-   public override string ToString();
  }
- public class PolicyException : SystemException {
-   public PolicyException();
-   protected PolicyException(SerializationInfo info, StreamingContext context);
-   public PolicyException(string message);
-   public PolicyException(string message, Exception exception);
  }
- public sealed class PolicyLevel {
-   public IList FullTrustAssemblies { get; }
-   public string Label { get; }
-   public IList NamedPermissionSets { get; }
-   public CodeGroup RootCodeGroup { get; set; }
-   public string StoreLocation { get; }
-   public PolicyLevelType Type { get; }
-   public void AddFullTrustAssembly(StrongName sn);
-   public void AddFullTrustAssembly(StrongNameMembershipCondition snMC);
-   public void AddNamedPermissionSet(NamedPermissionSet permSet);
-   public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet);
-   public static PolicyLevel CreateAppDomainLevel();
-   public void FromXml(SecurityElement e);
-   public NamedPermissionSet GetNamedPermissionSet(string name);
-   public void Recover();
-   public void RemoveFullTrustAssembly(StrongName sn);
-   public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC);
-   public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet);
-   public NamedPermissionSet RemoveNamedPermissionSet(string name);
-   public void Reset();
-   public PolicyStatement Resolve(Evidence evidence);
-   public CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
-   public SecurityElement ToXml();
  }
- public sealed class PolicyStatement : ISecurityEncodable, ISecurityPolicyEncodable {
-   public PolicyStatement(PermissionSet permSet);
-   public PolicyStatement(PermissionSet permSet, PolicyStatementAttribute attributes);
-   public PolicyStatementAttribute Attributes { get; set; }
-   public string AttributeString { get; }
-   public PermissionSet PermissionSet { get; set; }
-   public PolicyStatement Copy();
-   public override bool Equals(object obj);
-   public void FromXml(SecurityElement et);
-   public void FromXml(SecurityElement et, PolicyLevel level);
-   public override int GetHashCode();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public enum PolicyStatementAttribute {
-   All = 3,
-   Exclusive = 1,
-   LevelFinal = 2,
-   Nothing = 0,
  }
- public sealed class Publisher : EvidenceBase, IIdentityPermissionFactory {
-   public Publisher(X509Certificate cert);
-   public X509Certificate Certificate { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class PublisherMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public PublisherMembershipCondition(X509Certificate certificate);
-   public X509Certificate Certificate { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class Site : EvidenceBase, IIdentityPermissionFactory {
-   public Site(string name);
-   public string Name { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public static Site CreateFromUrl(string url);
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class SiteMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public SiteMembershipCondition(string site);
-   public string Site { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class StrongName : EvidenceBase, IIdentityPermissionFactory {
-   public StrongName(StrongNamePublicKeyBlob blob, string name, Version version);
-   public string Name { get; }
-   public StrongNamePublicKeyBlob PublicKey { get; }
-   public Version Version { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class StrongNameMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public StrongNameMembershipCondition(StrongNamePublicKeyBlob blob, string name, Version version);
-   public string Name { get; set; }
-   public StrongNamePublicKeyBlob PublicKey { get; set; }
-   public Version Version { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public class TrustManagerContext {
-   public TrustManagerContext();
-   public TrustManagerContext(TrustManagerUIContext uiContext);
-   public virtual bool IgnorePersistedDecision { get; set; }
-   public virtual bool KeepAlive { get; set; }
-   public virtual bool NoPrompt { get; set; }
-   public virtual bool Persist { get; set; }
-   public virtual ApplicationIdentity PreviousApplicationIdentity { get; set; }
-   public virtual TrustManagerUIContext UIContext { get; set; }
  }
- public enum TrustManagerUIContext {
-   Install = 0,
-   Run = 2,
-   Upgrade = 1,
  }
- public sealed class UnionCodeGroup : CodeGroup {
-   public UnionCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
-   public override string MergeLogic { get; }
-   public override CodeGroup Copy();
-   public override PolicyStatement Resolve(Evidence evidence);
-   public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
  }
- public sealed class Url : EvidenceBase, IIdentityPermissionFactory {
-   public Url(string name);
-   public string Value { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class UrlMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public UrlMembershipCondition(string url);
-   public string Url { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
- public sealed class Zone : EvidenceBase, IIdentityPermissionFactory {
-   public Zone(SecurityZone zone);
-   public SecurityZone SecurityZone { get; }
-   public override EvidenceBase Clone();
-   public object Copy();
-   public static Zone CreateFromUrl(string url);
-   public IPermission CreateIdentityPermission(Evidence evidence);
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override string ToString();
  }
- public sealed class ZoneMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
-   public ZoneMembershipCondition(SecurityZone zone);
-   public SecurityZone SecurityZone { get; set; }
-   public bool Check(Evidence evidence);
-   public IMembershipCondition Copy();
-   public override bool Equals(object o);
-   public void FromXml(SecurityElement e);
-   public void FromXml(SecurityElement e, PolicyLevel level);
-   public override int GetHashCode();
-   public override string ToString();
-   public SecurityElement ToXml();
-   public SecurityElement ToXml(PolicyLevel level);
  }
 }
-namespace System.Security.Principal {
- public class GenericIdentity : ClaimsIdentity {
-   protected GenericIdentity(GenericIdentity identity);
-   public GenericIdentity(string name);
-   public GenericIdentity(string name, string type);
-   public override string AuthenticationType { get; }
-   public override IEnumerable<Claim> Claims { get; }
-   public override bool IsAuthenticated { get; }
-   public override string Name { get; }
-   public override ClaimsIdentity Clone();
  }
- public class GenericPrincipal : ClaimsPrincipal {
-   public GenericPrincipal(IIdentity identity, string[] roles);
-   public override IIdentity Identity { get; }
-   public override bool IsInRole(string role);
  }
- public sealed class IdentityNotMappedException : SystemException {
-   public IdentityNotMappedException();
-   public IdentityNotMappedException(string message);
-   public IdentityNotMappedException(string message, Exception inner);
-   public IdentityReferenceCollection UnmappedIdentities { get; }
-   public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
  }
- public abstract class IdentityReference {
-   public abstract string Value { get; }
-   public abstract override bool Equals(object o);
-   public abstract override int GetHashCode();
-   public abstract bool IsValidTargetType(Type targetType);
-   public static bool operator ==(IdentityReference left, IdentityReference right);
-   public static bool operator !=(IdentityReference left, IdentityReference right);
-   public abstract override string ToString();
-   public abstract IdentityReference Translate(Type targetType);
  }
- public class IdentityReferenceCollection : ICollection<IdentityReference>, IEnumerable, IEnumerable<IdentityReference> {
-   public IdentityReferenceCollection();
-   public IdentityReferenceCollection(int capacity);
-   public int Count { get; }
-   public bool IsReadOnly { get; }
-   public IdentityReference this[int index] { get; set; }
-   public void Add(IdentityReference identity);
-   public void Clear();
-   public bool Contains(IdentityReference identity);
-   public void CopyTo(IdentityReference[] array, int offset);
-   public IEnumerator<IdentityReference> GetEnumerator();
-   public bool Remove(IdentityReference identity);
-   IEnumerator System.Collections.IEnumerable.GetEnumerator();
-   public IdentityReferenceCollection Translate(Type targetType);
-   public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess);
  }
- public interface IIdentity {
-   string AuthenticationType { get; }
-   bool IsAuthenticated { get; }
-   string Name { get; }
  }
- public interface IPrincipal {
-   IIdentity Identity { get; }
-   bool IsInRole(string role);
  }
- public sealed class NTAccount : IdentityReference {
-   public NTAccount(string name);
-   public NTAccount(string domainName, string accountName);
-   public override string Value { get; }
-   public override bool Equals(object o);
-   public override int GetHashCode();
-   public override bool IsValidTargetType(Type targetType);
-   public static bool operator ==(NTAccount left, NTAccount right);
-   public static bool operator !=(NTAccount left, NTAccount right);
-   public override string ToString();
-   public override IdentityReference Translate(Type targetType);
  }
- public enum PrincipalPolicy {
-   NoPrincipal = 1,
-   UnauthenticatedPrincipal = 0,
-   WindowsPrincipal = 2,
  }
- public sealed class SecurityIdentifier : IdentityReference, IComparable<SecurityIdentifier> {
-   public static readonly int MaxBinaryLength;
-   public static readonly int MinBinaryLength;
-   public SecurityIdentifier(byte[] binaryForm, int offset);
-   public SecurityIdentifier(IntPtr binaryForm);
-   public SecurityIdentifier(WellKnownSidType sidType, SecurityIdentifier domainSid);
-   public SecurityIdentifier(string sddlForm);
-   public SecurityIdentifier AccountDomainSid { get; }
-   public int BinaryLength { get; }
-   public override string Value { get; }
-   public int CompareTo(SecurityIdentifier sid);
-   public override bool Equals(object o);
-   public bool Equals(SecurityIdentifier sid);
-   public void GetBinaryForm(byte[] binaryForm, int offset);
-   public override int GetHashCode();
-   public bool IsAccountSid();
-   public bool IsEqualDomainSid(SecurityIdentifier sid);
-   public override bool IsValidTargetType(Type targetType);
-   public bool IsWellKnown(WellKnownSidType type);
-   public static bool operator ==(SecurityIdentifier left, SecurityIdentifier right);
-   public static bool operator !=(SecurityIdentifier left, SecurityIdentifier right);
-   public override string ToString();
-   public override IdentityReference Translate(Type targetType);
  }
- public enum TokenAccessLevels {
-   AdjustDefault = 128,
-   AdjustGroups = 64,
-   AdjustPrivileges = 32,
-   AdjustSessionId = 256,
-   AllAccess = 983551,
-   AssignPrimary = 1,
-   Duplicate = 2,
-   Impersonate = 4,
-   MaximumAllowed = 33554432,
-   Query = 8,
-   QuerySource = 16,
-   Read = 131080,
-   Write = 131296,
  }
- public enum TokenImpersonationLevel {
-   Anonymous = 1,
-   Delegation = 4,
-   Identification = 2,
-   Impersonation = 3,
-   None = 0,
  }
- public enum WellKnownSidType {
-   AccountAdministratorSid = 38,
-   AccountCertAdminsSid = 46,
-   AccountComputersSid = 44,
-   AccountControllersSid = 45,
-   AccountDomainAdminsSid = 41,
-   AccountDomainGuestsSid = 43,
-   AccountDomainUsersSid = 42,
-   AccountEnterpriseAdminsSid = 48,
-   AccountGuestSid = 39,
-   AccountKrbtgtSid = 40,
-   AccountPolicyAdminsSid = 49,
-   AccountRasAndIasServersSid = 50,
-   AccountSchemaAdminsSid = 47,
-   AnonymousSid = 13,
-   AuthenticatedUserSid = 17,
-   BatchSid = 10,
-   BuiltinAccountOperatorsSid = 30,
-   BuiltinAdministratorsSid = 26,
-   BuiltinAuthorizationAccessSid = 59,
-   BuiltinBackupOperatorsSid = 33,
-   BuiltinDomainSid = 25,
-   BuiltinGuestsSid = 28,
-   BuiltinIncomingForestTrustBuildersSid = 56,
-   BuiltinNetworkConfigurationOperatorsSid = 37,
-   BuiltinPerformanceLoggingUsersSid = 58,
-   BuiltinPerformanceMonitoringUsersSid = 57,
-   BuiltinPowerUsersSid = 29,
-   BuiltinPreWindows2000CompatibleAccessSid = 35,
-   BuiltinPrintOperatorsSid = 32,
-   BuiltinRemoteDesktopUsersSid = 36,
-   BuiltinReplicatorSid = 34,
-   BuiltinSystemOperatorsSid = 31,
-   BuiltinUsersSid = 27,
-   CreatorGroupServerSid = 6,
-   CreatorGroupSid = 4,
-   CreatorOwnerServerSid = 5,
-   CreatorOwnerSid = 3,
-   DialupSid = 8,
-   DigestAuthenticationSid = 52,
-   EnterpriseControllersSid = 15,
-   InteractiveSid = 11,
-   LocalServiceSid = 23,
-   LocalSid = 2,
-   LocalSystemSid = 22,
-   LogonIdsSid = 21,
-   MaxDefined = 60,
-   NetworkServiceSid = 24,
-   NetworkSid = 9,
-   NTAuthoritySid = 7,
-   NtlmAuthenticationSid = 51,
-   NullSid = 0,
-   OtherOrganizationSid = 55,
-   ProxySid = 14,
-   RemoteLogonIdSid = 20,
-   RestrictedCodeSid = 18,
-   SChannelAuthenticationSid = 53,
-   SelfSid = 16,
-   ServiceSid = 12,
-   TerminalServerSid = 19,
-   ThisOrganizationSid = 54,
-   WinBuiltinTerminalServerLicenseServersSid = 60,
-   WorldSid = 1,
  }
- public enum WindowsAccountType {
-   Anonymous = 3,
-   Guest = 1,
-   Normal = 0,
-   System = 2,
  }
- public enum WindowsBuiltInRole {
-   AccountOperator = 548,
-   Administrator = 544,
-   BackupOperator = 551,
-   Guest = 546,
-   PowerUser = 547,
-   PrintOperator = 550,
-   Replicator = 552,
-   SystemOperator = 549,
-   User = 545,
  }
- public class WindowsIdentity : ClaimsIdentity, IDeserializationCallback, IDisposable, ISerializable {
-   public const string DefaultIssuer = "AD AUTHORITY";
-   public WindowsIdentity(IntPtr userToken);
-   public WindowsIdentity(IntPtr userToken, string type);
-   public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType);
-   public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated);
-   public WindowsIdentity(SerializationInfo info, StreamingContext context);
-   protected WindowsIdentity(WindowsIdentity identity);
-   public WindowsIdentity(string sUserPrincipalName);
-   public WindowsIdentity(string sUserPrincipalName, string type);
-   public SafeAccessTokenHandle AccessToken { get; }
-   public sealed override string AuthenticationType { get; }
-   public override IEnumerable<Claim> Claims { get; }
-   public virtual IEnumerable<Claim> DeviceClaims { get; }
-   public IdentityReferenceCollection Groups { get; }
-   public TokenImpersonationLevel ImpersonationLevel { get; }
-   public virtual bool IsAnonymous { get; }
-   public override bool IsAuthenticated { get; }
-   public virtual bool IsGuest { get; }
-   public virtual bool IsSystem { get; }
-   public override string Name { get; }
-   public SecurityIdentifier Owner { get; }
-   public virtual IntPtr Token { get; }
-   public SecurityIdentifier User { get; }
-   public virtual IEnumerable<Claim> UserClaims { get; }
-   public override ClaimsIdentity Clone();
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public static WindowsIdentity GetAnonymous();
-   public static WindowsIdentity GetCurrent();
-   public static WindowsIdentity GetCurrent(bool ifImpersonating);
-   public static WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess);
-   [MethodImpl(NoInlining)]public virtual WindowsImpersonationContext Impersonate();
-   [MethodImpl(NoInlining)]public static WindowsImpersonationContext Impersonate(IntPtr userToken);
-   [MethodImpl(NoInlining)]public static void RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Action action);
-   [MethodImpl(NoInlining)]public static T RunImpersonated<T>(SafeAccessTokenHandle safeAccessTokenHandle, Func<T> func);
-   void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
  }
- public class WindowsImpersonationContext : IDisposable {
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public void Undo();
  }
- public class WindowsPrincipal : ClaimsPrincipal {
-   public WindowsPrincipal(WindowsIdentity ntIdentity);
-   public virtual IEnumerable<Claim> DeviceClaims { get; }
-   public override IIdentity Identity { get; }
-   public virtual IEnumerable<Claim> UserClaims { get; }
-   public virtual bool IsInRole(int rid);
-   public virtual bool IsInRole(SecurityIdentifier sid);
-   public virtual bool IsInRole(WindowsBuiltInRole role);
-   public override bool IsInRole(string role);
  }
 }
 namespace System.Text {
- public class ASCIIEncoding : Encoding {
-   public ASCIIEncoding();
-   public override bool IsSingleByte { get; }
-   public unsafe override int GetByteCount(char* chars, int count);
-   public override int GetByteCount(char[] chars, int index, int count);
-   public override int GetByteCount(string chars);
-   public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public override int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe override int GetCharCount(byte* bytes, int count);
-   public override int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public override Decoder GetDecoder();
-   public override Encoder GetEncoder();
-   public override int GetMaxByteCount(int charCount);
-   public override int GetMaxCharCount(int byteCount);
-   public override string GetString(byte[] bytes, int byteIndex, int byteCount);
  }
- public abstract class Decoder {
-   protected Decoder();
-   public DecoderFallback Fallback { get; set; }
-   public DecoderFallbackBuffer FallbackBuffer { get; }
-   public unsafe virtual void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
-   public virtual void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
-   public unsafe virtual int GetCharCount(byte* bytes, int count, bool flush);
-   public abstract int GetCharCount(byte[] bytes, int index, int count);
-   public virtual int GetCharCount(byte[] bytes, int index, int count, bool flush);
-   public unsafe virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
-   public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
-   public virtual void Reset();
  }
- public sealed class DecoderExceptionFallback : DecoderFallback {
-   public DecoderExceptionFallback();
-   public override int MaxCharCount { get; }
-   public override DecoderFallbackBuffer CreateFallbackBuffer();
-   public override bool Equals(object value);
-   public override int GetHashCode();
  }
- public sealed class DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
-   public DecoderExceptionFallbackBuffer();
-   public override int Remaining { get; }
-   public override bool Fallback(byte[] bytesUnknown, int index);
-   public override char GetNextChar();
-   public override bool MovePrevious();
  }
- public abstract class DecoderFallback {
-   protected DecoderFallback();
-   public static DecoderFallback ExceptionFallback { get; }
-   public abstract int MaxCharCount { get; }
-   public static DecoderFallback ReplacementFallback { get; }
-   public abstract DecoderFallbackBuffer CreateFallbackBuffer();
  }
- public abstract class DecoderFallbackBuffer {
-   protected DecoderFallbackBuffer();
-   public abstract int Remaining { get; }
-   public abstract bool Fallback(byte[] bytesUnknown, int index);
-   public abstract char GetNextChar();
-   public abstract bool MovePrevious();
-   public virtual void Reset();
  }
- public sealed class DecoderFallbackException : ArgumentException {
-   public DecoderFallbackException();
-   public DecoderFallbackException(string message);
-   public DecoderFallbackException(string message, byte[] bytesUnknown, int index);
-   public DecoderFallbackException(string message, Exception innerException);
-   public byte[] BytesUnknown { get; }
-   public int Index { get; }
  }
- public sealed class DecoderReplacementFallback : DecoderFallback {
-   public DecoderReplacementFallback();
-   public DecoderReplacementFallback(string replacement);
-   public string DefaultString { get; }
-   public override int MaxCharCount { get; }
-   public override DecoderFallbackBuffer CreateFallbackBuffer();
-   public override bool Equals(object value);
-   public override int GetHashCode();
  }
- public sealed class DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
-   public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
-   public override int Remaining { get; }
-   public override bool Fallback(byte[] bytesUnknown, int index);
-   public override char GetNextChar();
-   public override bool MovePrevious();
-   public override void Reset();
  }
- public abstract class Encoder {
-   protected Encoder();
-   public EncoderFallback Fallback { get; set; }
-   public EncoderFallbackBuffer FallbackBuffer { get; }
-   public unsafe virtual void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
-   public virtual void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
-   public unsafe virtual int GetByteCount(char* chars, int count, bool flush);
-   public abstract int GetByteCount(char[] chars, int index, int count, bool flush);
-   public unsafe virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
-   public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
-   public virtual void Reset();
  }
- public sealed class EncoderExceptionFallback : EncoderFallback {
-   public EncoderExceptionFallback();
-   public override int MaxCharCount { get; }
-   public override EncoderFallbackBuffer CreateFallbackBuffer();
-   public override bool Equals(object value);
-   public override int GetHashCode();
  }
- public sealed class EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
-   public EncoderExceptionFallbackBuffer();
-   public override int Remaining { get; }
-   public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
-   public override bool Fallback(char charUnknown, int index);
-   public override char GetNextChar();
-   public override bool MovePrevious();
  }
- public abstract class EncoderFallback {
-   protected EncoderFallback();
-   public static EncoderFallback ExceptionFallback { get; }
-   public abstract int MaxCharCount { get; }
-   public static EncoderFallback ReplacementFallback { get; }
-   public abstract EncoderFallbackBuffer CreateFallbackBuffer();
  }
- public abstract class EncoderFallbackBuffer {
-   protected EncoderFallbackBuffer();
-   public abstract int Remaining { get; }
-   public abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
-   public abstract bool Fallback(char charUnknown, int index);
-   public abstract char GetNextChar();
-   public abstract bool MovePrevious();
-   public virtual void Reset();
  }
- public sealed class EncoderFallbackException : ArgumentException {
-   public EncoderFallbackException();
-   public EncoderFallbackException(string message);
-   public EncoderFallbackException(string message, Exception innerException);
-   public char CharUnknown { get; }
-   public char CharUnknownHigh { get; }
-   public char CharUnknownLow { get; }
-   public int Index { get; }
-   public bool IsUnknownSurrogate();
  }
- public sealed class EncoderReplacementFallback : EncoderFallback {
-   public EncoderReplacementFallback();
-   public EncoderReplacementFallback(string replacement);
-   public string DefaultString { get; }
-   public override int MaxCharCount { get; }
-   public override EncoderFallbackBuffer CreateFallbackBuffer();
-   public override bool Equals(object value);
-   public override int GetHashCode();
  }
- public sealed class EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
-   public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
-   public override int Remaining { get; }
-   public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
-   public override bool Fallback(char charUnknown, int index);
-   public override char GetNextChar();
-   public override bool MovePrevious();
-   public override void Reset();
  }
- public abstract class Encoding : ICloneable {
-   protected Encoding();
-   protected Encoding(int codePage);
-   protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
-   public static Encoding ASCII { get; }
-   public static Encoding BigEndianUnicode { get; }
-   public virtual string BodyName { get; }
-   public virtual int CodePage { get; }
-   public DecoderFallback DecoderFallback { get; set; }
-   public static Encoding Default { get; }
-   public EncoderFallback EncoderFallback { get; set; }
-   public virtual string EncodingName { get; }
-   public virtual string HeaderName { get; }
-   public virtual bool IsBrowserDisplay { get; }
-   public virtual bool IsBrowserSave { get; }
-   public virtual bool IsMailNewsDisplay { get; }
-   public virtual bool IsMailNewsSave { get; }
-   public bool IsReadOnly { get; }
-   public virtual bool IsSingleByte { get; }
-   public static Encoding Unicode { get; }
-   public static Encoding UTF32 { get; }
-   public static Encoding UTF7 { get; }
-   public static Encoding UTF8 { get; }
-   public virtual string WebName { get; }
-   public virtual int WindowsCodePage { get; }
-   public virtual object Clone();
-   public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes);
-   public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes, int index, int count);
-   public override bool Equals(object value);
-   public unsafe virtual int GetByteCount(char* chars, int count);
-   public virtual int GetByteCount(char[] chars);
-   public abstract int GetByteCount(char[] chars, int index, int count);
-   public virtual int GetByteCount(string s);
-   public unsafe virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public virtual byte[] GetBytes(char[] chars);
-   public virtual byte[] GetBytes(char[] chars, int index, int count);
-   public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public virtual byte[] GetBytes(string s);
-   public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe virtual int GetCharCount(byte* bytes, int count);
-   public virtual int GetCharCount(byte[] bytes);
-   public abstract int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public virtual char[] GetChars(byte[] bytes);
-   public virtual char[] GetChars(byte[] bytes, int index, int count);
-   public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public virtual Decoder GetDecoder();
-   public virtual Encoder GetEncoder();
-   public static Encoding GetEncoding(int codepage);
-   public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
-   public static Encoding GetEncoding(string name);
-   public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
-   public static EncodingInfo[] GetEncodings();
-   public override int GetHashCode();
-   public abstract int GetMaxByteCount(int charCount);
-   public abstract int GetMaxCharCount(int byteCount);
-   public virtual byte[] GetPreamble();
-   public unsafe string GetString(byte* bytes, int byteCount);
-   public virtual string GetString(byte[] bytes);
-   public virtual string GetString(byte[] bytes, int index, int count);
-   public bool IsAlwaysNormalized();
-   public virtual bool IsAlwaysNormalized(NormalizationForm form);
-   public static void RegisterProvider(EncodingProvider provider);
  }
- public sealed class EncodingInfo {
-   public int CodePage { get; }
-   public string DisplayName { get; }
-   public string Name { get; }
-   public override bool Equals(object value);
-   public Encoding GetEncoding();
-   public override int GetHashCode();
  }
- public abstract class EncodingProvider {
-   public EncodingProvider();
-   public abstract Encoding GetEncoding(int codepage);
-   public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
-   public abstract Encoding GetEncoding(string name);
-   public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
  }
- public enum NormalizationForm {
-   FormC = 1,
-   FormD = 2,
-   FormKC = 5,
-   FormKD = 6,
  }
  public sealed class StringBuilder : ISerializable {
    public StringBuilder();
    public StringBuilder(int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public int Capacity { get; set; }
    public int Length { get; set; }
    public int MaxCapacity { get; }
    [System.Runtime.CompilerServices.IndexerName("Chars")]
    public char this[int index] { get; set; }
    public StringBuilder Append(bool value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    public unsafe StringBuilder Append(char* value, int valueCount);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(char[] value);
    public StringBuilder Append(char[] value, int startIndex, int charCount);
    public StringBuilder Append(decimal value);
    public StringBuilder Append(double value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(object value);
    public StringBuilder Append(sbyte value);
    public StringBuilder Append(float value);
    public StringBuilder Append(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(ushort value);
    public StringBuilder Append(uint value);
    public StringBuilder Append(ulong value);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, params object[] args);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, params object[] args);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public StringBuilder Clear();
    public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
    public int EnsureCapacity(int capacity);
    public bool Equals(StringBuilder sb);
    public StringBuilder Insert(int index, bool value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, char[] value);
    public StringBuilder Insert(int index, char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, decimal value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Insert(int index, ushort value);
    public StringBuilder Insert(int index, uint value);
    public StringBuilder Insert(int index, ulong value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
-   void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public override string ToString();
    public string ToString(int startIndex, int length);
  }
- public class UnicodeEncoding : Encoding {
-   public const int CharSize = 2;
-   public UnicodeEncoding();
-   public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
-   public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
-   public override bool Equals(object value);
-   public unsafe override int GetByteCount(char* chars, int count);
-   public override int GetByteCount(char[] chars, int index, int count);
-   public override int GetByteCount(string s);
-   public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe override int GetCharCount(byte* bytes, int count);
-   public override int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public override Decoder GetDecoder();
-   public override Encoder GetEncoder();
-   public override int GetHashCode();
-   public override int GetMaxByteCount(int charCount);
-   public override int GetMaxCharCount(int byteCount);
-   public override byte[] GetPreamble();
-   public override string GetString(byte[] bytes, int index, int count);
  }
- public sealed class UTF32Encoding : Encoding {
-   public UTF32Encoding();
-   public UTF32Encoding(bool bigEndian, bool byteOrderMark);
-   public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
-   public override bool Equals(object value);
-   public unsafe override int GetByteCount(char* chars, int count);
-   public override int GetByteCount(char[] chars, int index, int count);
-   public override int GetByteCount(string s);
-   public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe override int GetCharCount(byte* bytes, int count);
-   public override int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public override Decoder GetDecoder();
-   public override Encoder GetEncoder();
-   public override int GetHashCode();
-   public override int GetMaxByteCount(int charCount);
-   public override int GetMaxCharCount(int byteCount);
-   public override byte[] GetPreamble();
-   public override string GetString(byte[] bytes, int index, int count);
  }
- public class UTF7Encoding : Encoding {
-   public UTF7Encoding();
-   public UTF7Encoding(bool allowOptionals);
-   public override bool Equals(object value);
-   public unsafe override int GetByteCount(char* chars, int count);
-   public override int GetByteCount(char[] chars, int index, int count);
-   public override int GetByteCount(string s);
-   public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe override int GetCharCount(byte* bytes, int count);
-   public override int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public override Decoder GetDecoder();
-   public override Encoder GetEncoder();
-   public override int GetHashCode();
-   public override int GetMaxByteCount(int charCount);
-   public override int GetMaxCharCount(int byteCount);
-   public override string GetString(byte[] bytes, int index, int count);
  }
- public class UTF8Encoding : Encoding {
-   public UTF8Encoding();
-   public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
-   public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
-   public override bool Equals(object value);
-   public unsafe override int GetByteCount(char* chars, int count);
-   public override int GetByteCount(char[] chars, int index, int count);
-   public override int GetByteCount(string chars);
-   public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
-   public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
-   public unsafe override int GetCharCount(byte* bytes, int count);
-   public override int GetCharCount(byte[] bytes, int index, int count);
-   public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
-   public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
-   public override Decoder GetDecoder();
-   public override Encoder GetEncoder();
-   public override int GetHashCode();
-   public override int GetMaxByteCount(int charCount);
-   public override int GetMaxCharCount(int byteCount);
-   public override byte[] GetPreamble();
-   public override string GetString(byte[] bytes, int index, int count);
  }
 }
 namespace System.Threading {
- public class AbandonedMutexException : SystemException {
-   public AbandonedMutexException();
-   public AbandonedMutexException(int location, WaitHandle handle);
-   protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
-   public AbandonedMutexException(string message);
-   public AbandonedMutexException(string message, Exception inner);
-   public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
-   public AbandonedMutexException(string message, int location, WaitHandle handle);
-   public Mutex Mutex { get; }
-   public int MutexIndex { get; }
  }
- public enum ApartmentState {
-   MTA = 1,
-   STA = 0,
-   Unknown = 2,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AsyncFlowControl : IDisposable {
-   public void Dispose();
-   public override bool Equals(object obj);
-   public bool Equals(AsyncFlowControl obj);
-   public override int GetHashCode();
-   public static bool operator ==(AsyncFlowControl a, AsyncFlowControl b);
-   public static bool operator !=(AsyncFlowControl a, AsyncFlowControl b);
-   public void Undo();
  }
- public sealed class AsyncLocal<T> {
-   public AsyncLocal();
-   public AsyncLocal(Action<AsyncLocalValueChangedArgs<T>> valueChangedHandler);
-   public T Value { get; set; }
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct AsyncLocalValueChangedArgs<T> {
-   public T CurrentValue { get; }
-   public T PreviousValue { get; }
-   public bool ThreadContextChanged { get; }
  }
- public sealed class AutoResetEvent : EventWaitHandle {
-   public AutoResetEvent(bool initialState);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CancellationToken {
-   public CancellationToken(bool canceled);
-   public bool CanBeCanceled { get; }
-   public bool IsCancellationRequested { get; }
-   public static CancellationToken None { get; }
-   public WaitHandle WaitHandle { get; }
-   public override bool Equals(object other);
-   public bool Equals(CancellationToken other);
-   public override int GetHashCode();
-   public static bool operator ==(CancellationToken left, CancellationToken right);
-   public static bool operator !=(CancellationToken left, CancellationToken right);
-   public CancellationTokenRegistration Register(Action callback);
-   public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
-   public CancellationTokenRegistration Register(Action<object> callback, object state);
-   public CancellationTokenRegistration Register(Action<object> callback, object state, bool useSynchronizationContext);
-   public void ThrowIfCancellationRequested();
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct CancellationTokenRegistration : IDisposable, IEquatable<CancellationTokenRegistration> {
-   public void Dispose();
-   public override bool Equals(object obj);
-   public bool Equals(CancellationTokenRegistration other);
-   public override int GetHashCode();
-   public static bool operator ==(CancellationTokenRegistration left, CancellationTokenRegistration right);
-   public static bool operator !=(CancellationTokenRegistration left, CancellationTokenRegistration right);
  }
- public class CancellationTokenSource : IDisposable {
-   public CancellationTokenSource();
-   public CancellationTokenSource(int millisecondsDelay);
-   public CancellationTokenSource(TimeSpan delay);
-   public bool IsCancellationRequested { get; }
-   public CancellationToken Token { get; }
-   public void Cancel();
-   public void Cancel(bool throwOnFirstException);
-   public void CancelAfter(int millisecondsDelay);
-   public void CancelAfter(TimeSpan delay);
-   public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
-   public static CancellationTokenSource CreateLinkedTokenSource(params CancellationToken[] tokens);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
  }
- public sealed class CompressedStack : ISerializable {
-   [MethodImpl(NoInlining)]public static CompressedStack Capture();
-   public CompressedStack CreateCopy();
-   [MethodImpl(NoInlining)]public static CompressedStack GetCompressedStack();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
  }
- public delegate void ContextCallback(object state);
- public class CountdownEvent : IDisposable {
-   public CountdownEvent(int initialCount);
-   public int CurrentCount { get; }
-   public int InitialCount { get; }
-   public bool IsSet { get; }
-   public WaitHandle WaitHandle { get; }
-   public void AddCount();
-   public void AddCount(int signalCount);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public void Reset();
-   public void Reset(int count);
-   public bool Signal();
-   public bool Signal(int signalCount);
-   public bool TryAddCount();
-   public bool TryAddCount(int signalCount);
-   public void Wait();
-   public bool Wait(int millisecondsTimeout);
-   public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
-   public void Wait(CancellationToken cancellationToken);
-   public bool Wait(TimeSpan timeout);
-   public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
  }
- public enum EventResetMode {
-   AutoReset = 0,
-   ManualReset = 1,
  }
- public class EventWaitHandle : WaitHandle {
-   public EventWaitHandle(bool initialState, EventResetMode mode);
-   public EventWaitHandle(bool initialState, EventResetMode mode, string name);
-   public EventWaitHandle(bool initialState, EventResetMode mode, string name, out bool createdNew);
-   public EventWaitHandle(bool initialState, EventResetMode mode, string name, out bool createdNew, EventWaitHandleSecurity eventSecurity);
-   public EventWaitHandleSecurity GetAccessControl();
-   public static EventWaitHandle OpenExisting(string name);
-   public static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);
-   public bool Reset();
-   public bool Set();
-   public void SetAccessControl(EventWaitHandleSecurity eventSecurity);
-   public static bool TryOpenExisting(string name, EventWaitHandleRights rights, out EventWaitHandle result);
-   public static bool TryOpenExisting(string name, out EventWaitHandle result);
  }
- public sealed class ExecutionContext : IDisposable, ISerializable {
-   [MethodImpl(NoInlining)]public static ExecutionContext Capture();
-   public ExecutionContext CreateCopy();
-   public void Dispose();
-   public void GetObjectData(SerializationInfo info, StreamingContext context);
-   public static bool IsFlowSuppressed();
-   public static void RestoreFlow();
-   public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
-   public static AsyncFlowControl SuppressFlow();
  }
- public class HostExecutionContext : IDisposable {
-   public HostExecutionContext();
-   public HostExecutionContext(object state);
-   protected internal object State { get; set; }
-   public virtual HostExecutionContext CreateCopy();
-   public void Dispose();
-   public virtual void Dispose(bool disposing);
  }
- public class HostExecutionContextManager {
-   public HostExecutionContextManager();
-   public virtual HostExecutionContext Capture();
-   public virtual void Revert(object previousState);
-   public virtual object SetHostExecutionContext(HostExecutionContext hostExecutionContext);
  }
- public static class Interlocked {
-   public static int Add(ref int location1, int value);
-   public static long Add(ref long location1, long value);
-   [MethodImpl(InternalCall)]public static double CompareExchange(ref double location1, double value, double comparand);
-   [MethodImpl(InternalCall)]public static int CompareExchange(ref int location1, int value, int comparand);
-   [MethodImpl(InternalCall)]public static long CompareExchange(ref long location1, long value, long comparand);
-   [MethodImpl(InternalCall)]public static IntPtr CompareExchange(ref IntPtr location1, IntPtr value, IntPtr comparand);
-   [MethodImpl(InternalCall)]public static object CompareExchange(ref object location1, object value, object comparand);
-   [MethodImpl(InternalCall)]public static float CompareExchange(ref float location1, float value, float comparand);
-   public static T CompareExchange<T>(ref T location1, T value, T comparand) where T : class;
-   public static int Decrement(ref int location);
-   public static long Decrement(ref long location);
-   [MethodImpl(InternalCall)]public static double Exchange(ref double location1, double value);
-   [MethodImpl(InternalCall)]public static int Exchange(ref int location1, int value);
-   [MethodImpl(InternalCall)]public static long Exchange(ref long location1, long value);
-   [MethodImpl(InternalCall)]public static IntPtr Exchange(ref IntPtr location1, IntPtr value);
-   [MethodImpl(InternalCall)]public static object Exchange(ref object location1, object value);
-   [MethodImpl(InternalCall)]public static float Exchange(ref float location1, float value);
-   public static T Exchange<T>(ref T location1, T value) where T : class;
-   public static int Increment(ref int location);
-   public static long Increment(ref long location);
-   public static void MemoryBarrier();
-   public static long Read(ref long location);
  }
- public unsafe delegate void IOCompletionCallback(uint errorCode, uint numBytes, NativeOverlapped* pOVERLAP);
- public static class LazyInitializer {
-   public static T EnsureInitialized<T>(ref T target) where T : class;
-   public static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock);
-   public static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock, Func<T> valueFactory);
-   public static T EnsureInitialized<T>(ref T target, Func<T> valueFactory) where T : class;
  }
  public enum LazyThreadSafetyMode {
    ExecutionAndPublication = 2,
    None = 0,
    PublicationOnly = 1,
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct LockCookie {
-   public override bool Equals(object obj);
-   public bool Equals(LockCookie obj);
-   public override int GetHashCode();
-   public static bool operator ==(LockCookie a, LockCookie b);
-   public static bool operator !=(LockCookie a, LockCookie b);
  }
- public class LockRecursionException : Exception {
-   public LockRecursionException();
-   protected LockRecursionException(SerializationInfo info, StreamingContext context);
-   public LockRecursionException(string message);
-   public LockRecursionException(string message, Exception innerException);
  }
- public sealed class ManualResetEvent : EventWaitHandle {
-   public ManualResetEvent(bool initialState);
  }
- public class ManualResetEventSlim : IDisposable {
-   public ManualResetEventSlim();
-   public ManualResetEventSlim(bool initialState);
-   public ManualResetEventSlim(bool initialState, int spinCount);
-   public bool IsSet { get; }
-   public int SpinCount { get; }
-   public WaitHandle WaitHandle { get; }
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public void Reset();
-   public void Set();
-   public void Wait();
-   public bool Wait(int millisecondsTimeout);
-   public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
-   public void Wait(CancellationToken cancellationToken);
-   public bool Wait(TimeSpan timeout);
-   public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
  }
- public static class Monitor {
-   [MethodImpl(InternalCall)]public static void Enter(object obj);
-   public static void Enter(object obj, ref bool lockTaken);
-   [MethodImpl(InternalCall)]public static void Exit(object obj);
-   public static bool IsEntered(object obj);
-   public static void Pulse(object obj);
-   public static void PulseAll(object obj);
-   public static bool TryEnter(object obj);
-   public static void TryEnter(object obj, ref bool lockTaken);
-   public static bool TryEnter(object obj, int millisecondsTimeout);
-   public static void TryEnter(object obj, int millisecondsTimeout, ref bool lockTaken);
-   public static bool TryEnter(object obj, TimeSpan timeout);
-   public static void TryEnter(object obj, TimeSpan timeout, ref bool lockTaken);
-   public static bool Wait(object obj);
-   public static bool Wait(object obj, int millisecondsTimeout);
-   public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
-   public static bool Wait(object obj, TimeSpan timeout);
-   public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
  }
- public sealed class Mutex : WaitHandle {
-   public Mutex();
-   public Mutex(bool initiallyOwned);
-   public Mutex(bool initiallyOwned, string name);
-   public Mutex(bool initiallyOwned, string name, out bool createdNew);
-   public Mutex(bool initiallyOwned, string name, out bool createdNew, MutexSecurity mutexSecurity);
-   public MutexSecurity GetAccessControl();
-   public static Mutex OpenExisting(string name);
-   public static Mutex OpenExisting(string name, MutexRights rights);
-   public void ReleaseMutex();
-   public void SetAccessControl(MutexSecurity mutexSecurity);
-   public static bool TryOpenExisting(string name, MutexRights rights, out Mutex result);
-   public static bool TryOpenExisting(string name, out Mutex result);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct NativeOverlapped {
-   public int OffsetHigh;
-   public int OffsetLow;
-   public IntPtr EventHandle;
-   public IntPtr InternalHigh;
-   public IntPtr InternalLow;
  }
- public class Overlapped {
-   public Overlapped();
-   public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
-   public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
-   public IAsyncResult AsyncResult { get; set; }
-   public int EventHandle { get; set; }
-   public IntPtr EventHandleIntPtr { get; set; }
-   public int OffsetHigh { get; set; }
-   public int OffsetLow { get; set; }
-   public unsafe static void Free(NativeOverlapped* nativeOverlappedPtr);
-   public unsafe NativeOverlapped* Pack(IOCompletionCallback iocb);
-   public unsafe NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
-   public unsafe static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
-   public unsafe NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
-   public unsafe NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
  }
- public delegate void ParameterizedThreadStart(object obj);
- public sealed class ReaderWriterLock : CriticalFinalizerObject {
-   public ReaderWriterLock();
-   public bool IsReaderLockHeld { get; }
-   public bool IsWriterLockHeld { get; }
-   public int WriterSeqNum { get; }
-   public void AcquireReaderLock(int millisecondsTimeout);
-   public void AcquireReaderLock(TimeSpan timeout);
-   public void AcquireWriterLock(int millisecondsTimeout);
-   public void AcquireWriterLock(TimeSpan timeout);
-   [MethodImpl(InternalCall)]public bool AnyWritersSince(int seqNum);
-   public void DowngradeFromWriterLock(ref LockCookie lockCookie);
-   ~ReaderWriterLock();
-   public LockCookie ReleaseLock();
-   public void ReleaseReaderLock();
-   public void ReleaseWriterLock();
-   public void RestoreLock(ref LockCookie lockCookie);
-   public LockCookie UpgradeToWriterLock(int millisecondsTimeout);
-   public LockCookie UpgradeToWriterLock(TimeSpan timeout);
  }
- public sealed class RegisteredWaitHandle : MarshalByRefObject {
-   public bool Unregister(WaitHandle waitObject);
  }
- public class SemaphoreFullException : SystemException {
-   public SemaphoreFullException();
-   protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
-   public SemaphoreFullException(string message);
-   public SemaphoreFullException(string message, Exception innerException);
  }
- public class SemaphoreSlim : IDisposable {
-   public SemaphoreSlim(int initialCount);
-   public SemaphoreSlim(int initialCount, int maxCount);
-   public WaitHandle AvailableWaitHandle { get; }
-   public int CurrentCount { get; }
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public int Release();
-   public int Release(int releaseCount);
-   public void Wait();
-   public bool Wait(int millisecondsTimeout);
-   public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
-   public void Wait(CancellationToken cancellationToken);
-   public bool Wait(TimeSpan timeout);
-   public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
-   public Task WaitAsync();
-   public Task<bool> WaitAsync(int millisecondsTimeout);
-   public Task<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
-   public Task WaitAsync(CancellationToken cancellationToken);
-   public Task<bool> WaitAsync(TimeSpan timeout);
-   public Task<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
  }
- public delegate void SendOrPostCallback(object state);
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SpinLock {
-   public SpinLock(bool enableThreadOwnerTracking);
-   public bool IsHeld { get; }
-   public bool IsHeldByCurrentThread { get; }
-   public bool IsThreadOwnerTrackingEnabled { get; }
-   public void Enter(ref bool lockTaken);
-   public void Exit();
-   public void Exit(bool useMemoryBarrier);
-   public void TryEnter(ref bool lockTaken);
-   public void TryEnter(int millisecondsTimeout, ref bool lockTaken);
-   public void TryEnter(TimeSpan timeout, ref bool lockTaken);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct SpinWait {
-   public int Count { get; }
-   public bool NextSpinWillYield { get; }
-   public void Reset();
-   public void SpinOnce();
-   public static void SpinUntil(Func<bool> condition);
-   public static bool SpinUntil(Func<bool> condition, int millisecondsTimeout);
-   public static bool SpinUntil(Func<bool> condition, TimeSpan timeout);
  }
- public class SynchronizationContext {
-   public SynchronizationContext();
-   public static SynchronizationContext Current { get; }
-   public virtual SynchronizationContext CreateCopy();
-   public bool IsWaitNotificationRequired();
-   public virtual void OperationCompleted();
-   public virtual void OperationStarted();
-   public virtual void Post(SendOrPostCallback d, object state);
-   public virtual void Send(SendOrPostCallback d, object state);
-   public static void SetSynchronizationContext(SynchronizationContext syncContext);
-   protected void SetWaitNotificationRequired();
-   public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
-   [MethodImpl(InternalCall)]protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
  }
- public class SynchronizationLockException : SystemException {
-   public SynchronizationLockException();
-   protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
-   public SynchronizationLockException(string message);
-   public SynchronizationLockException(string message, Exception innerException);
  }
- public sealed class Thread : CriticalFinalizerObject, _Thread {
-   public Thread(ParameterizedThreadStart start);
-   public Thread(ParameterizedThreadStart start, int maxStackSize);
-   public Thread(ThreadStart start);
-   public Thread(ThreadStart start, int maxStackSize);
-   public ApartmentState ApartmentState { get; set; }
-   public static Context CurrentContext { get; }
-   public CultureInfo CurrentCulture { get; set; }
-   public static IPrincipal CurrentPrincipal { get; set; }
-   public static Thread CurrentThread { get; }
-   public CultureInfo CurrentUICulture { get; set; }
-   public ExecutionContext ExecutionContext { get; }
-   public bool IsAlive { [MethodImpl(InternalCall)]get; }
-   public bool IsBackground { get; set; }
-   public bool IsThreadPoolThread { [MethodImpl(InternalCall)]get; }
-   public int ManagedThreadId { [MethodImpl(InternalCall)]get; }
-   public string Name { get; set; }
-   public ThreadPriority Priority { get; set; }
-   public ThreadState ThreadState { get; }
-   public void Abort();
-   public void Abort(object stateInfo);
-   public static LocalDataStoreSlot AllocateDataSlot();
-   public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
-   [MethodImpl(InternalCall)]public static void BeginCriticalRegion();
-   [MethodImpl(InternalCall)]public static void BeginThreadAffinity();
-   [MethodImpl(InternalCall)]public void DisableComObjectEagerCleanup();
-   [MethodImpl(InternalCall)]public static void EndCriticalRegion();
-   [MethodImpl(InternalCall)]public static void EndThreadAffinity();
-   ~Thread();
-   public static void FreeNamedDataSlot(string name);
-   public ApartmentState GetApartmentState();
-   public CompressedStack GetCompressedStack();
-   public static object GetData(LocalDataStoreSlot slot);
-   public static AppDomain GetDomain();
-   public static int GetDomainID();
-   public override int GetHashCode();
-   public static LocalDataStoreSlot GetNamedDataSlot(string name);
-   public void Interrupt();
-   public void Join();
-   public bool Join(int millisecondsTimeout);
-   public bool Join(TimeSpan timeout);
-   [MethodImpl(InternalCall)]public static void MemoryBarrier();
-   public static void ResetAbort();
-   public void Resume();
-   public void SetApartmentState(ApartmentState state);
-   public void SetCompressedStack(CompressedStack stack);
-   public static void SetData(LocalDataStoreSlot slot, object data);
-   public static void Sleep(int millisecondsTimeout);
-   public static void Sleep(TimeSpan timeout);
-   public static void SpinWait(int iterations);
-   [MethodImpl(NoInlining)]public void Start();
-   [MethodImpl(NoInlining)]public void Start(object parameter);
-   public void Suspend();
-   void System.Runtime.InteropServices._Thread.GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
-   void System.Runtime.InteropServices._Thread.GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
-   void System.Runtime.InteropServices._Thread.GetTypeInfoCount(out uint pcTInfo);
-   void System.Runtime.InteropServices._Thread.Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
-   public bool TrySetApartmentState(ApartmentState state);
-   [MethodImpl(NoInlining)]public static byte VolatileRead(ref byte address);
-   [MethodImpl(NoInlining)]public static double VolatileRead(ref double address);
-   [MethodImpl(NoInlining)]public static short VolatileRead(ref short address);
-   [MethodImpl(NoInlining)]public static int VolatileRead(ref int address);
-   [MethodImpl(NoInlining)]public static long VolatileRead(ref long address);
-   [MethodImpl(NoInlining)]public static IntPtr VolatileRead(ref IntPtr address);
-   [MethodImpl(NoInlining)]public static object VolatileRead(ref object address);
-   [MethodImpl(NoInlining)]public static sbyte VolatileRead(ref sbyte address);
-   [MethodImpl(NoInlining)]public static float VolatileRead(ref float address);
-   [MethodImpl(NoInlining)]public static ushort VolatileRead(ref ushort address);
-   [MethodImpl(NoInlining)]public static uint VolatileRead(ref uint address);
-   [MethodImpl(NoInlining)]public static ulong VolatileRead(ref ulong address);
-   [MethodImpl(NoInlining)]public static UIntPtr VolatileRead(ref UIntPtr address);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref byte address, byte value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref double address, double value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref short address, short value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref int address, int value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref long address, long value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref IntPtr address, IntPtr value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref object address, object value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref sbyte address, sbyte value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref float address, float value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref ushort address, ushort value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref uint address, uint value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref ulong address, ulong value);
-   [MethodImpl(NoInlining)]public static void VolatileWrite(ref UIntPtr address, UIntPtr value);
-   public static bool Yield();
  }
- public sealed class ThreadAbortException : SystemException {
-   public object ExceptionState { get; }
  }
- public class ThreadInterruptedException : SystemException {
-   public ThreadInterruptedException();
-   protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
-   public ThreadInterruptedException(string message);
-   public ThreadInterruptedException(string message, Exception innerException);
  }
- public class ThreadLocal<T> : IDisposable {
-   public ThreadLocal();
-   public ThreadLocal(bool trackAllValues);
-   public ThreadLocal(Func<T> valueFactory);
-   public ThreadLocal(Func<T> valueFactory, bool trackAllValues);
-   public bool IsValueCreated { get; }
-   public T Value { get; set; }
-   public IList<T> Values { get; }
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   ~ThreadLocal();
-   public override string ToString();
  }
- public static class ThreadPool {
-   public static bool BindHandle(IntPtr osHandle);
-   public static bool BindHandle(SafeHandle osHandle);
-   public static void GetAvailableThreads(out int workerThreads, out int completionPortThreads);
-   public static void GetMaxThreads(out int workerThreads, out int completionPortThreads);
-   public static void GetMinThreads(out int workerThreads, out int completionPortThreads);
-   [MethodImpl(NoInlining)]public static bool QueueUserWorkItem(WaitCallback callBack);
-   [MethodImpl(NoInlining)]public static bool QueueUserWorkItem(WaitCallback callBack, object state);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
-   public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
-   public static bool SetMinThreads(int workerThreads, int completionPortThreads);
-   public unsafe static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
-   [MethodImpl(NoInlining)]public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
-   [MethodImpl(NoInlining)]public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
  }
- public enum ThreadPriority {
-   AboveNormal = 3,
-   BelowNormal = 1,
-   Highest = 4,
-   Lowest = 0,
-   Normal = 2,
  }
- public delegate void ThreadStart();
- public sealed class ThreadStartException : SystemException {
  }
- public enum ThreadState {
-   Aborted = 256,
-   AbortRequested = 128,
-   Background = 4,
-   Running = 0,
-   Stopped = 16,
-   StopRequested = 1,
-   Suspended = 64,
-   SuspendRequested = 2,
-   Unstarted = 8,
-   WaitSleepJoin = 32,
  }
- public class ThreadStateException : SystemException {
-   public ThreadStateException();
-   protected ThreadStateException(SerializationInfo info, StreamingContext context);
-   public ThreadStateException(string message);
-   public ThreadStateException(string message, Exception innerException);
  }
  public static class Timeout {
    public const int Infinite = -1;
    public static readonly TimeSpan InfiniteTimeSpan;
  }
- public sealed class Timer : MarshalByRefObject, IDisposable {
-   [MethodImpl(NoInlining)]public Timer(TimerCallback callback);
-   [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, int dueTime, int period);
-   [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, long dueTime, long period);
-   [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
-   [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, uint dueTime, uint period);
-   public bool Change(int dueTime, int period);
-   public bool Change(long dueTime, long period);
-   public bool Change(TimeSpan dueTime, TimeSpan period);
-   public bool Change(uint dueTime, uint period);
-   public void Dispose();
-   public bool Dispose(WaitHandle notifyObject);
  }
- public delegate void TimerCallback(object state);
- public static class Volatile {
-   public static bool Read(ref bool location);
-   public static byte Read(ref byte location);
-   public static double Read(ref double location);
-   public static short Read(ref short location);
-   public static int Read(ref int location);
-   public static long Read(ref long location);
-   public static IntPtr Read(ref IntPtr location);
-   public static sbyte Read(ref sbyte location);
-   public static float Read(ref float location);
-   public static ushort Read(ref ushort location);
-   public static uint Read(ref uint location);
-   public static ulong Read(ref ulong location);
-   public static UIntPtr Read(ref UIntPtr location);
-   public static T Read<T>(ref T location) where T : class;
-   public static void Write(ref bool location, bool value);
-   public static void Write(ref byte location, byte value);
-   public static void Write(ref double location, double value);
-   public static void Write(ref short location, short value);
-   public static void Write(ref int location, int value);
-   public static void Write(ref long location, long value);
-   public static void Write(ref IntPtr location, IntPtr value);
-   public static void Write(ref sbyte location, sbyte value);
-   public static void Write(ref float location, float value);
-   public static void Write(ref ushort location, ushort value);
-   public static void Write(ref uint location, uint value);
-   public static void Write(ref ulong location, ulong value);
-   public static void Write(ref UIntPtr location, UIntPtr value);
-   public static void Write<T>(ref T location, T value) where T : class;
  }
- public delegate void WaitCallback(object state);
  public abstract class WaitHandle : MarshalByRefObject, IDisposable {
    public const int WaitTimeout = 258;
    protected static readonly IntPtr InvalidHandle;
    protected WaitHandle();
-   public virtual IntPtr Handle { get; set; }
-   public SafeWaitHandle SafeWaitHandle { get; set; }
-   public virtual void Close();
    public void Dispose();
    protected virtual void Dispose(bool explicitDisposing);
-   public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
-   public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
-   public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
-   public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
-   public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
-   public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
-   public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
-   public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout);
-   public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
  }
- public class WaitHandleCannotBeOpenedException : ApplicationException {
-   public WaitHandleCannotBeOpenedException();
-   protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
-   public WaitHandleCannotBeOpenedException(string message);
-   public WaitHandleCannotBeOpenedException(string message, Exception innerException);
  }
- public static class WaitHandleExtensions {
-   public static SafeWaitHandle GetSafeWaitHandle(this WaitHandle waitHandle);
-   public static void SetSafeWaitHandle(this WaitHandle waitHandle, SafeWaitHandle value);
  }
- public delegate void WaitOrTimerCallback(object state, bool timedOut);
 }
-namespace System.Threading.Tasks {
- public class ConcurrentExclusiveSchedulerPair {
-   public ConcurrentExclusiveSchedulerPair();
-   public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
-   public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
-   public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
-   public Task Completion { get; }
-   public TaskScheduler ConcurrentScheduler { get; }
-   public TaskScheduler ExclusiveScheduler { get; }
-   public void Complete();
  }
- public static class Parallel {
-   public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int, ParallelLoopState> body);
-   public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int> body);
-   public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action<int, ParallelLoopState> body);
-   public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action<int> body);
-   public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action<long, ParallelLoopState> body);
-   public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action<long> body);
-   public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action<long, ParallelLoopState> body);
-   public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action<long> body);
-   public static ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, Func<TLocal> localInit, Func<int, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<int, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, Func<TLocal> localInit, Func<long, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<long, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(OrderablePartitioner<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(OrderablePartitioner<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(Partitioner<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(Partitioner<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
-   public static ParallelLoopResult ForEach<TSource>(OrderablePartitioner<TSource> source, Action<TSource, ParallelLoopState, long> body);
-   public static ParallelLoopResult ForEach<TSource>(OrderablePartitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState, long> body);
-   public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, Action<TSource, ParallelLoopState> body);
-   public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, Action<TSource> body);
-   public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState> body);
-   public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource, ParallelLoopState, long> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource, ParallelLoopState> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState, long> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState> body);
-   public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource> body);
-   public static void Invoke(params Action[] actions);
-   public static void Invoke(ParallelOptions parallelOptions, params Action[] actions);
  }
- [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
  public struct ParallelLoopResult {
-   public bool IsCompleted { get; }
-   public Nullable<long> LowestBreakIteration { get; }
  }
- public class ParallelLoopState {
-   public bool IsExceptional { get; }
-   public bool IsStopped { get; }
-   public Nullable<long> LowestBreakIteration { get; }
-   public bool ShouldExitCurrentIteration { get; }
-   public void Break();
-   public void Stop();
  }
- public class ParallelOptions {
-   public ParallelOptions();
-   public CancellationToken CancellationToken { get; set; }
-   public int MaxDegreeOfParallelism { get; set; }
-   public TaskScheduler TaskScheduler { get; set; }
  }
- public class Task : IAsyncResult, IDisposable {
-   [MethodImpl(NoInlining)]public Task(Action action);
-   [MethodImpl(NoInlining)]public Task(Action action, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Action action, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Action<object> action, object state);
-   [MethodImpl(NoInlining)]public Task(Action<object> action, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task(Action<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Action<object> action, object state, TaskCreationOptions creationOptions);
-   public object AsyncState { get; }
-   public static Task CompletedTask { get; }
-   public TaskCreationOptions CreationOptions { get; }
-   public static Nullable<int> CurrentId { get; }
-   public AggregateException Exception { get; }
-   public static TaskFactory Factory { get; }
-   public int Id { get; }
-   public bool IsCanceled { get; }
-   public bool IsCompleted { get; }
-   public bool IsFaulted { get; }
-   public TaskStatus Status { get; }
-   WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
-   bool System.IAsyncResult.CompletedSynchronously { get; }
-   public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task, object> continuationAction, object state);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task> continuationAction, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskScheduler scheduler);
-   public static Task Delay(int millisecondsDelay);
-   public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
-   public static Task Delay(TimeSpan delay);
-   public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
-   public void Dispose();
-   protected virtual void Dispose(bool disposing);
-   public static Task FromCanceled(CancellationToken cancellationToken);
-   public static Task<TResult> FromCanceled<TResult>(CancellationToken cancellationToken);
-   public static Task FromException(Exception exception);
-   public static Task<TResult> FromException<TResult>(Exception exception);
-   public static Task<TResult> FromResult<TResult>(TResult result);
-   public TaskAwaiter GetAwaiter();
-   [MethodImpl(NoInlining)]public static Task Run(Action action);
-   [MethodImpl(NoInlining)]public static Task Run(Action action, CancellationToken cancellationToken);
-   public static Task Run(Func<Task> function);
-   public static Task Run(Func<Task> function, CancellationToken cancellationToken);
-   public static Task<TResult> Run<TResult>(Func<Task<TResult>> function);
-   public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public static Task<TResult> Run<TResult>(Func<TResult> function);
-   [MethodImpl(NoInlining)]public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken);
-   public void RunSynchronously();
-   public void RunSynchronously(TaskScheduler scheduler);
-   public void Start();
-   public void Start(TaskScheduler scheduler);
-   public void Wait();
-   public bool Wait(int millisecondsTimeout);
-   public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
-   public void Wait(CancellationToken cancellationToken);
-   public bool Wait(TimeSpan timeout);
-   [MethodImpl(NoOptimization)]public static void WaitAll(params Task[] tasks);
-   [MethodImpl(NoOptimization)]public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
-   [MethodImpl(NoOptimization)]public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
-   [MethodImpl(NoOptimization)]public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
-   [MethodImpl(NoOptimization)]public static bool WaitAll(Task[] tasks, TimeSpan timeout);
-   [MethodImpl(NoOptimization)]public static int WaitAny(params Task[] tasks);
-   [MethodImpl(NoOptimization)]public static int WaitAny(Task[] tasks, int millisecondsTimeout);
-   [MethodImpl(NoOptimization)]public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
-   [MethodImpl(NoOptimization)]public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
-   [MethodImpl(NoOptimization)]public static int WaitAny(Task[] tasks, TimeSpan timeout);
-   public static Task WhenAll(IEnumerable<Task> tasks);
-   public static Task WhenAll(params Task[] tasks);
-   public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks);
-   public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks);
-   public static Task<Task> WhenAny(IEnumerable<Task> tasks);
-   public static Task<Task> WhenAny(params Task[] tasks);
-   public static Task<Task<TResult>> WhenAny<TResult>(IEnumerable<Task<TResult>> tasks);
-   public static Task<Task<TResult>> WhenAny<TResult>(params Task<TResult>[] tasks);
-   public static YieldAwaitable Yield();
  }
- public class Task<TResult> : Task {
-   [MethodImpl(NoInlining)]public Task(Func<object, TResult> function, object state);
-   [MethodImpl(NoInlining)]public Task(Func<object, TResult> function, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Func<TResult> function);
-   [MethodImpl(NoInlining)]public Task(Func<TResult> function, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task(Func<TResult> function, TaskCreationOptions creationOptions);
-   public static new TaskFactory<TResult> Factory { get; }
-   public TResult Result { get; }
-   public new ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
-   public new TaskAwaiter<TResult> GetAwaiter();
  }
- public class TaskCanceledException : OperationCanceledException {
-   public TaskCanceledException();
-   protected TaskCanceledException(SerializationInfo info, StreamingContext context);
-   public TaskCanceledException(string message);
-   public TaskCanceledException(string message, Exception innerException);
-   public TaskCanceledException(Task task);
-   public Task Task { get; }
  }
- public class TaskCompletionSource<TResult> {
-   public TaskCompletionSource();
-   public TaskCompletionSource(object state);
-   public TaskCompletionSource(object state, TaskCreationOptions creationOptions);
-   public TaskCompletionSource(TaskCreationOptions creationOptions);
-   public Task<TResult> Task { get; }
-   public void SetCanceled();
-   public void SetException(IEnumerable<Exception> exceptions);
-   public void SetException(Exception exception);
-   public void SetResult(TResult result);
-   public bool TrySetCanceled();
-   public bool TrySetCanceled(CancellationToken cancellationToken);
-   public bool TrySetException(IEnumerable<Exception> exceptions);
-   public bool TrySetException(Exception exception);
-   public bool TrySetResult(TResult result);
  }
- public enum TaskContinuationOptions {
-   AttachedToParent = 4,
-   DenyChildAttach = 8,
-   ExecuteSynchronously = 524288,
-   HideScheduler = 16,
-   LazyCancellation = 32,
-   LongRunning = 2,
-   None = 0,
-   NotOnCanceled = 262144,
-   NotOnFaulted = 131072,
-   NotOnRanToCompletion = 65536,
-   OnlyOnCanceled = 196608,
-   OnlyOnFaulted = 327680,
-   OnlyOnRanToCompletion = 393216,
-   PreferFairness = 1,
-   RunContinuationsAsynchronously = 64,
  }
- public enum TaskCreationOptions {
-   AttachedToParent = 4,
-   DenyChildAttach = 8,
-   HideScheduler = 16,
-   LongRunning = 2,
-   None = 0,
-   PreferFairness = 1,
-   RunContinuationsAsynchronously = 64,
  }
- public class TaskFactory {
-   public TaskFactory();
-   public TaskFactory(CancellationToken cancellationToken);
-   public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
-   public TaskFactory(TaskScheduler scheduler);
-   public CancellationToken CancellationToken { get; }
-   public TaskContinuationOptions ContinuationOptions { get; }
-   public TaskCreationOptions CreationOptions { get; }
-   public TaskScheduler Scheduler { get; }
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   public Task FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, object state);
-   public Task FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod);
-   [MethodImpl(NoInlining)]public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   public Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
-   public Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
-   public Task FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
-   public Task FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
-   public Task<TResult> FromAsync<TArg1, TArg2, TResult>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
-   public Task<TResult> FromAsync<TArg1, TArg2, TResult>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
-   public Task FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
-   public Task FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
-   public Task<TResult> FromAsync<TArg1, TResult>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
-   public Task<TResult> FromAsync<TArg1, TResult>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
-   public Task FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, object state);
-   public Task FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
-   public Task<TResult> FromAsync<TResult>(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state);
-   public Task<TResult> FromAsync<TResult>(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task StartNew(Action action);
-   [MethodImpl(NoInlining)]public Task StartNew(Action action, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task StartNew(Action action, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task StartNew(Action<object> action, object state);
-   [MethodImpl(NoInlining)]public Task StartNew(Action<object> action, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task StartNew(Action<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task StartNew(Action<object> action, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<TResult> function);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<TResult> function, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew<TResult>(Func<TResult> function, TaskCreationOptions creationOptions);
  }
- public class TaskFactory<TResult> {
-   public TaskFactory();
-   public TaskFactory(CancellationToken cancellationToken);
-   public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
-   public TaskFactory(TaskScheduler scheduler);
-   public CancellationToken CancellationToken { get; }
-   public TaskContinuationOptions ContinuationOptions { get; }
-   public TaskCreationOptions CreationOptions { get; }
-   public TaskScheduler Scheduler { get; }
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
-   public Task<TResult> FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state);
-   public Task<TResult> FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   public Task<TResult> FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
-   public Task<TResult> FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
-   public Task<TResult> FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
-   public Task<TResult> FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
-   public Task<TResult> FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
-   public Task<TResult> FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<object, TResult> function, object state);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<object, TResult> function, object state, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<TResult> function);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<TResult> function, CancellationToken cancellationToken);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
-   [MethodImpl(NoInlining)]public Task<TResult> StartNew(Func<TResult> function, TaskCreationOptions creationOptions);
  }
- public abstract class TaskScheduler {
-   protected TaskScheduler();
-   public static TaskScheduler Current { get; }
-   public static TaskScheduler Default { get; }
-   public int Id { get; }
-   public virtual int MaximumConcurrencyLevel { get; }
-   public static event EventHandler<UnobservedTaskExceptionEventArgs> UnobservedTaskException;
-   public static TaskScheduler FromCurrentSynchronizationContext();
-   protected abstract IEnumerable<Task> GetScheduledTasks();
-   protected internal abstract void QueueTask(Task task);
-   protected internal virtual bool TryDequeue(Task task);
-   protected bool TryExecuteTask(Task task);
-   protected abstract bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
  }
- public class TaskSchedulerException : Exception {
-   public TaskSchedulerException();
-   public TaskSchedulerException(Exception innerException);
-   protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
-   public TaskSchedulerException(string message);
-   public TaskSchedulerException(string message, Exception innerException);
  }
- public enum TaskStatus {
-   Canceled = 6,
-   Created = 0,
-   Faulted = 7,
-   RanToCompletion = 5,
-   Running = 3,
-   WaitingForActivation = 1,
-   WaitingForChildrenToComplete = 4,
-   WaitingToRun = 2,
  }
- public class UnobservedTaskExceptionEventArgs : EventArgs {
-   public UnobservedTaskExceptionEventArgs(AggregateException exception);
-   public AggregateException Exception { get; }
-   public bool Observed { get; }
-   public void SetObserved();
  }
 }
```
